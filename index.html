<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="robots" content="noindex, nofollow">
<title>Primary Treatment — Design Challenge</title>
<style>
/* ---------------- Tooltip ---------------- */
.tooltip{ position:relative; display:inline-block; width:100%; }
.tooltip .tooltiptext{
visibility:hidden; width:220px; background:#1b2430; color:#fff;
text-align:left; border-radius:6px; padding:8px 10px;
position:absolute; z-index:1; top:-50px; left:0; opacity:0;
transition:opacity .3s; font-size:13px;
}
.tooltip:hover .tooltiptext{ visibility:visible; opacity:1; }
/* Hide whole control (wrapper div around label+input) */
.qs-hide{ display:none !important; }
/* ---------------- Theme / base ---------------- */
:root{
--panel: rgba(255,255,255,.96);
--ink:#1b2430; --muted:#5b6473; --line:#cfd6e3;
--accent:#0ea5e9; --good:#16a34a; --bad:#ef4444; --warn:#f59e0b;
}
*{box-sizing:border-box}
html,body{height:100%}
body { background-color:#e9ebef; }
/* Final Challenge wallpaper */
body.final-mode{
background-image: url('Picture1.png');
background-repeat:no-repeat;
background-position:center;
background-size:cover;
background-attachment:fixed;
}
/* ---------------- Layout shell ---------------- */
.wrap{ max-width:none; width:74vw; margin:70px auto; padding:0 12px; }
.board{
background:#2f3b45; border:1px solid var(--line); border-radius:10px; padding:12px;
box-shadow:0 14px 32px rgba(0,0,0,.12); backdrop-filter: blur(2px);
width:100%; min-height:800px; height:auto; margin:auto; overflow:visible;
}
header{display:flex; align-items:baseline; gap:12px; flex-wrap:wrap}
h1{ margin-left:10px; font-size:22px; letter-spacing:.2px;}
.muted{margin-left:10px; color:var(--muted); font-size:16px;font-weight:500;flex-basis: 100%; margin-top: 2px;}
.timer{margin-left:auto; font-variant-numeric:tabular-nums; font-weight:700}
.toolbar{display:flex; gap:12px; flex-wrap:wrap; margin:12px 0 14px}
button{background:#fff; border:1px solid var(--line);margin-left:10px; padding:10px 14px; border-radius:10px; cursor:pointer}
button.primary{background:#6E5F48; color:#fff; border-color:transparent}
/* ---------------- Grid ---------------- */
.grid{
display:grid; gap: 6px 12px;
grid-template-columns: repeat(12,1fr);
align-items:start;
grid-auto-rows:auto;
}
.card{background:#2f3b45; border-radius:12px; padding:10px; display:flex; flex-direction:column; min-height:auto; gap:4px;}
label{font-size:12px; color:#5b6473}
input,select{
height:auto; width:100%; padding:8px 10px; border-radius:10px; border:1px solid var(--line); background:#fff; color:#1b2430;
font-variant-numeric:tabular-nums;
}
input:disabled{background:#F2EDE6; color:#9ca3af}
.chip{display:flex; justify-content:space-between; align-items:center; gap:8px; background:#2f3b45; border:1px solid var(--line); border-radius:14px; padding:6px 10px; font-size:13px}
.ok{color:var(--good)} .bad{color:var(--bad)}
/* Scenario strip */
.plate-row{display:flex; flex-wrap:nowrap; align-items:baseline; gap:16px}
.plate{background:transparent; border:none; padding:8px 10px; display:inline-flex; gap:6px; align-items:baseline}
.plate .k{ margin-right:4px; font-weight:700; opacity:.85 } .plate .v{ font-weight:700 }
/* Titles / tank rows */
.tank-title{ font-weight:700; font-size:14px; margin-bottom:4px; color:var(--ink) }
.tank-row{border-top:1px dashed var(--line); padding-top:8px; margin-top:8px}
.tank-row .rowgrid{display:grid; grid-template-columns:repeat(3,1fr); gap:8px}
.tank-row .rowhdr{font-size:12px; color:var(--muted); margin-bottom:6px}
/* Back-calculation feedback */
input.pass{ outline:3px solid rgba(16,163,74,.35); border-color:#16a34a; }
input.fail{ outline:3px solid rgba(239,68,68,.35); border-color:#ef4444; }
.small-hint{ font-size:12px; color:#5b6473; margin-top:4px }
/* ---------------- Explicit placement ---------------- */
.scenario { grid-column: 1 / span 7; grid-row: 1; height:50px; min-height:unset; padding:6px 10px; }
.criteria { grid-column: 8 / span 5; grid-row: 1; }
/* ----- Branch CTA panel (right side under Criteria) ----- */
.cta-panel{
grid-column: 8 / span 5;
display:flex; flex-direction:column; gap:12px; padding:14px 16px;
background: rgba(193,185,168,0.824);
border-radius:12px; min-height:120px;
}
.cta-panel .cta-title{ font-weight:600; font-size:15px; color:var(--ink); }
.cta-panel .cta-sub{ font-size:13.5px; color:var(--muted); }
.cta-actions{ display:flex; gap:10px; flex-wrap:wrap; }
.btn-ghost{
appearance:none; border:1px solid var(--line); background:#fff;
padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600;
transition: transform .04s ease, box-shadow .12s ease, background-color .12s ease, border-color .12s ease;
}
.btn-ghost:hover{ box-shadow:0 4px 10px rgba(0,0,0,.08); border-color:#c5cdd9; }
.btn-ghost:active{ transform:translateY(1px); box-shadow:0 2px 6px rgba(0,0,0,.06); }
.btn-easy{ background:#ffffff; }
.btn-inter{ background:#ffffff; }
@media (max-width: 900px){
.cta-panel{ grid-column: 1 / -1; }
.cta-actions{ width:100%; }
.btn-ghost{ flex:1 1 220px; }
}
/* Row 2: Quickstart + calc3 placement */
.card.quickstart {
margin-top:-160px; grid-column:1 / span 5; align-self:start; padding:10px 12px; background: #2f3b45;
}
.calc3 {
grid-column:1 / span 7; align-self:start; margin-top:-80px; margin-bottom:10px; background:#2f3b45;
}
.calc1 { grid-column:1 / -1; align-self:start; margin-top:6px; background: #2f3b45; }
@media (max-width:1100px){
.calc3 .fields{ grid-template-columns: repeat(2, minmax(220px, 1fr)); }
.card.quickstart{ grid-column:1 / span 12;}
.calc3{ grid-column:1 / span 12; margin-top:-60px; }
}
@media (max-width:700px){ .calc3 .fields{ grid-template-columns:1fr; } }
/* ---------------- Start overlay ---------------- */
#startOverlay{position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background: rgba(0,0,0,.25); backdrop-filter: blur(2px); z-index:10}
#startCard{width:min(680px,92vw); background:var(--panel); border:1px solid var(--line); border-radius:18px; padding:24px; box-shadow:0 20px 40px rgba(0,0,0,.2); text-align:center}
#startCard h2{margin:0 0 8px 0; color: #0e0e0e;}
#startCard p{margin:0 0 16px 0; color:#0e0e0e}
#startBtn{font-size:16px; color: #f9f4ef;}
/* Align the Scenario card content */
.card.scenario { padding-left:10px; padding-right:10px; background: #2f3b45; }
.scenario .plate-row { padding-left:0;}
.scenario .plate { padding-left:0; padding-right:0; }
/* Easy Challenge wallpaper */
body.easy-mode{
background-image:url('Background-7.png');
background-repeat:no-repeat;
background-position:center;
background-size:cover;
background-attachment:fixed;
}
/* Easy start overlay */
#easyStartOverlay{
position:fixed; inset:0; display:none; align-items:center; justify-content:center;
background:transparent; backdrop-filter:none; z-index:2000;
}
#easyStartCard{
width:min(680px,92vw); background:var(--panel); border:1px solid var(--line);
border-radius:18px; padding:24px; box-shadow:0 20px 40px rgba(0,0,0,.2); text-align:center;
}
/* Calc-3 grid */
.calc3 .fields{
display:grid; grid-template-columns:repeat(3, minmax(200px,1fr)); gap:12px 16px; align-items:start;
}
@media (max-width:1100px){ .calc3 .fields{ grid-template-columns:repeat(2, minmax(220px,1fr)); } }
@media (max-width:700px){ .calc3 .fields{ grid-template-columns:1fr; } }
.calc3 .form-ctrl{ min-width:0; }
.calc3 .form-ctrl.has-help{ padding-bottom:0; }
.calc3 .form-ctrl .help{ display:none; }
/* === Easy Challenge · SOR Quiz (Part 1) — unified styles === */
.card.panel-dark.sor-quiz {
/* card look */
background:#2f3b45; color:#e8edf2;
border-radius:10px;
box-shadow:0 14px 32px rgba(0,0,0,.18);
/* layout */
display:grid;
grid-template-columns: 1fr 2px 1fr; /* left | divider | right */
grid-template-areas: "left divider right";
column-gap:30px; align-items:start;
/* spacing & size */
padding:28px 36px;
width:80%; min-height:520px;
margin:100px auto 0;
line-height:1.6;
}
/* grid areas */
.sor-left { grid-area:left; }
.sor-divider{
grid-area:divider;
width:2px; background:rgba(255,255,255,.25); border-radius:2px; height:100%;
}
.sor-right { grid-area:right; font-size: 20px; }
/* titles */
.card.panel-dark.sor-quiz h2{
font-size:26px; font-weight:800; letter-spacing:.2px; margin:0 0 12px;
}
.card.panel-dark.sor-quiz h3{
font-size:20px; font-weight:600; margin:0 0 20px;
}
/* left column first H2 centered */
.card.panel-dark.sor-quiz > .sor-left h2:first-child{
text-align:center; margin:0 0 20px;
}
/* example block (left) */
.card.panel-dark.sor-quiz .ex,
.card.panel-dark.sor-quiz .sor{
font-size:20px; line-height:1.6; margin:0;
}
.card.panel-dark.sor-quiz .ex{ color:#69DEE1; } /* teal for given values */
.card.panel-dark.sor-quiz .ex span{ color:#69DEE1; font-weight:700; }
.card.panel-dark.sor-quiz .sor{ color:#FFD966; } /* yellow for SOR result */
.card.panel-dark.sor-quiz .sor span{ color:#FFD966; font-weight:700; }
.sor-left, .sor-right {
display:flex;
flex-direction:column;
justify-content:flex-start; /* force content to start from top */
}
/* Right column text lines: same rhythm as Example */
.card.panel-dark.sor-quiz .sor-right .label,
.card.panel-dark.sor-quiz .sor-right p{
font-size: 20px;
line-height: 1.6;
margin: 0; /* kill default <p> margins */
}
.sor-right h2:first-child {
margin:0; /* kill default top margin on the heading */
}
/* options */
.card.panel-dark.sor-quiz .sor-opt{
border-radius:4px;
padding:12px 16px;
margin:0 8px 8px 0;
border:1px solid #cfd6e3;
background:#ffffff;
color:#1e2a35;
font-size: 16px;
font-weight:700;
box-shadow:0 1px 0 rgba(0,0,0,.06);
cursor:pointer;
min-width:80px; /* keeps consistent size */
}
/* flex only the buttons row */
#sorOptions {
display: flex;
justify-content: center; /* or space-evenly / space-between */
gap: 16px;
flex-wrap: nowrap;
}
.sor-right .sor-opt {
flex: 0 0 auto; /* don’t stretch, keep natural size */
width: 150px; /* fixed width for each button */
height: 60px; /* fixed height (optional) */
font-size: 18px;
}
.card.panel-dark.sor-quiz .sor-opt:hover{ filter:brightness(.98); }
.card.panel-dark.sor-quiz .sor-opt.correct{
background:#e8fbe9; border-color:#22c55e;
}
.card.panel-dark.sor-quiz .sor-opt.wrong{
background:#fde8e8; border-color:#ef4444;
}
/* score badge (top-right) */
.card.panel-dark.sor-quiz .sor-score{
position:absolute; top:16px; right:20px;
font-size:24px; font-weight:800; color:#FFD966;
}
/* action buttons */
#sorNext{
background:#e6d5c1; border:1px solid #cdb79c;
color:#0e0e0e; border-radius:10px;
padding:10px 16px; font-weight:700; font-size:16px;
margin-top:16px; display:inline-block; width:80px;
}
#sorNext:hover{ background:#d9c7b3; }
#sorNext:disabled{ opacity:.6; cursor:not-allowed; box-shadow:none; }
#testPart2{
background:#ffffff; border:1px solid #cfd6e3;
border-radius:10px; padding:10px 16px; cursor:pointer;
font-weight:700;
}
#testPart2:hover{ background:#f3f4f6; }
/* responsive */
@media (max-width:900px){
.card.panel-dark.sor-quiz{
grid-template-columns:1fr;
grid-template-areas:
"left"
"right";
row-gap:18px;
}
.sor-divider{ display:none; }
}
/* 1) Kill the tiny vertical nudge on the left block */
.card.panel-dark.sor-quiz .ex,
.card.panel-dark.sor-quiz .sor
card.panel-dark.sor-quiz .label{
font-size: 24px; /* or 20px, whichever you prefer */
line-height: 1.6;
position: static !important;
top: auto !important;
}
/* 2) Make the space under both column titles identical */
.card.panel-dark.sor-quiz .col-title{
margin-top: 0 !important;
margin-bottom: 12px !important; /* title → content gap (both sides) */
}
/* 3) Ensure the first content line begins at the same height on both sides */
.sor-left .ex:first-of-type,
.sor-right .label:first-of-type{
margin-top: 4px !important; /* small, even offset under the title */
}
/* 4) Neutralize the empty spacer divs so they don't add random gaps */
.card.panel-dark.sor-quiz .example-block,
.card.panel-dark.sor-quiz .question-block{
margin: 0 !important;
padding: 0 !important;
height: 0 !important;
}
/* 5) Keep numbers steady when they change (no width/wrap jitter) */
.sor-quiz .label strong,
.sor-quiz .ex span,
.sor-quiz .sor span{
font-variant-numeric: tabular-nums;
font-feature-settings: "tnum" 1, "lnum" 1;
}
/* make right-hand lines flex so gap is natural */
.sor-right .label {
display: flex;
align-items: baseline;
gap: .5ch; /* adjust gap size if needed */
}
/* no reserved width anymore */
.sor-quiz .label strong {
display: inline;
min-width: 0;
text-align: left;
font-variant-numeric: tabular-nums;
font-feature-settings: "tnum" 1, "lnum" 1;
}
.sor-quiz .label .unit,
.sor-quiz .ex .unit,
.sor-quiz .sor .unit{
white-space:nowrap; /* keeps m³/day and m² on one line */
}
/* Part-2: single-card layout */
.card.panel-dark.sor-range-quiz {
display: fl ex;
flex-direction: column;
align-items: center;
text-align: center;
background: #2f3b45;
color: #e8edf2;
width: 80%;
min-height: 400px;
margin: 100px auto 0;
padding: 24px;
border-radius: 12px;
}
/* Title + subtitle */
.sor-range-quiz h3 {
font-size: 24px;
margin-bottom: 8px;
}
.sor-range-quiz .subtitle {
font-size: 18px;
font-weight: 500;
margin-bottom: 20px;
}
/* Flow + area labels */
.sor-range-quiz .label {
font-size: 16px;
margin: 6px 0;
}
/* Options: wide centered buttons */
.sor-range-quiz .sor-options {
display: flex;
gap: 12px;
margin: 16px 0;
flex-wrap: wrap;
justify-content: center;
}
.sor-range-quiz .sor-opt {
min-width: 220px;
background: #d7efc2;
border: 1px solid #9bc17a;
border-radius: 8px;
padding: 12px 16px;
text-align: center;
}
.sor-range-quiz .sor-opt:hover { filter: brightness(.98); }
.sor-range-quiz .sor-opt.correct { border-color: #22c55e; }
.sor-range-quiz .sor-opt.wrong { border-color: #ef4444; }
/* Feedback + Next */
.sor-range-quiz #sorRangeFeedback {
margin-top: 12px;
font-size: 24px;
}
.sor-range-quiz #rangeNext {
margin-top: 18px;
}
/* Part-2: single-card layout */
.card.panel-dark.sor-range-quiz {
position: relative; /* needed for the HUD */
display: flex;
flex-direction: column;
align-items: center;
text-align: center;
width: 80%;
min-height: 400px;
margin: 100px auto 0;
padding: 24px;
border-radius: 12px;
}
/* HUD (Score + Timer) */
.sor-range-quiz .hud{
position: absolute;
top: 16px;
right: 20px;
display: flex;
gap: 12px;
align-items: center;
}
.sor-range-quiz #rangeScore{
font-weight: 800;
color: #FFD966;
font-size: 18px;
}
.sor-range-quiz #rangeTimer{
font-weight: 800;
font-variant-numeric: tabular-nums;
color: #e8edf2;
padding: 6px 10px;
border-radius: 10px;
min-width: 52px;
text-align: center;
}
/* Title + subtitle */
.sor-range-quiz h3 {
font-size: 26px;
margin-bottom: 8px;
}
.sor-range-quiz .subtitle {
font-size: 18px;
font-weight: 500;
margin-bottom: 20px;
}
/* Flow + area labels */
.sor-range-quiz .label {
font-size: 16px;
margin: 6px 0;
}
/* Options: wide centered buttons */
.sor-range-quiz .sor-options {
display: flex;
gap: 12px;
margin: 16px 0;
flex-wrap: wrap;
justify-content: center;
}
.sor-range-quiz .sor-opt {
min-width: 240px;
background: #d7efc2;
border: 1px solid #9bc17a;
border-radius: 8px;
padding: 12px 16px;
text-align: left;
line-height: 1.35;
font-weight: 700;
}
.sor-range-quiz .sor-opt .t { display:block; }
.sor-range-quiz .sor-opt .s { display:block; font-weight:600; }
.sor-range-quiz .sor-opt:hover { filter: brightness(.98); }
.sor-range-quiz .sor-opt.correct { border-color: #22c55e; }
.sor-range-quiz .sor-opt.wrong { border-color: #ef4444; }
.sor-range-quiz #sorRangeFeedback { margin-top: 10px; font-size: 16px; }
/* Overlay for Part-2 */
#rangeStartOverlay {
position: fixed;
inset: 0;
display: none; /* shown by JS */
align-items: center;
justify-content: center;
background: rgba(0,0,0,.35);
backdrop-filter: blur(2px);
z-index: 3000;
}
#rangeStartCard {
width: min(600px, 92vw);
background: #ffffff;
border: 1px solid #ccc;
border-radius: 18px;
padding: 28px;
box-shadow: 0 20px 40px rgba(0,0,0,.25);
text-align: center;
}
#rangeStartCard h2 { margin: 0 0 12px 0; }
#rangeStartCard p { margin: 0 0 18px 0; color: #333; }
#rangeStartBtn {
font-size: 16px;
padding: 10px 20px;
border-radius: 10px;
}
/* Part-2 Results overlay */
#rangeResultOverlay{
position: fixed;
inset: 0;
display: none; /* shown by JS at time-up */
align-items: center;
justify-content: center;
background: rgba(0,0,0,.35);
backdrop-filter: blur(2px);
z-index: 3000;
}
#rangeResultCard{
width: min(640px, 92vw);
background: #ffffff;
border: 1px solid #cfd6e3;
border-radius: 18px;
padding: 26px;
box-shadow: 0 20px 40px rgba(0,0,0,.25);
text-align: center;
}
#rangeResultCard h2{ color: #222; margin: 0 0 10px 0; }
#rangeResultCard p { margin: 0 0 16px 0; color: #333; }
#rangeResultCard .result-score{
margin: 8px 0 18px 0;
font-size: 18px; color: #333;
}
#rangeResultCard .result-score .sep{ opacity: .5; margin: 0 8px; }
#rangeResultCard .btn-row{
display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;
}
#rangeRestartBtn, #rangeNextBtn, #rangeRetryBtn{
border-radius: 10px; padding: 10px 16px; cursor: pointer;
}
#rangeRestartBtn.primary, #rangeNextBtn.primary{
background: #D9CEBD; border: 1px solid #D9CEBD; color:#0e0e0e;
}
#rangeRetryBtn.secondary{
background: #fff; border: 1px solid #cfd6e3;
}
#sorRangeQuiz .button-row {
margin-top: 12px;
display: flex;
gap: 10px;
justify-content: flex-end;
}
body.intermediate-mode {
background-image: url('Background-9.png');
background-repeat: no-repeat;
background-position: center;
background-size: cover;
background-attachment: fixed;
}
#interStartOverlay {
position: fixed; inset: 0;
display: none; /* toggled by JS */
align-items: center; justify-content: center;
background: rgba(0,0,0,.35);
backdrop-filter: blur(2px);
z-index: 3000;
}
#interStartCard {
width: min(600px, 92vw);
background: #ffffff;
border: 1px solid #ccc;
border-radius: 18px;
padding: 28px;
box-shadow: 0 20px 40px rgba(0,0,0,.25);
text-align: center; color: #000;
}
/* ==== Intermediate (Practice) — Screenshot layout (fixed) ==== */
.card.panel-dark.inter-quiz{
position: relative;
width: 80%;
margin: 100px auto 0;
padding: 28px 36px 70px; /* extra bottom space for Next */
border-radius: 18px;
background: #2f3b45;
color: #e8edf2;
box-shadow: 0 20px 40px rgba(0,0,0,.25);
/* grid */
display: grid;
grid-template-columns: 1fr 2px 1fr; /* left | divider | right */
grid-template-rows: auto 1fr auto; /* title | content | next */
column-gap: 30px;
row-gap: 16px;
min-height: 480px;
}
/* Title centered across top row */
.inter-quiz .inter-title{
grid-column: 1 / -1;
grid-row: 1;
text-align: center;
font-size: 28px;
font-weight: 800;
margin: 0 0 6px 0;
letter-spacing: .2px;
}
/* Position each region explicitly */
.inter-left{
grid-column: 1;
grid-row: 2;
min-height: 220px; /* gives divider something to stretch against */
}
.inter-right{
grid-column: 3;
grid-row: 2 / 4; /* span content + next row */
}
.inter-divider{
grid-column: 2;
grid-row: 2 / 4; /* span content + next row */
background: #3b82f6; /* blue divider */
width: 2px;
border-radius: 2px;
align-self: stretch; /* <-- critical: full height */
}
/* Question text & feedback */
.inter-quiz .meta{ opacity:.95; margin-bottom: 10px; }
#interFeedback{ margin-top: 10px; min-height: 22px; }
/* Options — two green columns */
.opts-grid{
display: grid;
grid-template-columns: repeat(2, minmax(220px, 1fr));
gap: 12px;
margin: 14px 0 8px;
}
.inter-quiz #interOptions .sor-opt{
display:block; width:100%;
background: #d7efc2;
border: 1px solid #9bc17a;
color: #0f172a;
border-radius: 8px;
padding: 12px 16px;
text-align: left;
font-weight: 700;
}
.inter-quiz #interOptions .sor-opt:hover{ filter: brightness(.98); }
.inter-quiz #interOptions .sor-opt.correct{ border-color:#22c55e; }
.inter-quiz #interOptions .sor-opt.wrong { border-color:#ef4444; }
/* Hint centered under options */
.hint-row{ display:flex; justify-content:center; margin-top: 8px; }
.btn-hint{
background: #cfe0f5;
border: 1px solid #90a7c7;
color: #0e0e0e;
border-radius: 8px;
padding: 10px 18px;
font-weight: 700;
}
#interHint.used{ opacity:.7; pointer-events:none; }
/* Next bottom-right */
.next-row{
grid-column: 3;
grid-row: 3;
display:flex; justify-content:flex-end; align-items:flex-end;
}
.btn-next{
background: #e6d5c1;
border: 1px solid #cdb79c;
color: #0e0e0e;
border-radius: 8px;
padding: 10px 18px;
font-weight: 700;
}
.btn-next:disabled{ opacity:.6; cursor:not-allowed; }
/* Criteria list */
.criteria-list{ line-height:1.6; margin:0; padding-left:18px; }
.criteria-list li{ margin: 2px 0; }
/* Responsive: stack and hide divider */
@media (max-width: 900px){
.card.panel-dark.inter-quiz{
grid-template-columns: 1fr;
grid-template-rows: auto auto auto auto;
row-gap: 18px;
}
.inter-title{ grid-column:1; grid-row:1; }
.inter-right{ grid-column:1; grid-row:2; }
.inter-left { grid-column:1; grid-row:3; }
.next-row { grid-column:1; grid-row:4; }
}
.inter-divider{
grid-column: 2;
grid-row: 2 / 4; /* span content + next row */
background: #e8ecf3; /* blue divider */
width: 2px;
border-radius: 2px;
align-self: stretch; /* <-- critical */
}
/* ==== Practice HUD (Score + Timer) ==== */
.inter-hud{
position:absolute; /* #interQuiz is already position:relative */
top: 16px;
right: 20px;
display:flex;
gap:12px;
align-items:center;
}
#interScore{
font-weight:800;
color:#FFD966; /* yellow like earlier UI */
}
#interTimer{
font-weight:800;
font-variant-numeric: tabular-nums;
color:#e8edf2;
padding:6px 10px;
border-radius:10px;
min-width:64px;
text-align:center;
background: rgba(255,255,255,.08);
}
/* small helper to disable clicks when time is up */
.inter-locked .sor-opt{ pointer-events:none; opacity:.8; }
/* ==== SOR-only Practice Board ==== */
.card.sor-only-quiz {
position: relative;
width: 80%;
margin: 100px auto 0;
padding: 28px 36px 70px; /* extra space for Next btn */
border-radius: 16px;
background: #ffffff; /* white outer background */
color: #1e2a35;
box-shadow: 0 12px 28px rgba(0,0,0,.15);
display: grid;
grid-template-columns: 1fr 2px 1fr; /* left | divider | right */
grid-template-areas:
"title title title"
"left divider right"
"next divider right";
column-gap: 30px;
row-gap: 16px;
min-height: 480px;
}
/* Title */
.sor-only-quiz .quiz-title {
grid-area: title;
text-align: center;
font-size: 26px;
font-weight: 800;
margin: 0 0 12px;
letter-spacing: .3px;
color: #0e0e0e;
}
/* Left: question + options */
.sor-left { grid-area: left; }
.sor-only-quiz .meta { margin-bottom: 8px; font-size: 16px; }
.sor-only-quiz #sorOnlyFeedback { margin-top: 10px; min-height: 24px; }
/* Options: styled like Easy Part 2 */
#sorOnlyOptions {
display: flex;
flex-direction: column;
gap: 12px;
margin-top: 12px;
}
#sorOnlyOptions .sor-opt {
background: #d7efc2;
border: 1px solid #9bc17a;
border-radius: 8px;
padding: 12px 16px;
font-weight: 700;
text-align: left;
color: #0f172a;
cursor: pointer;
}
#sorOnlyOptions .sor-opt:hover { filter: brightness(.97); }
#sorOnlyOptions .sor-opt.correct { border-color: #22c55e; background:#e8fbe9; }
#sorOnlyOptions .sor-opt.wrong { border-color: #ef4444; background:#fde8e8; }
/* Divider */
.sor-divider {
grid-area: divider;
background: rgba(0,0,0,.15);
width: 2px;
border-radius: 2px;
}
/* Right: criteria (optional) */
.sor-right { grid-area: right; }
.sor-right h2 { margin-top: 0; }
.sor-right .criteria-list {
line-height: 1.6;
margin: 0;
padding-left: 18px;
}
/* Bottom-right Next */
.sor-next-row {
grid-area: next;
display: flex;
justify-content: flex-end;
align-items: flex-end;
}
.sor-only-quiz .btn-next {
background: #e6d5c1;
border: 1px solid #cdb79c;
border-radius: 8px;
padding: 10px 18px;
font-weight: 700;
color: #0e0e0e;
}
.sor-only-quiz .btn-next:disabled {
opacity: .6;
cursor: not-allowed;
}
/* HUD top-right (Score + Timer) */
.sor-hud {
position: absolute;
top: 16px;
right: 20px;
display: flex;
gap: 12px;
align-items: center;
}
#sorOnlyScore { font-weight: 800; color: #eab308; }
#sorOnlyTimer { font-weight: 800; background: rgba(0,0,0,.06);
padding: 6px 10px; border-radius: 10px; min-width: 52px;
text-align: center; }
/* Responsive: stack */
@media (max-width: 900px){
.card.sor-only-quiz{
grid-template-columns: 1fr;
grid-template-areas:
"title"
"left"
"right"
"next";
}
.sor-divider{ display:none; }
}
/* ===== SOR-only Practice — match Easy Part 2 ===== */
/* Make the page background plain for this mode */
body.soronly-mode{
background:#ffffff !important;
background-image:none !important;
}
/* Board */
.card.panel-dark.sor-only-quiz{
position:relative;
width:min(1100px, 92vw);
margin: 28px auto 80px;
padding: 28px 36px 80px; /* space for Next button */
border-radius:16px;
background:#2f3b45; /* dark panel like Easy Part 2 */
color:#e8edf2;
box-shadow:0 14px 32px rgba(0,0,0,.18);
display:flex; /* single column layout */
flex-direction:column;
align-items:center;
text-align:center;
}
/* Title */
.sor-only-quiz .sor-title{
font-size:32px;
font-weight:800;
margin: 4px 0 6px;
letter-spacing:.2px;
}
/* Body copy */
.sor-only-quiz .meta{
font-size:18px;
line-height:1.45;
}
.sor-only-quiz .meta + .meta{ margin-top:6px; }
/* Options row — big green buttons */
.sor-only-quiz .sor-opts{
display: flex;
flex-direction: column;
gap: 12px;
width: 100%; /* use full container width */
max-width: none; /* remove narrow center constraint */
margin: 22px 0 10px;
}
.sor-only-quiz .sor-opts .sor-opt{
width: 100%; /* always stretch full width */
min-height: 60px;
}
.sor-only-quiz .sor-opts .sor-opt:hover{ filter:brightness(.98); }
.sor-only-quiz .sor-opts .sor-opt.correct{ border-color:#22c55e; background:#e8fbe9; }
.sor-only-quiz .sor-opts .sor-opt.wrong { border-color:#ef4444; background:#fde8e8; }
/* Feedback */
#sorOnlyFeedback{ margin-top:10px; min-height:24px; }
/* Hint button (centered row) */
.sor-hint-row{ display:flex; justify-content:center; margin-top:10px; }
#sorOnlyHint{
background:#cfe0f5;
border:1px solid #90a7c7;
color:#0e0e0e;
border-radius:8px;
padding:10px 18px;
font-weight:700;
}
#sorOnlyHint.used{ opacity:.7; pointer-events:none; }
/* HUD top-right */
.sor-hud{
position:absolute; top:16px; right:20px;
display:flex; gap:16px; align-items:center;
}
#sorOnlyScore{ font-weight:800; color:#FFD166; }
#sorOnlyTimer{
font-weight:800; font-variant-numeric:tabular-nums;
padding:6px 10px; border-radius:10px;
background: rgba(255,255,255,.10);
min-width:56px; text-align:center;
}
/* Next button bottom-right */
.sor-next-row{ position:absolute; right:20px; bottom:20px; }
.sor-only-quiz .btn-next{
background:#6E5F48; color:#fff;
border:1px solid transparent;
border-radius:10px;
padding:12px 18px;
font-weight:700;
}
.sor-only-quiz .btn-next:disabled{ opacity:.6; cursor:not-allowed; }
/* Results overlay (use same look as your other overlays) */
#sorOnlyResultOverlay{
position:fixed; inset:0; display:none;
align-items:center; justify-content:center;
background:rgba(0,0,0,.35); backdrop-filter:blur(2px);
z-index:3500;
}
#sorOnlyResultCard{
width:min(640px,92vw);
background:#ffffff;
border:1px solid #cfd6e3;
border-radius:18px;
padding:26px;
box-shadow:0 20px 40px rgba(0,0,0,.25);
text-align:center;
}
/* Responsive */
@media (max-width:900px){
.sor-only-quiz .sor-opts .sor-opt{ min-width:260px; }
}
/* SOR-only result overlay text colors */
#sorOnlyResultCard h2 { color:#222; font-weight:800; }
#sorOnlyResultCard p,
#sorOnlyResultCard span,
#sorOnlyResultCard strong { color:#0e0e0e; }
/* Buttons (matches your other overlays) */
#sorOnlyRestartBtn.primary,
#sorOnlyNextBtn.primary{
background:#D9CEBD; border:1px solid #D9CEBD; color:#0e0e0e;
border-radius:10px; padding:10px 16px; font-weight:700;
}
#sorOnlyBackBtn.secondary{
background:#fff; color:#0e0e0e; border-radius:10px; padding:10px 16px; font-weight:700;
}
/* === Easy Challenge · Weir Quiz (Part 1) — styles (fixed) === */
.card.panel-dark.weir-quiz {
/* card look */
background:#2f3b45; color:#e8edf2;
border-radius:10px;
box-shadow:0 14px 32px rgba(0,0,0,.18);
/* layout */
display:grid;
grid-template-columns: 1fr 2px 1fr; /* left | divider | right */
grid-template-areas: "left divider right";
column-gap:30px; align-items:start;
/* spacing & size */
padding:28px 36px;
width:80%; min-height:520px;
margin:100px auto 0;
line-height:1.6;
}
/* grid areas */
.card.panel-dark.weir-quiz .weir-left { grid-area:left; }
.card.panel-dark.weir-quiz .weir-right { grid-area:right; }
.card.panel-dark.weir-quiz .weir-divider{
grid-area:divider;
width:2px; height:100%;
background:rgba(255,255,255,.25); border-radius:2px;
}
/* titles */
.card.panel-dark.weir-quiz h2{
font-size:26px; font-weight:800; letter-spacing:.2px; margin:0 0 12px;
}
.card.panel-dark.weir-quiz h3{
font-size:20px; font-weight:600; margin:0 0 20px;
}
/* left column first H2 centered */
.card.panel-dark.weir-quiz > .weir-left h2:first-child{
text-align:center; margin:0 0 20px;
}
/* example block (left) */
.card.panel-dark.weir-quiz .ex,
.card.panel-dark.weir-quiz .weir{
font-size:20px; line-height:1.6; margin:0;
}
.card.panel-dark.weir-quiz .ex { color:#69DEE1; }
.card.panel-dark.weir-quiz .ex span{ color:#69DEE1; font-weight:700; }
.card.panel-dark.weir-quiz .weir{ color:#FFD966; }
.card.panel-dark.weir-quiz .weir span{ color:#FFD966; font-weight:700; }
.weir-left, .weir-right {
display:flex;
flex-direction:column;
justify-content:flex-start;
}
/* Right column text lines */
.card.panel-dark.weir-quiz .weir-right .label,
.card.panel-dark.weir-quiz .weir-right p{
font-size:20px;
line-height:1.6;
margin:0;
}
.weir-right h2:first-child { margin:0; }
/* options */
#weirOptions {
display:flex;
justify-content:center; /* or space-evenly / space-between */
gap:16px;
flex-wrap:nowrap;
}
#weirOptions .weir-opt{
border-radius:4px;
padding:12px 16px;
margin:0 8px 8px 0;
border:1px solid #cfd6e3;
background:#ffffff;
color:#1e2a35;
font-size:16px;
font-weight:700;
box-shadow:0 1px 0 rgba(0,0,0,.06);
cursor:pointer;
min-width:80px;
}
#weirOptions .weir-opt:hover{ filter:brightness(.98); }
#weirOptions .weir-opt.correct{ background:#e8fbe9; border-color:#22c55e; }
#weirOptions .weir-opt.wrong { background:#fde8e8; border-color:#ef4444; }
/* score badge (top-right) */
.card.panel-dark.weir-quiz .weir-score{
position:absolute; top:16px; right:20px;
font-size:24px; font-weight:800; color:#FFD966;
}
/* action button (if used later) */
#weirNext{
background:#e6d5c1; border:1px solid #cdb79c;
color:#0e0e0e; border-radius:10px;
padding:10px 16px; font-weight:700; font-size:16px;
margin-top:16px; display:inline-block; width:80px;
}
#weirNext:hover{ background:#d9c7b3; }
#weirNext:disabled{ opacity:.6; cursor:not-allowed; box-shadow:none; }
/* responsive */
@media (max-width:900px){
.card.panel-dark.weir-quiz{
grid-template-columns:1fr;
grid-template-areas:"left" "right";
row-gap:18px;
}
.card.panel-dark.weir-quiz .weir-divider{ display:none; }
}
/* ——— Normalizers (fixed broken selector) ——— */
.card.panel-dark.weir-quiz .ex,
.card.panel-dark.weir-quiz .weir,
.card.panel-dark.weir-quiz .label{
font-variant-numeric: tabular-nums;
font-feature-settings: "tnum" 1, "lnum" 1;
}
.weir-right .label{
display:flex; align-items:baseline; gap:.5ch;
}
.weir-quiz .label strong{
display:inline-block; min-width:0.25ch; text-align:right;
}
.weir-quiz .label .unit,
.weir-quiz .ex .unit,
.weir-quiz .weir .unit{ white-space:nowrap; }
/* ===================== GLOBAL (tokens & components) ===================== */
/* Design tokens (single source of truth) */
:root{
/* colors */
--ink: #0e0e0e;
--muted: #e8edf2;
--panel-bg: #2f3b45; /* quiz board background */
--panel-shadow: 0 14px 32px rgba(0,0,0,.18);
--opt-bg: #d7efc2;
--opt-border: #9bc17a;
--opt-bg-correct: #e8fbe9;
--opt-border-correct: #22c55e;
--opt-bg-wrong: #fde8e8;
--opt-border-wrong: #ef4444;
--btn-next-bg: #6E5F48;
--btn-next-ink: #fff;
--btn-hint-bg: #cfe0f5;
--btn-hint-border: #90a7c7;
--score-ink: #FFD166;
--timer-bg: rgba(255,255,255,.10);
/* layout & type */
--radius-xl: 16px;
--radius-lg: 10px;
--space-1: 6px;
--space-2: 12px;
--space-3: 18px;
--space-4: 28px;
--title-size: 32px;
--subtitle-size: 20px;
--body-size: 18px;
--opt-min-h: 60px; /* consistent option height */
--opt-max-w: 480px; /* centered narrow stack width */
}
/* Global font for entire site */
body{
font-family: "Arial Rounded MT Bold","Arial Rounded MT",Arial,sans-serif;
color: var(--muted);
}
h1,h2,h3{ color: var(--muted); margin: 0; }
/* ================= Components ================= */
/* Quiz board panel (apply to all boards) */
.quiz-board{
position: relative;
width: min(1100px, 92vw);
margin: var(--space-4) auto 80px;
padding: var(--space-4) var(--space-4) calc(80px);
border-radius: var(--radius-xl);
background: var(--panel-bg);
color: var(--muted);
box-shadow: var(--panel-shadow);
display: flex;
flex-direction: column;
align-items: center;
text-align: center;
}
/* Titles */
.quiz-title{
font-size: var(--title-size);
font-weight: 800;
letter-spacing: .2px;
margin-bottom: var(--space-2);
}
.quiz-subtitle{
font-size: var(--subtitle-size);
font-weight: 700;
opacity: .95;
margin-bottom: var(--space-2);
}
.quiz-meta{ font-size: var(--body-size); line-height: 1.45; }
.quiz-meta + .quiz-meta{ margin-top: var(--space-1); }
/* HUD (Score + Timer) */
.quiz-hud{
position: absolute; top: 16px; right: 20px;
display: flex; gap: 16px; align-items: center;
}
.quiz-score{ font-weight: 800; color: var(--score-ink); }
.quiz-timer{
font-weight: 800; font-variant-numeric: tabular-nums;
padding: 6px 10px; border-radius: var(--radius-lg);
background: var(--timer-bg);
min-width: 56px; text-align: center;
}
/* Buttons – base + variants */
.btn{
border-radius: var(--radius-lg);
padding: 12px 18px;
font-weight: 700;
cursor: pointer;
border: 1px solid transparent;
}
.btn:disabled{ opacity:.6; cursor:not-allowed; }
.btn-next{
background: var(--btn-next-bg);
color: var(--btn-next-ink);
}
.btn-hint{
background: var(--btn-hint-bg);
border-color: var(--btn-hint-border);
color: var(--ink);
}
.btn-used{ opacity:.7; pointer-events:none; }
/* Next in bottom-right of board */
.quiz-next{
position: absolute; right: 20px; bottom: 20px;
}
/* Option list (stacked) */
.option-list{
display: flex;
flex-direction: column;
gap: var(--space-2);
width: 100%;
max-width: var(--opt-max-w);
margin: var(--space-3) auto var(--space-1);
}
.option-btn{
width: 100%;
min-height: var(--opt-min-h);
background: var(--opt-bg);
border: 1px solid var(--opt-border);
border-radius: var(--radius-lg);
padding: 14px 18px;
font-weight: 700;
text-align: left;
color: #0f172a;
box-shadow: 0 1px 0 rgba(0,0,0,.06);
}
.option-btn:hover{ filter: brightness(.98); }
.option-btn.correct{ background: var(--opt-bg-correct); border-color: var(--opt-border-correct); }
.option-btn.wrong { background: var(--opt-bg-wrong); border-color: var(--opt-border-wrong); }
/* Feedback slot under options */
.quiz-feedback{ margin-top: var(--space-1); min-height: 24px; }
/* Responsive tweak */
@media (max-width: 600px){
:root{ --opt-max-w: 100%; }
}
/* ===== Aliases: map existing elements to global components ===== */
/* Titles & meta (use existing elements with new classes where possible) */
#sorOnlyQuiz .sor-title { font-size: var(--title-size); font-weight:800; }
#sorOnlyStem, #sorOnlyGiven { font-size: var(--body-size); line-height:1.45; }
/* HUD */
#sorOnlyScore{ /* adopt .quiz-score */ font-weight:800; color: var(--score-ink); }
#sorOnlyTimer{ /* adopt .quiz-timer */ font-weight:800; font-variant-numeric:tabular-nums; padding:6px 10px; border-radius:var(--radius-lg); background:var(--timer-bg); min-width:56px; text-align:center; }
.sor-hud{ position:absolute; top:16px; right:20px; display:flex; gap:16px; align-items:center; }
/* Options */
#sorOnlyOptions{ /* adopt .option-list */ display:flex; flex-direction:column; gap:var(--space-2); width:100%; max-width:var(--opt-max-w); margin:var(--space-3) auto var(--space-1); }
#sorOnlyOptions .sor-opt{ /* adopt .option-btn */ width:100%; min-height:var(--opt-min-h); background:var(--opt-bg); border:1px solid var(--opt-border); border-radius:var(--radius-lg); padding:14px 18px; font-weight:700; text-align:left; color:#0f172a; box-shadow:0 1px 0 rgba(0,0,0,.06); }
#sorOnlyOptions .sor-opt:hover{ filter:brightness(.98); }
#sorOnlyOptions .sor-opt.correct{ background:var(--opt-bg-correct); border-color:var(--opt-border-correct); }
#sorOnlyOptions .sor-opt.wrong { background:var(--opt-bg-wrong); border-color:var(--opt-border-wrong); }
/* Hint + Next */
#sorOnlyHint{ /* btn + btn-hint */ background:var(--btn-hint-bg); border:1px solid var(--btn-hint-border); color:var(--ink); border-radius:var(--radius-lg); padding:10px 18px; font-weight:700; }
#sorOnlyHint.used{ opacity:.7; pointer-events:none; }
#sorOnlyNext{ /* btn + btn-next + quiz-next placement */ position:absolute; right:20px; bottom:20px; background:var(--btn-next-bg); color:var(--btn-next-ink); border-radius:var(--radius-lg); padding:12px 18px; font-weight:700; }
/* DEV: prevent layout collapse in narrow preview panes */
#gameWrap { min-width: 1280px; } /* use your real outer wrapper ID */
@media (max-width: 1280px){
body { min-width: 1280px; } /* fallback if wrapper ID changes */
}
/* Detention Easy: don't prepend "Score:" via CSS */
#detScore::before { content: none !important; }
/* Hide every "Retry" button but keep the DOM node so existing JS doesn't crash */
[id$="RetryBtn"] { display: none !important; }
/* Make sure Restart is always visible even if JS tried to hide it */
[id$="RestartBtn"] { display: inline-block !important; }
/* 1) Make all result overlay card text black */
[id$="ResultCard"] { color: #0e0e0e !important; }
[id$="ResultCard"] .result-score strong { color: #0e0e0e !important; } /* numbers too */
/* 2) Ensure buttons keep their theme colors (not black) */
[id$="ResultCard"] button.primary { color: #fff !important; }
[id$="ResultCard"] button.secondary { color: #1b2430 !important; } /* tweak if your secondary is different */
/* Make ALL result-overlay text black, but keep button labels themed */
[id$="ResultCard"] { color:#0e0e0e !important; }
/* Headings & body inside the card (beats any old .overlay h2 rules) */
[id$="ResultCard"] h1,
[id$="ResultCard"] h2,
[id$="ResultCard"] h3,
[id$="ResultCard"] p,
[id$="ResultCard"] .result-score,
[id$="ResultCard"] .result-score strong,
[id$="ResultCard"] .sep { color:#0e0e0e !important; text-shadow:none !important; }
/* Buttons keep their own colors */
[id$="ResultCard"] button.primary,
[id$="ResultCard"] button.primary * { color:#fff !important; }
[id$="ResultCard"] button.secondary,
[id$="ResultCard"] button.secondary * { color:#1b2430 !important; } /* adjust if your secondary is different */
/* === Result overlays: make cards same size as Start cards + add spacing === */
/* 1) Uniform card size */
[id$="ResultCard"]{
width: min(640px, 92vw) !important; /* match your Start cards */
padding: 28px 32px !important; /* a bit roomier */
border-radius: 18px; /* keep your rounded look */
text-align: center;
}
/* 2) Clean, consistent spacing inside the card */
[id$="ResultCard"] h1,
[id$="ResultCard"] h2 { margin: 0 0 12px !important; }
[id$="ResultCard"] p { margin: 8px 0 14px !important; }
[id$="ResultCard"] .result-score { margin: 10px 0 18px !important; }
/* 3) Button row: gap + top margin */
[id$="ResultCard"] .btn-row{
display: flex;
justify-content: center;
flex-wrap: wrap;
gap: 12px; /* space between buttons */
margin-top: 18px !important; /* space above buttons */
}
/* (optional) If any overlay forgot the .btn-row wrapper, give single buttons some air */
[id$="ResultCard"] > button { margin-top: 18px; }
#sorOnlyStartCard, #weir90StartCard, #det90StartCard{
background:#fff !important; border:1px solid #cfd6e3 !important; color:#0e0e0e !important;
width:min(640px,92vw) !important; padding:28px !important; border-radius:18px !important;
box-shadow:0 20px 40px rgba(0,0,0,.25) !important; text-align:center;
}
#sorOnlyStartCard h1, #sorOnlyStartCard h2, #sorOnlyStartCard p,
#weir90StartCard h1, #weir90StartCard h2, #weir90StartCard p,
#det90StartCard h1, #det90StartCard h2, #det90StartCard p{ color:#0e0e0e !important; }



/* FORCE size + layout for the Score tab */
#scoreDock{
  position: fixed;
  top: 50%;
  left: 16px;                /* left side; change to right:16px if needed */
  right: auto;
  transform: translateY(-50%);

  /* size — these win even against older rules */
  width: 50px !important;    /* thickness */
  height: 200px !important;  /* tallness */
  padding: 0 !important;
  box-sizing: border-box;

  /* center the vertical label */
  display: flex;
  align-items: center;
  justify-content: center;
  writing-mode: vertical-rl;
  text-orientation: mixed;

  z-index: 2147483600;
}
/* HIDE the Score tab during the Final Challenge */
body.final-mode #scoreDock{
  display: none !important;
}
/* FORCE size + layout for the Score tab */
#scoreDock{
  position: fixed;
  top: 50%;
  left: 16px;
  right: auto;
  transform: translateY(-50%);
  width: 50px !important;
  height: 200px !important;
  padding: 0 !important;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  writing-mode: vertical-rl;
  text-orientation: mixed;
  z-index: 2147483600;
}


</style>
</head>
<body>
<!-- Start layer -->
<div id="startOverlay">
<div id="startCard">
<h2>Primary Clarifier — The Final Design Challenge</h2>
<p>Click <strong>Start</strong> button.</p>
<button id="startBtn" class="primary">Start</button>
</div>
</div>
<!-- Welcome layer shown BEFORE the Final Start overlay -->
<div id="finalWelcomeOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);z-index:3600;">
<div id="finalWelcomeCard" style="width:min(640px,92vw);background:#fff;border:1px solid var(--line);border-radius:18px;padding:26px;box-shadow:0 20px 40px rgba(0,0,0,.25);text-align:center;">
<h2 style="margin-top:0;color:#333;">Welcome</h2>
<p style="margin:0 0 16px 0;color:#333;">How familiar are you with wastewater management?</p>
<div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
<!-- Pro / Beginner buttons (use your existing button styles) -->
<button id="finalProBtn" class="primary" style="width:320px;height:44px;">I know basic wastewater management</button>
<button id="finalBeginBtn" class="primary" style="width:320px;height:44px;">I have minimal knowledge</button>
</div>
</div>
</div>
<!-- Final · Preview / Limited overlay -->
<div id="finalPreviewOverlay"
style="position:fixed; inset:0; display:none; align-items:center; justify-content:center;
background:rgba(0,0,0,.35); backdrop-filter:blur(2px); z-index:3700;">
<div id="finalPreviewCard"
style="width:min(640px,92vw); background:#fff; border:1px solid var(--line);
border-radius:18px; padding:26px; box-shadow:0 20px 40px rgba(0,0,0,.25); text-align:center;">
<h2 style="margin-top:0; color:#333;">Final (limited preview)</h2>
<p style="margin:0 0 8px 0; color:#333;">You need <strong>95%</strong> overall to unlock full access.</p>
<p style="margin:0 0 16px 0; color:#333;">
You’ve earned <strong><span id="finalPreviewPoints">0</span> points</strong> so far
(<strong><span id="finalPreviewPercent">0%</span></strong>).
</p>
<div style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:8px;">
<button id="finalPreviewTry" class="primary" style="width:220px; height:42px;">Preview Final Challenge anyways</button>
<button id="finalPreviewResume" class="primary" style="width:220px; height:42px;">Resume quiz</button>
<button id="finalPreviewExit" class="secondary" style="width:220px; height:42px;">Exit</button>
</div>
</div>
</div>
<div class="wrap" id="gameWrap" style="display:none;">
<div class="board">
<header>
<h1>Design the primary treatment plant for the given flow</h1>
<p style="font-size: 20px ;">There is no fixed order of the design process here. Start from wherever you like.</p>
<div class="timer" id="timer">⏱ 00:00</div>
</header>
<div class="toolbar">
<button class="primary" id="new"> New / Replay</button>
<button id="reset">↺ Reset inputs</button>
<button id="checkBtn"> Submit & Check</button>
</div>
<section class="grid">
<!-- Scenario plates -->
<div class="card scenario">
<div class="plate-row">
<div class="plate"><span class="k">Average flow:</span><span class="v"><span id="qavgPlate">—</span> m³/day</span></div>
<div class="plate"><span class="k">Peak factor:</span><span class="v" id="pfPlate">—</span></div>
</div>
<input id="qavg" type="hidden"><input id="pf" type="hidden">
</div>
<!-- Branching CTA panel -->
<div class="cta-panel" aria-label="Challenge options" style="background: #495e6e;">
<div class="cta-title" style="color: #e8edf2;">Try easier levels first and return here again</div>
<div class="cta-sub">Pick a path to practice before tackling the full design.</div>
<div class="cta-actions">
<button type="button" id="ctaEasy" class="btn-ghost btn-easy" aria-label="Easy Challenge">Easy Challenge</button>
<button type="button" id="ctaInter" class="btn-ghost btn-inter" aria-label="Intermediate Challenge">Intermediate Challenge</button>
</div>
</div>
<!-- Criteria -->
<div class="card criteria">
<div class="tank-title" style="color:#e8edf2">Design Criteria to be followed</div>
<div style="display:grid; grid-template-columns:1fr 1fr; gap:8px" >
<div class="chip"><span>Diameter 10–30 m</span><strong id="c_dia">—</strong></div>
<div class="chip"><span>Length:Width ≈ 4:1 (±0.2)</span><strong id="c_lw">—</strong></div>
<div class="chip"><span>Max Length ≤ 30 m</span><strong id="c_len">—</strong></div>
<div class="chip"><span>Max Width ≤ 8 m</span><strong id="c_brd">—</strong></div>
<div class="chip"><span>Depth 3–4 m</span><strong id="c_depth">—</strong></div>
<div class="chip"><span>Detention 2–4 h</span><strong id="c_t">—</strong></div>
<div class="chip"><span>SOR 20–40 m³/m²·d</span><strong id="c_sor">—</strong></div>
<div class="chip"><span>WLR 125–500 m³/m·d</span><strong id="c_wlr">—</strong></div>
</div>
</div>
<!-- Quickstart -->
<div class="card quickstart">
<label class="tank-title" style="color: #e8edf2;"for="startSelect">Start Here</label>
<div class="tooltip">
<select id="startSelect">
<option value="">— Select your starting point —</option>
<option value="sorVal">SOR (m³/m²·d)</option>
<option value="tVal">Detention time (h)</option>
<option value="wlrVal">WLR (m³/m·d)</option>
<option value="N">No. of tanks ≤ 8</option>
<option value="weir">Weir length / tank (m)</option>
<option value="Vtotal">Total volume (m³)</option>
</select>
<span class="tooltiptext">You can begin with any parameter. Your choice will update the main form automatically.</span>
</div>
</div>
<!-- Calc 3 -->
<div class="card calc3">
<div class="tank-title" style="color: #e8ecf2;">Your inputs will appear after your selection</div>
<div class="fields">
<div class="form-ctrl" id="sorField"><label for="sorVal"style="color: #e8edf2;">SOR (m³/m²·d)</label><input id="sorVal" class="checkable" type="number" step="0.01"></div>
<div class="form-ctrl" id="tField"><label for="tVal"style="color: #e8edf2;">Detention time (h)</label><input id="tVal" class="checkable" type="number" step="0.01"></div>
<div class="form-ctrl" id="wlrField"><label for="wlrVal"style="color: #e8edf2;">WLR (m³/m·d)</label><input id="wlrVal" class="checkable" type="number" step="0.01"></div>
<div class="form-ctrl" id="nField"><label for="N"style="color: #e8edf2;">No. of tanks ≤ 8</label><input id="N" class="checkable" type="number" min="1" max="8" step="1" value="1"></div>
<div class="form-ctrl" id="weirField"><label for="weir"style="color: #e8edf2;">Weir length / tank (m)</label><input id="weir" class="checkable" type="number" step="0.1"></div>
<div class="form-ctrl" id="volField"><label for="Vtotal"style="color: #e8edf2;">Total volume (m³)</label><input id="Vtotal" class="checkable" type="number" step="0.01"></div>
</div>
</div>
<!-- Tank 1 Dimensions -->
<div class="card calc1 qs-hide" id="calc1Card">
<div class="tank-title">Tank 1 Dimensions:Circular and/or Rectangular</div>
<div style="display:grid; grid-template-columns:repeat(3,1fr); gap:8px">
<div><label>Length L (m)</label><input id="L" class="checkable" type="number" step="0.1"></div>
<div><label>Breadth B (m)</label><input id="B" class="checkable" type="number" step="0.1"></div>
<div><label>Diameter Di (m)</label><input id="Di" class="checkable" type="number" step="0.1"></div>
<div><label>Depth D (m)</label><input id="D" class="checkable" type="number" step="0.1"></div>
<div id="extraTanks" style="grid-column:1/-1"></div>
</div>
</div>
</section>
</div>
</div>
<!-- Final Result (after Submit & Check) -->
<div id="finalResultOverlay" style="display:none; position:fixed; inset:0; z-index:3650;
background:rgba(0,0,0,.35); backdrop-filter:blur(2px); align-items:center; justify-content:center;">
<div id="finalResultCard" style="background:#fff; width:min(720px,92vw); border-radius:18px;
box-shadow:0 20px 60px rgba(0,0,0,.25); padding:24px; text-align:center;">
<h2 id="finalResultTitle" style="margin:0 0 8px; font-size:28px; font-weight:700; color:#2d2f31;">
Design check
</h2>
<p id="finalResultMsg" style="margin:0 0 12px; font-size:16px; color:#404346;">
We analyzed your design.
</p>
<ul id="finalResultList" style="margin:0 auto 16px; padding-left:20px; text-align:left; max-width:560px; color:#404346;"></ul>
<div style="display:flex; gap:12px; justify-content:center;">
<button id="finalResultEditBtn" class="primary">Continue editing</button>
<button id="finalResultReplayBtn" class="secondary">New / Replay</button>
</div>
</div>
</div>
<!-- Easy Challenge -->
<section id="easyChallenge" class="qs-hide">
<!-- ===== Easy Challenge · Topic Selection Overlay ===== -->
<div id="easyTopicOverlay" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.35); backdrop-filter:blur(2px); z-index:3000;">
<div id="easyTopicCard" style="width:min(620px,92vw); background:#ffffff; border:1px solid #cfd6e3; border-radius:18px; padding:24px; box-shadow:0 20px 40px rgba(0,0,0,.25); text-align:center;">
<h2 style="color:#0e0e0e; font-weight:800; margin:0 0 8px;">Pick a topic</h2>
<p style="color:#0e0e0e; margin:0 0 16px;">Choose what you want to practice in Easy level.</p>
<div style="display:grid; gap:10px; margin:10px auto; max-width:420px;">
<button id="topicSORBtn" class="primary" title="SOR sets plan-view area based on flow so tanks don't overflow." type="button">Surface Overflow Rate (SOR)</button>
<button id="topicWLRBtn" class="primary" title="WLR limits flow per meter of weir length to keep effluent quality." type="button">Weir Loading Rate (WLR)</button>
<button id="topicDetBtn" class="primary" title="Detention time ensures enough contact time for settling to work." type="button">Detention Time</button>
</div>
</div>
</div>
<!-- Easy start layer -->
<div id="easyStartOverlay">
<div id="easyStartCard">
<h2 style="color: #1b2430;">Easy Challenge (Level 1) </h2>
<p style="color: #1b2430;">Click <strong>Start</strong> to begin the intro-level practice.</p>
<button id="easyStartBtn" class="primary">Start</button>
</div>
</div>
<!-- SOR Quiz block -->
<div id="sorQuiz" class="card panel-dark sor-quiz qs-hide">
<div class="sor-left">
<h2 style="text-align:center; font-size:26px; font-weight:800; color:#060606; position: absolute; top: 30px; right: 580px ;">Surface Overflow Rate (SOR)</h2>
<h2 class="col-title" style="text-align: left;">Example</h2>
<div class="col-body example-block"></div>
<div class="ex" style="font-size:26px;">Average Flow: <span>5000</span> m³/day</div>
<div class="ex" style="font-size:26px;">Tank Area: <span>250</span> m²</div>
<div class="sor" style="font-size:26px;">SOR: 20 m³/day/m²</div>
</div>
<div class="sor-divider" aria-hidden="true"></div>
<div class="sor-right" >
<div id="sorScore" class="sor-score" style="padding-top:10px; position: absolute; top: 110px;right:190px; ">Score: 0</div>
<h2 class="col-title" style="text-align:left; font-size: 26px; font-weight:800; color:#e8ecf2;">Select the correct SOR</h2>
<div class="col-body question-block"></div>
<div class="label" style="text-align:left; font-size: 26px; color:#e8ecf2;">Average Flow: <strong id="qFlow">—</strong> m³/day</div>
<div class="label"style="text-align:left; font-size: 26px; ">Tank Area: <strong id="qArea">—</strong> m²</div>
<div style="margin:8px 0 4px;font-size: 26px; font-weight:800;">SOR ?</div>
<div id="sorOptions" class="sor-options" style="position:absolute; bottom:180px; justify-content: space-around;"></div>
<div id="sorFeedback"></div>
<button id="sorNext" class="primary" style="position: absolute; right:180px; bottom: 100px;" disabled>Next</button>
</div>
</div>
<!-- Start overlay for SOR Range Quiz 60 second (Part 2) -->
<div id="rangeStartOverlay">
<div id="rangeStartCard">
<h2 style="color: #060606;">The 60-Second Challenge</h2>
<p>How many can you get right in 60 seconds?</p>
<button id="rangeStartBtn" class="primary">Start</button>
</div>
</div>
<!-- SOR Range Quiz (Part 2) -->
<div id="sorRangeQuiz" class="card panel-dark sor-range-quiz qs-hide">
<!-- HUD: score + timer -->
<div class="hud">
<div id="rangeScore">Score: 0</div>
<div id="rangeTimer">60s</div>
</div>
<h3>Surface Overflow Rate (SOR)</h3>
<div class="subtitle">Select the correct category of the SOR</div>
<div class="label">Average Flow (m³/day): <strong id="qFlow2">—</strong></div>
<div class="label">Tank Area (m²): <strong id="qArea2">—</strong></div>
<div id="sorRangeOptions" class="sor-options"></div>
<div id="sorRangeFeedback"></div>
</div>
<!-- No Next button: it auto-advances -->
</div>
<!-- Part-2: Results overlay (shown when timer hits 0) -->
<div id="rangeResultOverlay">
<div id="rangeResultCard">
<h2 id="rangeResultTitle">Time’s up!</h2>
<p id="rangeResultMsg"></p>
<div class="result-score">
<span>Final:</span>
<strong id="rangeFinalScore" style="color: #000;">0</strong> pts
<span class="sep">•</span>
<span>Best:</span>
<strong id="rangeBestScore" style="color: #000;">0</strong> pts
</div>
<div class="btn-row">
<button id="rangeRestartBtn" class="primary">Restart</button>
<button id="rangeNextBtn" class="primary">Next</button>
</div>
</div>
</div>
</section>
<!-- ================= SOR-Only Practice 90 sec per question (no right-hand criteria) ================ -->
<section id="sorOnlySection" class="qs-hide" style="display:none;">
<!-- Start overlay -->
<div id="sorOnlyStartOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);z-index:3000;">
<div id="sorOnlyStartCard" style="width:min(600px,92vw);background:#2f3b45;border:1px solid #2f3b45;border-radius:18px;padding:28px;box-shadow:0 20px 40px rgba(0,0,0,.25);text-align:center;">
<h2>S O R — Practice (Level 2)</h2>
<p>Focus: flow handling (avg/peak), required area, tank dimensions, and number of tanks. 90 seconds per question.</p>
<button id="sorOnlyStartBtn" class="primary">Start</button>
</div>
</div>
<!-- Quiz board -->
<div id="sorOnlyQuiz" class="card panel-dark sor-only-quiz qs-hide">
<!-- Title -->
<h2 class="sor-title">SOR — Practice</h2>
<!-- HUD -->
<div class="sor-hud">
<div id="sorOnlyScore">Score: 0</div>
<div id="sorOnlyTimer">01:30</div>
</div>
<!-- Body: question + options + feedback + hint -->
<div class="sor-body">
<!-- Question text -->
<div id="sorOnlyStem" class="meta"></div>
<!-- Given / data line (criteria for this question live here) -->
<div id="sorOnlyGiven" class="meta"></div>
<!-- Options (2-column grid) -->
<div id="sorOnlyOptions" class="sor-opts"></div>
<!-- Feedback -->
<div id="sorOnlyFeedback"></div>
<!-- Hint -->
<div class="sor-hint-row">
<button id="sorOnlyHint" type="button">Hint</button>
</div>
</div>
<!-- Next button -->
<div class="sor-next-row">
<button id="sorOnlyNext" class="btn-next" disabled>Next</button>
</div>
</div>
<!-- Results overlay (SOR-only 90s) -->
<div id="sorOnlyResultOverlay" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.35); backdrop-filter:blur(2px); z-index:3500;">
<div id="sorOnlyResultCard" style="width:min(640px,92vw); background:#ffffff; border:1px solid #cfd6e3; border-radius:18px; padding:26px; box-shadow:0 20px 40px rgba(0,0,0,.25); text-align:center;">
<h2 id="sorOnlyResultTitle">Session complete</h2>
<p id="sorOnlyResultMsg" style="margin:8px 0 16px 0;">Nice run.</p>
<div class="score-line" style="margin:10px 0 18px;">
<span>Final:</span>
<strong id="sorOnlyFinalScore">0</strong> pts
<span class="sep" style="opacity:.5; margin:0 8px;">•</span>
<span>Best:</span>
<strong id="sorOnlyBestScore">0</strong> pts
</div>
<div class="btn-row" style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
<button id="sorOnlyRestartBtn" class="primary">Restart</button>
<button id="sorOnlyNextBtn" class="primary">Next: Intermediate</button>
</div>
</div>
</div>
</section>
<!-- Easy start layer Weir Loading Rate Part 1-->
<!-- Weir Quiz block -->
<div id="weirQuiz" class="card panel-dark weir-quiz qs-hide">
<div class="weir-left">
<h2 style="text-align:center; font-size:26px; font-weight:800; color:#060606; position:absolute; top:30px; right:580px;">
Weir Loading Rate (WLR)
</h2>
<h2 class="col-title" style="text-align:left;">Example</h2>
<div class="col-body example-block"></div>
<div class="ex" style="font-size:26px;">Average Flow: <span id="weirExQ">10000</span> m³/day</div>
<div class="ex" style="font-size:26px;">Weir Length: <span id="weirExL">50</span> m</div>
<div class="weir" style="font-size:26px;">WLR: <span id="weirExWL">200</span> m³/day/m</div>
</div>
<div class="weir-divider" aria-hidden="true"></div>
<div class="weir-right">
<div id="weirScore" class="weir-score" style="padding-top:10px; position:absolute; top:110px; right:190px;">
Score: 0
</div>
<h2 class="col-title" style="text-align:left; font-size:26px; font-weight:800; color:#e8ecf2;">Select the correct WLR</h2>
<div class="col-body question-block"></div>
<div class="label" style="text-align:left; font-size:26px; color:#e8ecf2;">
Average Flow: <strong id="weirGivenQ">—</strong> m³/day
</div>
<div class="label" style="text-align:left; font-size:26px;">
Weir Length: <strong id="weirGivenL">—</strong> m
</div>
<div style="margin:8px 0 4px; font-size:26px; font-weight:800;">WLR ?</div>
<!-- Options container — ID has no spaces; buttons will get class="weir-opt" -->
<div id="weirOptions" class="weir-options" style="position:absolute; bottom:180px; justify-content: space-around;"></div>
<div id="weirFeedback"></div>
</div>
</div>
<!-- ===== WEIR · Easy Challenge · 60-Second (Part 2) ===== -->
<!-- ===== Weir 60s · Start Overlay ===== -->
<div id="weir60StartOverlay"
style="position:fixed; inset:0; display:none; align-items:center; justify-content:center;
background:rgba(0,0,0,.35); backdrop-filter:blur(2px); z-index:3000;">
<div id="weir60StartCard"
style="width:min(620px,92vw); background:#ffffff; border:1px solid #cfd6e3;
border-radius:18px; padding:24px; box-shadow:0 20px 40px rgba(0,0,0,.25); text-align:center;">
<h2 style="color:#0e0e0e; font-weight:800; margin:0 0 8px;">Weir Loading Rate — 60 Second Challenge</h2>
<p style="color:#0e0e0e; margin:0 0 16px;">
How many can you get right in 60 seconds?
</p>
<div style="display:flex; gap:12px; justify-content:center;">
<button id="weir60StartBtn" class="primary" type="button">Start</button>
<button id="weir60BackBtn" class="secondary" type="button">Back</button>
</div>
</div>
</div>
<!-- ===== Weir 60s · Quiz ===== -->
<div id="weir60" class="card panel-dark sor-range-quiz qs-hide" style="display:none; position:relative;">
<!-- Top-right status: score + timer -->
<div style="position:absolute; top:12px; right:16px; font-weight:800;">
<span>Score: <span id="weir60Score">0</span></span>
<span id="weir60Timer" class="timer-badge" style="margin-left:12px;">60s</span>
</div>
<!-- Title + subtitle -->
<h3 style="font-size:24px; margin-bottom:8px;">Weir Loading Rate 60 Second Challenge</h3>
<p>How many can you get right in 60 seconds?</p>
<!-- Givens -->
<div class="label" style="font-size:20px; margin:6px 0;">
Average Flow: <strong id="weir60Q">—</strong> m³/day
</div>
<div class="label" style="font-size:20px; margin:6px 0;">
Weir Length: <strong id="weir60L">—</strong> m
</div>
<!-- Prompt -->
<div style="margin:8px 0 4px; font-size:20px; font-weight:700;">WLR ?</div>
<!-- Options (3 buttons) -->
<div id="weir60Options" class="sor-options" style="display:flex; gap:12px; margin:16px 0; flex-wrap:wrap; justify-content:center;"></div>
<!-- Feedback -->
<div id="weir60Feedback" style="margin-top:12px; font-size:18px; min-height:1.5em;"></div>
</div>
<!-- Weir 60s · Results overlay (SOR-style) -->
<div id="weir60ResultOverlay"
style="position:fixed; inset:0; display:none; align-items:center; justify-content:center;
background:rgba(0,0,0,.35); backdrop-filter:blur(2px); z-index:3000;">
<div id="weir60ResultCard"
style="width:min(620px,92vw); background:#ffffff; border:1px solid #cfd6e3;
border-radius:18px; padding:24px; box-shadow:0 20px 40px rgba(0,0,0,.25); text-align:center;">
<h2 id="weir60ResultTitle">Time’s up!</h2>
<p id="weir60ResultMsg" style="margin:8px 0 16px 0; color:#060606;"></p>
<div class="result-score" style="margin:10px 0 18px;">
<span>Final:</span>
<strong id="weir60FinalScore" style="color:#000;">0</strong> pts
<span class="sep" style="opacity:.5; margin:0 8px;">•</span>
<span>Best:</span>
<strong id="weir60BestScore" style="color:#000;">0</strong> pts
</div>
<div class="btn-row" style="display:flex; gap:12px; justify-content:center;">
<button id="weir60RestartBtn" class="primary" type="button">Restart</button>
<!-- ONE Next button only -->
<button id="weir60NextBtn" class="primary" type="button" data-next="weir90">Next</button>
</div>
</div>
</div>
<!-- ================= WEIR Practice 90 sec per question ================ -->
<section id="weir90Section" class="qs-hide" style="display:none;">
<!-- Start overlay -->
<div id="weir90StartOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);z-index:3000;">
<div id="weir90StartCard" style="width:min(600px,92vw);background:#2f3b45;border:1px solid #2f3b45;border-radius:18px;padding:28px;box-shadow:0 20px 40px rgba(0,0,0,.25);text-align:center;">
<h2>W E I R — Practice (Level 2)</h2>
<p>Focus: number of tanks, allowable/actual WOR, required weir length, and allowable flow. 90 seconds per question.</p>
<button id="weir90StartBtn" class="primary">Start</button>
</div>
</div>
<!-- Quiz board -->
<div id="weir90Quiz" class="card panel-dark sor-only-quiz qs-hide">
<h2 class="sor-title">Weir Loading Rate — Practice</h2>
<!-- HUD -->
<div class="sor-hud">
<div id="weir90Score">Score: 0</div>
<div id="weir90Timer">01:30</div>
</div>
<!-- Body -->
<div class="sor-body">
<div id="weir90Stem" class="meta"></div>
<div id="weir90Given" class="meta"></div>
<div id="weir90Options" class="sor-opts" ></div>
<div id="weir90Feedback"></div>
<div class="sor-hint-row">
<button id="weir90Hint" type="button">Hint</button>
</div>
</div>
<!-- (hidden) Next button, kept for parity -->
<div class="sor-next-row" style="display:none;">
<button id="weir90Next" class="btn-next" disabled>Next</button>
</div>
</div>
<!-- Results overlay -->
<div id="weir90ResultOverlay" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.35); backdrop-filter:blur(2px); z-index:3500;">
<div id="weir90ResultCard" style="width:min(640px,92vw); background:#ffffff; border:1px solid #cfd6e3; border-radius:18px; padding:26px; box-shadow:0 20px 40px rgba(0,0,0,.25); text-align:center;">
<h2 id="weir90ResultTitle">Session complete</h2>
<p id="weir90ResultMsg" style="margin:8px 0 16px 0;">Nice run.</p>
<div class="score-line" style="margin:10px 0 18px;">
<span>Final:</span>
<strong id="weir90FinalScore">0</strong> pts
<span class="sep" style="opacity:.5; margin:0 8px;">•</span>
<span>Best:</span>
<strong id="weir90BestScore">0</strong> pts
</div>
<div class="btn-row" style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
<button id="weir90RestartBtn" class="primary">Restart</button>
<button id="weir90NextBtn" class="primary">Next: Intermediate</button>

</div>
</div>
</div>
</section>
<!-- DETENTION TIME · Easy (Part 1) -->
<div id="detQuiz" class="card panel-dark sor-quiz qs-hide">
<div class="sor-left">
<h2 style="text-align:center; font-size:26px; font-weight:800; color:#060606; position:absolute; top:30px; right:580px;">
Detention Time
</h2>
<h2 class="col-title" style="text-align:left;">Example</h2>
<div class="col-body example-block"></div>
<!-- Example numbers chosen to give 6.0 h -->
<div class="ex" style="font-size:26px;">Average Flow: <span>12,000</span> m³/day</div>
<div class="ex" style="font-size:26px;">Tank Volume: <span>3,000</span> m³</div>
<div class="sor" style="font-size:26px;">Detention Time: 6.0 h</div>
</div>
<div class="sor-divider" aria-hidden="true"></div>
<div class="sor-right">
<div id="detScore" class="sor-score" style="padding-top:10px; position:absolute; top:110px; right:190px;">Score: 0</div>
<h2 class="col-title" style="text-align:left; font-size:26px; font-weight:800; color:#e8ecf2;">Select the correct Detention Time</h2>
<div class="col-body question-block"></div>
<div class="label" style="text-align:left; font-size:26px; color:#e8ecf2;">
Average Flow: <strong id="detGivenQ">—</strong> m³/day
</div>
<div class="label" style="text-align:left; font-size:26px;">
Tank Volume: <strong id="detGivenV">—</strong> m³
</div>
<div style="margin:8px 0 4px; font-size:26px; font-weight:800;">Detention Time ?</div>
<div id="detOptions" class="sor-options" style="position:absolute; bottom:180px; justify-content:space-around;"></div>
<div id="detFeedback"></div>
<!-- Kept for parity; we hide/disable it via JS just like SOR -->
<button id="detNext" class="primary" style="position:absolute; right:180px; bottom:100px;" disabled>Next</button>
</div>
</div>
<!-- ================= Detention Time — 60-second Challenge (Part 2) ================ -->
<!-- Start overlay -->
<div id="det60StartOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);z-index:3000;">
<div id="det60StartCard" style="width:min(600px,92vw);background:#fdfdfd;border:1px solid #cfd6e3;border-radius:18px;padding:28px;box-shadow:0 20px 40px rgba(0,0,0,.25);text-align:center;">
<h2 style="color:#0e0e0e;">The 60-Second Challenge</h2>
<p style="color:#0e0e0e;">How many detention times can you get right in 60 seconds?</p>
<button id="det60StartBtn" class="primary">Start</button>
</div>
</div>
<!-- Quiz board -->
<div id="det60Quiz" class="card panel-dark sor-range-quiz qs-hide" style="display:none;">
<!-- HUD: score + timer -->
<div class="hud">
<div id="det60Score">Score: 0</div>
<div id="det60Timer">60s</div>
</div>
<h3>Detention Time </h3>
<div class="subtitle">Pick the correct detention time (hours)</div>
<div class="label">Volume (m³): <strong id="det60V">—</strong></div>
<div class="label">Flow (m³/day): <strong id="det60Q">—</strong></div>
<div id="det60Options" class="sor-options"></div>
<div id="det60Feedback"></div>
</div>
<!-- Detention 60 sec Challenge: Results overlay -->
<div id="det60ResultOverlay"style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.35); backdrop-filter:blur(2px); z-index:3500;">
<div id="det60ResultCard"style="width:min(640px,92vw); background:#ffffff; border:1px solid #cfd6e3; border-radius:18px; padding:26px; box-shadow:0 20px 40px rgba(0,0,0,.25); text-align:center;" >
<h2 id="det60ResultTitle">Time’s up!</h2>
<p id="det60ResultMsg"></p>
<div class="result-score">
<span>Final:</span>
<strong id="det60FinalScore" style="color: #000;">0</strong> pts
<span class="sep">•</span>
<span>Best:</span>
<strong id="det60BestScore" style="color: #000;">0</strong> pts
</div>
<div class="btn-row">

<button id="det60RestartBtn" class="primary">Restart</button>
<button id="det60NextBtn" class="primary">Next</button>
</div>
</div>
</div>
<!-- ================= Detention Time — 90 sec per question ================ -->
<section id="det90Section" class="qs-hide" style="display:none;">
<!-- Start overlay -->
<div id="det90StartOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);z-index:3000;">
<div id="det90StartCard" style="width:min(600px,92vw);background:#2f3b45;border:1px solid #2f3b45;border-radius:18px;padding:28px;box-shadow:0 20px 40px rgba(0,0,0,.25);text-align:center;">
<h2>Detention Time — Practice (Level 2)</h2>
<p>Focus: t = 24·V/Q, multi-tank operation, design comparison, and min diameter with dual criteria. 90 seconds per question.</p>
<button id="det90StartBtn" class="primary">Start</button>
</div>
</div>
<!-- Quiz board -->
<div id="det90Quiz" class="card panel-dark sor-only-quiz qs-hide">
<h2 class="sor-title">Detention Time — Practice</h2>
<!-- HUD -->
<div class="sor-hud">
<div id="det90Score">Score: 0</div>
<div id="det90Timer">01:30</div>
</div>
<!-- Body -->
<div class="sor-body">
<div id="det90Stem" class="meta"></div>
<div id="det90Given" class="meta"></div>
<div id="det90Options" class="sor-opts"></div>
<div id="det90Feedback"></div>
<div class="sor-hint-row">
<button id="det90Hint" type="button">Hint</button>
</div>
</div>
<!-- (hidden) Next button, kept for parity -->
<div class="sor-next-row" style="display:none;">
<button id="det90Next" class="btn-next" disabled>Next</button>
</div>
</div>
<!-- Results overlay -->
<div id="det90ResultOverlay" style="position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.35); backdrop-filter:blur(2px); z-index:3500;">
<div id="det90ResultCard" style="width:min(640px,92vw); background:#ffffff; border:1px solid #cfd6e3; border-radius:18px; padding:26px; box-shadow:0 20px 40px rgba(0,0,0,.25); text-align:center;">
<h2 id="det90ResultTitle">Session complete</h2>
<p id="det90ResultMsg" style="margin:8px 0 16px 0;">Nice run.</p>
<div class="score-line" style="margin:10px 0 18px;">
<span>Final:</span>
<strong id="det90FinalScore">0</strong> pts
<span class="sep" style="opacity:.5; margin:0 8px;">•</span>
<span>Best:</span>
<strong id="det90BestScore">0</strong> pts
</div>
<div class="btn-row" style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap;">
<button id="det90RestartBtn" class="primary">Restart</button>
<button id="det90NextBtn" class="primary">Next: Intermediate</button>

</div>
</div>
</div>
</section>
<!-- ================= Intermediate Section ================ -->
<section id="intermediateSection" class="qs-hide">
<!-- Start overlay -->
<div id="interStartOverlay" style="display:none;">
<div id="interStartCard">
<h2 style="color: #000;">Intermediate Challenge</h2>
<p>All concepts of design calculations applied. Click <strong>Start</strong> to begin.</p>
<button id="interStartBtn" class="primary">Start</button>
</div>
</div>
<!-- Quiz board (Practice Mode, screenshot layout) -->
<div id="interQuiz" class="card panel-dark inter-quiz qs-hide">
<!-- TITLE -->
<h2 class="inter-title">Design Calculation- Practice</h2>
<!-- HUD -->
<div class="inter-hud">
<div id="interScore">Score: 0</div>
<div id="interTimer">01:30</div>
</div>
<!-- LEFT: question -->
<div class="inter-left">
<div id="interStem" class="meta"></div>
<div id="interGiven" class="meta"></div>
<div id="interOptions" class="opts-grid"></div><!-- options: 2-column green buttons -->
<div id="interFeedback"></div><!-- feedback -->
<div class="hint-row"> <!-- hint centered at bottom-left area -->
<button id="interHint" type="button" class="btn-hint">Hint</button>
</div>
</div>
<!-- BLUE divider -->
<div class="inter-divider" aria-hidden="true"></div>
<!-- RIGHT: fixed criteria -->
<div class="inter-right">
<h3>Design Criteria</h3>
<ul class="criteria-list">
<li><strong>Diameter:</strong> 10–30 m</li>
<li><strong>Length:Width</strong> ≈ 4:1 (±0.2)</li>
<li><strong>Max Length</strong> ≤ 30 m</li>
<li><strong>Max Width</strong> ≤ 8 m</li>
<li><strong>Depth:</strong> 3–4 m</li>
<li><strong>Detention:</strong> 2–4 h</li>
<li><strong>SOR:</strong> 20–40 m³/m²·d</li>
<li><strong>WLR:</strong> 125–500 m³/m·d</li>
</ul>
</div>
<!-- Next button bottom-right -->
<div class="next-row">
<button id="interNext" class="btn-next" disabled>Next</button>
</div>
</div>
<!-- Results overlay -->
<div id="interResultOverlay" style="position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);backdrop-filter:blur(2px);z-index:3500;">
<div id="interResultCard" style="width:min(640px,92vw);background:#fff;border:1px solid #cfd6e3;border-radius:18px;padding:26px;box-shadow:0 20px 40px rgba(0,0,0,.25);text-align:center;">
<h2 id="interResultTitle">Time’s up!</h2>
<p id="interResultMsg" style="margin:0 0 16px 0;color:#333;"></p>
<div class="btn-row" style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
<button id="interRestartBtn" class="primary">Restart</button>
<button id="interBackBtn" class="secondary" style="border:1px solid #cfd6e3;border-radius:10px;padding:10px 16px;">Final</button>
</div>
</div>
</div>
</section>
<style>
/* Final limited mode: dim & block other tiles */
body.final-limited [id^="cta"].locked {
opacity: .45;
pointer-events: none;
cursor: not-allowed;
}
</style>
<style>
/* Base look for WOR & Det 90s option buttons (neutral state only) */
#weir90Quiz .opt90:not(.wrong):not(.incorrect):not(.is-wrong):not([aria-invalid="true"]),
#det90Quiz .opt90:not(.wrong):not(.incorrect):not(.is-wrong):not([aria-invalid="true"]) {
background:#fff7e6; /* soft warm background */
border:1px solid #f4b84a; /* amber border */
color:#5a3b00; /* readable text */
}
#weir90Quiz .opt90:hover,
#det90Quiz .opt90:hover{
filter: brightness(0.98);
}
/* Keep your existing wrong/correct visuals intact by not overriding those classes */
</style>
<style>
/* Instant tooltip bubble */
.tip-host{ position:relative; }
.tip-host[data-tip]::after{
content: attr(data-tip);
position: absolute;
right: 0; /* bubble hugs the button's right edge */
bottom: 100%; /* show above the button */
margin-bottom: 8px;
transform: translateY(4px);
background: rgba(32,35,37,.95);
color: #fff;
font-size: 13px;
line-height: 1.35;
padding: 8px 10px;
border-radius: 8px;
box-shadow: 0 6px 20px rgba(0,0,0,.25);
white-space: nowrap;
opacity: 0;
pointer-events: none;
transition: opacity .08s ease, transform .08s ease;
z-index: 4000;
}
.tip-host[data-tip]:hover::after,
.tip-host[data-tip]:focus-visible::after{
opacity: 1;
transform: translateY(0);
}
@media (max-width:640px){
.tip-host[data-tip]::after{ white-space: normal; max-width: 260px; }
}
</style>
<style>
/* Colored Skip button */
#skipToFinalBtn{
background:#021bf5; /* button fill */
color:#fff; /* text */
border:1px solid #fff; /* subtle darker border */
box-shadow:0 2px 6px rgba(0,0,0,.15);
}
#skipToFinalBtn:hover{ transform: translateY(-1px); }
#skipToFinalBtn:focus-visible{ outline:2px solid #224ea6; outline-offset:2px; }
</style>
<!-- Skip to Final (limited) — fixed button (hidden by default) -->
<button id="skipToFinalBtn" class="secondary"
style="position:fixed; right:16px; bottom:16px; z-index:3900; display:none;">Optional: Skip to Final (limited)</button>

<style>
  /* Fullscreen overlay */
  .skip-overlay{
    position:fixed; inset:0; background:rgba(0,0,0,.5);
    display:none; z-index:2147483602;
  }
  .skip-overlay.show{ display:block; }

  /* Centered panel (same visual language as your boards) */
  .skip-panel{
    position:absolute; top:50%; left:50%; transform:translate(-50%,-50%) scale(.97);
    width:min(720px,92vw); max-height:80vh; overflow:auto;
    background:#1f2937; color:#e5e7eb; border-radius:16px;
    box-shadow:0 24px 60px rgba(0,0,0,.45);
    padding:20px 24px; opacity:1;
  }
  .skip-panel h3{ margin:0 0 12px; font:700 22px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#fff; }
  .skip-status{ margin:6px 0 14px; line-height:1.4; }
  .skip-actions{ display:flex; gap:10px; justify-content:flex-end; }
  .btn{ padding:10px 14px; border-radius:10px; border:0; font-weight:700; cursor:pointer; }
  .btn.primary{ background:#3f6cc9; color:#fff; }
  .btn.secondary{ background:#111827; color:#fff; }
  .btn[disabled]{ opacity:.5; cursor:not-allowed; }
  .skip-close{
    position:absolute; top:10px; right:12px; width:36px; height:36px;
    border-radius:50%; border:0; background:#111827; color:#fff; font-size:18px; cursor:pointer;
    display:flex; align-items:center; justify-content:center; line-height:1; padding:0;
  }
  
/* ===== EASY · PART 1 — Uniform option buttons across SOR / WLR / Detention ===== */

/* ===============================
   EASY · PART 1 — OPTION BUTTONS (FINAL, PER-TOPIC)
   Keep cards & typography unchanged. Only buttons/layout below.
   =============================== */

/* ——— SOR ———  (compact buttons; allow 2-line wrap for units) */
#sorOptions{
  display: grid !important;
  grid-template-columns: repeat(3, minmax(180px, 1fr)) !important;
  gap: 16px 18px !important;
  max-width: 840px !important;
  margin: 16px auto 0 !important;
  justify-items: center !important;
  align-items: stretch !important;
}
#sorOptions .sor-opt{
  width: 100% !important;
  max-width: 230px !important;
  min-height: 50px !important;
  padding: 8px 12px !important;
  display: flex !important; align-items: center !important; justify-content: center !important;
  text-align: center !important; box-sizing: border-box !important;
  white-space: normal !important;       /* wrap is OK here */
  word-break: keep-all !important;
  line-height: 1.22 !important;
  font-size: clamp(13px, 1.45vw, 16px) !important;
}
@media (max-width:1100px){
  #sorOptions{ grid-template-columns: repeat(2, minmax(180px, 1fr)) !important; max-width: 540px !important; }
}
@media (max-width:640px){
  #sorOptions{ grid-template-columns: 1fr !important; max-width: 340px !important; }
}

/* ——— WLR ———  (same feel as SOR; tiny bit wider cap) */
#weirOptions{
  display: grid !important;
  grid-template-columns: repeat(3, minmax(180px, 1fr)) !important;
  gap: 16px 18px !important;
  max-width: 860px !important;
  margin: 16px auto 0 !important;
  justify-items: center !important;
  align-items: stretch !important;
}
#weirOptions .weir-opt{
  width: 100% !important;
  max-width: 240px !important;
  min-height: 50px !important;
  padding: 8px 12px !important;
  display: flex !important; align-items: center !important; justify-content: center !important;
  text-align: center !important; box-sizing: border-box !important;
  white-space: normal !important;       /* wrap allowed */
  word-break: keep-all !important;
  line-height: 1.22 !important;
  font-size: clamp(13px, 1.45vw, 16px) !important;
}
@media (max-width:1100px){
  #weirOptions{ grid-template-columns: repeat(2, minmax(180px, 1fr)) !important; max-width: 560px !important; }
}
@media (max-width:640px){
  #weirOptions{ grid-template-columns: 1fr !important; max-width: 360px !important; }
}

/* ——— DETENTION ———  (preserve the look you liked; single-line labels) */
#detOptions{
  display: grid !important;
  grid-template-columns: repeat(3, minmax(200px, 1fr)) !important;
  gap: 18px 20px !important;
  max-width: 900px !important;
  margin: 18px auto 0 !important;
  justify-items: center !important;
  align-items: stretch !important;
}
#detOptions .det-opt{
  width: 100% !important;
  max-width: 260px !important;        /* slightly roomier than SOR/WLR */
  min-height: 60px !important;        /* keep the “Detention look” */
  padding: 10px 14px !important;
  display: flex !important; align-items: center !important; justify-content: center !important;
  text-align: center !important; box-sizing: border-box !important;
  white-space: nowrap !important;      /* keep “6.8 h” on one line */
  line-height: 1.2 !important;
  font-size: clamp(14px, 1.6vw, 17px) !important;
}
@media (max-width:1100px){
  #detOptions{ grid-template-columns: repeat(2, minmax(200px, 1fr)) !important; max-width: 600px !important; }
}
@media (max-width:640px){
  #detOptions{ grid-template-columns: 1fr !important; max-width: 380px !important; }
}
/* ===== Detention · Part 1 — align option buttons nicely ===== */

/* Vertically center the whole right column (title + labels + options) */
.card.panel-dark.det-quiz .det-right,
.card.panel-dark.detention-quiz .det-right{
  display: grid !important;
  align-content: center !important;   /* balances the block in the card */
  row-gap: 14px !important;
}

/* Nudge the options block up and keep it centered */
#detOptions{
  margin-top: 12px !important;        /* was taller → pushed row too low */
  align-self: center !important;      /* centers within right column */
  justify-items: center !important;
  align-items: stretch !important;
}

/* If your build uses only one of the det-quiz/detention-quiz classes, keeping both is harmless. */

/* Optional: on very wide screens, lift a hair more */
@media (min-width: 1400px){
  #detOptions{ margin-top: 8px !important; }
}



</style>

<!-- Reference dock + panel (global) -->
<div id="refDock" aria-controls="refPanel" aria-expanded="false" title="References">Reference</div>

<div id="refPanel" class="ref-panel" role="dialog" aria-labelledby="refTitle" aria-modal="true" hidden>
  <button class="ref-close" aria-label="Close references">×</button>
  <h3 id="refTitle">References</h3>
  <ol class="ref-list">
    <li>Chou, Y.-k. <em>Actionable Gamification: Beyond Points, Badges, and Leaderboards</em> [Kindle edition].</li>
    <li>Leroux, M.-J. <em>The Effective Gamification Framework</em>.</li>
    <li>Institute of Environmental Engineering &amp; Research, UET Lahore. <em>Water &amp; Wastewater Treatment Plant Design</em> [YouTube tutorials].</li>
    <li>OpenAI. <em>ChatGPT</em> [coding assistance].</li>
  </ol>
</div>
<style>
  :root{
    --ref-blue:#3f6cc9;      /* match your site blue if needed */
    --ref-text:#fff;
    --ref-card-bg:#1f2937;   /* panel background */
    --ref-card-fg:#e5e7eb;   /* panel text */
  }

  /* Docked vertical button on the right edge */
  #refDock{
  position:fixed; top:50%; right:16px; transform:translateY(-50%);
  width:50px; height:200px;
  background:var(--ref-blue); color:var(--ref-text);
  border:2px solid rgba(0,0,0,.35); border-radius:14px;
  box-shadow:0 6px 24px rgba(0,0,0,.25);
  font:600 18px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  cursor:pointer; user-select:none;

  /* vertical label + perfect centering */
  writing-mode:vertical-rl; text-orientation:mixed;
  display:flex; align-items:center; justify-content:center;
  padding: 15px; line-height:1; text-align:center;

  transform-origin:center;
  transition:left .55s ease, right .55s ease, transform .55s ease;
  z-index:2147483600;
}

  /* When opened, glide to center */
  #refDock.open{ left:50%; right:auto; transform:translate(-50%,-50%); }

  /* References panel */
  .ref-panel{
    position:fixed; top:50%; left:50%; transform:translate(-50%,-50%) scale(.95);
    width:min(720px,92vw); max-height:80vh; overflow:auto;
    background:var(--ref-card-bg); color:var(--ref-card-fg);
    border-radius:16px; box-shadow:0 24px 60px rgba(0,0,0,.45);
    padding:20px 24px; opacity:0; pointer-events:none;
    transition:opacity .25s ease, transform .25s ease;
    z-index:2147483601;
  }
  .ref-panel.show{ opacity:1; transform:translate(-50%,-50%) scale(1); pointer-events:auto; }
  .ref-panel h3{ margin:0 0 10px; font:700 22px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:#fff; }
  .ref-list{ margin:0; padding-left:20px; }
  .ref-close{
    position:absolute; top:10px; right:12px; width:34px; height:34px;
    border-radius:50%; border:0; background:#111827; color:#fff; 
    font-size:20px; cursor:pointer;
     /* center the X */
  display:flex; align-items:center; justify-content:center;
  line-height:1; padding:0;              
  }

  @media (prefers-reduced-motion: reduce){
    #refDock, .ref-panel{ transition:none; }
  }
  /* Hide the blue reference tab while the card is open */
#refDock.is-hidden { opacity: 0; pointer-events: none; }
</style>

<!-- Score dock + panel -->
<div id="scoreDock" aria-controls="scorePanel" aria-expanded="false" title="Scores">Score</div>

<div id="scorePanel" class="score-panel" role="dialog" aria-labelledby="scoreTitle" aria-modal="true" hidden>
  <button class="score-close" aria-label="Close score board">×</button>
  <h3 id="scoreTitle">Your Scores</h3>
  <div id="scoreTable" class="score-table"></div>
  <div id="scoreFooter" class="score-footer"></div>
</div>

<style>
  /* --- colours – tune if needed --- */
  :root{
    --score-blue:#3f6cc9;   /* tab */
    --score-text:#fff;
    --score-card-bg:#1f2937; /* panel */
    --score-card-fg:#e5e7eb;
    --score-accent:#10b981;  /* qualified green */
    --score-warn:#f59e0b;    /* “need N more” amber */
  }

  /* Right-edge vertical tab (same visual language as your Reference tab) */
  #scoreDock{
    position:fixed; top:50%; right:96px; transform:translateY(-50%); /* offset from right so it doesn’t clash with Reference */
    width:64px; height:180px;
    background:var(--score-blue); color:var(--score-text);
    border:2px solid rgba(0,0,0,.35); border-radius:14px;
    box-shadow:0 6px 24px rgba(0,0,0,.25);
    font:600 18px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    cursor:pointer; user-select:none;
    writing-mode:vertical-rl; text-orientation:mixed;
    display:flex; align-items:center; justify-content:center; text-align:center;
    padding:0; line-height:1;
    z-index:2147483600;
  }
  #scoreDock.is-hidden{ opacity:0; pointer-events:none; }

  /* Score board */
  .score-panel{
    position:fixed; top:50%; left:50%; transform:translate(-50%,-50%) scale(.95);
    width:min(720px,92vw); background:var(--score-card-bg); color:var(--score-card-fg);
    border-radius:16px; box-shadow:0 24px 60px rgba(0,0,0,.45);
    padding:20px 24px; opacity:0; pointer-events:none;
    transition:opacity .25s ease, transform .25s ease;
    z-index:2147483601; max-height:80vh; overflow:auto;
  }
  .score-panel.show{ opacity:1; transform:translate(-50%,-50%) scale(1); pointer-events:auto; }
  .score-panel h3{ margin:0 0 12px; font:700 22px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; color:#fff; }

  .score-close{
    position:absolute; top:10px; right:12px; width:36px; height:36px;
    border-radius:50%; border:0; background:#111827; color:#fff; font-size:18px; cursor:pointer;
    display:flex; align-items:center; justify-content:center; line-height:1; padding:0;
  }
  .score-table{ display:grid; gap:8px; }
  .score-row{ display:grid; grid-template-columns: 1fr auto; gap:12px; align-items:center; }
  .score-row .name{ font-weight:600; }
  .score-row .value{ font-variant-numeric: tabular-nums; }
  .score-footer{ margin-top:14px; font-weight:700; }
  .ok{ color:var(--score-accent); }
  .need{ color:var(--score-warn); }

  @media (prefers-reduced-motion: reduce){
    #scoreDock, .score-panel{ transition:none; }
  }
</style>


<script>
  
(function () {
  const SCORE_KEY   = 'quiz.scores.v1';
  const QUAL_KEY    = 'finalQualified';
  const ASKED_FLAG  = 'scores.prompted.v1';   // session-only flag (per tab)

  // Only ask once per tab
  if (sessionStorage.getItem(ASKED_FLAG)) return;

  // If any previous scores exist, ask the user
  if (localStorage.getItem(SCORE_KEY)) {
    const keep = confirm('Continue with previous scores? Click "OK" to continue, or "Cancel" to reset and start fresh.');
    if (!keep) {
      try {
        localStorage.removeItem(SCORE_KEY);
        localStorage.removeItem(QUAL_KEY);
        // (Optional) clear any auxiliary timestamps you may have added later
        localStorage.removeItem('quiz.scores.ts');
      } catch {}
    }
  }

  // Don’t ask again until this tab is reloaded
  sessionStorage.setItem(ASKED_FLAG, '1');
})();


/* =========================================================
Base init (wallpaper + which sections are visible)
========================================================= */
document.addEventListener('DOMContentLoaded', () => {
document.body.classList.remove('easy-mode');
document.body.classList.add('final-mode');
const startOv = document.getElementById('startOverlay');
const game = document.getElementById('gameWrap');
const easy = document.getElementById('easyChallenge');
if (startOv) startOv.style.display = 'flex';
if (game) game.style.display = 'none';
if (easy){ easy.classList.add('qs-hide'); easy.style.display = 'none'; }
});
/* tiny helpers */
const show = (el, disp='block') => { if (!el) return; el.classList.remove('qs-hide'); el.style.display = disp; };
const hide = (el) => { if (!el) return; el.style.display = 'none'; el.classList.add('qs-hide'); };
function showEasyStartLayer(){ hide(document.getElementById('easyMain')); show(document.getElementById('easyStartOverlay'),'flex'); }
/* =========================================================
FINAL CHALLENGE ENGINE (unchanged logic)
========================================================= */
(function(){
const $ = id => document.getElementById(id);
const RANGE = { QAVG_MIN:1963.50, QAVG_MAX:125663.71, PF_MIN:2.0, PF_MAX:3.0 };
let SCEN = { qavg:0, pf:0 };
function randExclusive(min,max,step){
const steps = Math.floor((max-min)/step);
const k = 1 + Math.floor(Math.random()*(steps-1));
const dp = (step.toString().split(".")[1]||"").length;
return +(min + k*step).toFixed(dp);
}
function randInclusive(min,max,step){
const steps = Math.round((max-min)/step);
const k = Math.floor(Math.random()*(steps+1));
const dp = (step.toString().split(".")[1]||"").length;
return +(min + k*step).toFixed(dp);
}
function randomizeScenario(){
const q = randExclusive(RANGE.QAVG_MIN, RANGE.QAVG_MAX, 0.01);
const p = randInclusive(RANGE.PF_MIN, RANGE.PF_MAX, 0.01);
SCEN.qavg = q; SCEN.pf = p;
$("qavgPlate").textContent = q;
$("pfPlate").textContent = p;
$("qavg").value = q; $("pf").value = p;
}
function renderExtraTanks(){
const nRaw = parseInt($("N").value,10) || 1;
const n = Math.min(8, Math.max(1, nRaw));
if (n !== nRaw) $("N").value = n;
const wrap = $("extraTanks");
wrap.innerHTML = "";
for (let i=2;i<=n;i++){
const row = document.createElement("div");
row.className = "tank-row";
row.innerHTML = `
<div class="tank-title">Tank ${i}</div>
<div class="rowgrid">
<div><label>Length L_${i} (m)</label><input id="L_${i}" class="checkable" type="number" step="0.1"></div>
<div><label>Breadth B_${i} (m)</label><input id="B_${i}" class="checkable" type="number" step="0.1"></div>
<div><label>Diameter Di_${i} (m)</label><input id="Di_${i}" class="checkable" type="number" step="0.1"></div>
</div>`;
wrap.appendChild(row);
const L=$(`L_${i}`), B=$(`B_${i}`), Di=$(`Di_${i}`);
const sync=()=>{ const rect=(L.value!==""||B.value!==""); Di.disabled=rect; const circ=(Di.value!==""); L.disabled=B.disabled=circ; };
[L,B,Di].forEach(el=>el.addEventListener("input",sync));
}
}
function calculateTankDesign(Q_avg, PF, SOR_target, depth, allowMix){
const D_max=30, L_max=30, W_max=8, ratio=3.8;
const Q_peak = Q_avg*PF;
const A_total = Q_peak/SOR_target;
const Amax_circ = Math.PI*(D_max*D_max)/4;
const Amax_rect = L_max*(L_max/ratio);
const tanks=[];
function pushCircular(area){ const D=Math.sqrt((4*area)/Math.PI); tanks.push({type:"Circular", D:+D.toFixed(2), area:+area.toFixed(2)}); }
function pushRectangular(area){
let W=Math.sqrt(area/ratio), L=W*ratio;
if (L>L_max||W>W_max){
const n=Math.ceil(area/Amax_rect), aPer=area/n;
for(let i=0;i<n;i++) pushRectangular(aPer);
return;
}
tanks.push({type:"Rectangular", L:+L.toFixed(2), W:+W.toFixed(2), area:+area.toFixed(2)});
}
if (allowMix){
const N_circ=Math.floor(A_total/Amax_circ);
for(let i=0;i<N_circ;i++) pushCircular(Amax_circ);
const A_rem=A_total - N_circ*Amax_circ;
if (A_rem>0){
const N_rect=Math.ceil(A_rem/Amax_rect), A_per=A_rem/N_rect;
for(let i=0;i<N_rect;i++) pushRectangular(A_per);
}
}else{
const N=Math.ceil(A_total/Amax_circ), A_per=A_total/N;
for(let i=0;i<N;i++) pushCircular(A_per);
}
const total_volume = isFinite(depth)? A_total*depth : NaN;
const detention_time = isFinite(total_volume)? (24*total_volume)/Q_avg : NaN;
const Q_peak_per = Q_peak/(tanks.length||1);
tanks.forEach(t=>{
const L_weir = (t.type==="Circular") ? Math.PI*t.D : t.L;
t.WLR = +(Q_peak_per/L_weir).toFixed(2);
});
return { Q_avg, PF, Q_peak, SOR_target, A_total:+A_total.toFixed(2),
depth, detention_time: isFinite(detention_time)? +detention_time.toFixed(2) : NaN, tanks };
}
function runDesignSolverAndRender(){
const Q_avg=SCEN.qavg, PF=SCEN.pf, SOR_target=+$("sorVal").value, depth=+$("D").value;
if (!isFinite(Q_avg)||!isFinite(PF)||!isFinite(SOR_target)||SOR_target<=0){
$("designResults") && ($("designResults").innerHTML = "<span style='color:#ef4444'>Enter SOR (and start the scenario) to see suggested tanks.</span>");
return;
}
const res = calculateTankDesign(Q_avg, PF, SOR_target, (isFinite(depth)?depth:NaN), true);
let html = `<div><strong>Suggested (deterministic) sizing</strong></div>`;
html += `<div>Total area (from SOR): <strong>${res.A_total}</strong> m²</div>`;
html += `<div>Detention time: <strong>${isFinite(res.detention_time)? res.detention_time+" h" : "—"}</strong></div>`;
html += `<div style="margin-top:6px"><em>Tanks:</em></div><ul style="margin:6px 0 0 18px">`;
res.tanks.forEach((t,i)=>{
html += (t.type==="Circular")
? `<li>Tank ${i+1} — Circular: D = <strong>${t.D}</strong> m, Area = ${t.area} m², WLR ≈ ${t.WLR}</li>`
: `<li>Tank ${i+1} — Rectangular: L = <strong>${t.L}</strong> m, W = <strong>${t.W}</strong> m, Area = ${t.area} m², WLR ≈ ${t.WLR}</li>`;
});
html += `</ul>`;
$("designResults") && ($("designResults").innerHTML = html);
}
function eqStrict(a,b){ if(!isFinite(a)||!isFinite(b)) return false; const ra=Math.round(a*10000)/10000, rb=Math.round(b*10000)/10000; return ra===rb; }
function areaFromDims(){
const N= +$("N").value||1, L= +$("L").value, B= +$("B").value, Di= +$("Di").value;
if(!$("Di").disabled && isFinite(Di)) return Math.PI*Di*Di/4 * N;
if(!$("L").disabled && isFinite(L) && isFinite(B)) return L*B * N;
return NaN;
}
function volFromDims(){ const A=areaFromDims(), D= +$("D").value; return (isFinite(A)&&isFinite(D))? A*D : NaN; }
function totalWeirFromInputs(){
const N= +$("N").value||1, L= +$("L").value, Di= +$("Di").value, weir= +$("weir").value;
if(isFinite(weir)&&weir>0) return weir*N;
if(!$("Di").disabled&&isFinite(Di)) return Math.PI*Di*N;
if(!$("L").disabled &&isFinite(L)) return L*N;
return NaN;
}
function clearMarks(){ document.querySelectorAll("input.checkable").forEach(i=>i.classList.remove("pass","fail")); }
function runBackChecks(){
clearMarks();
const q=SCEN.qavg, p=SCEN.pf;
if (!(q>RANGE.QAVG_MIN && q<RANGE.QAVG_MAX)){ $("done") && ($("done").textContent="⚠ Average flow must be strictly between 1,963.50 and 125,663.71 m³/day."); return; }
if (!(p>=RANGE.PF_MIN && p<=RANGE.PF_MAX)){ $("done") && ($("done").textContent="⚠ Peak factor must be between 2.0 and 3.0 (inclusive)."); return; }
const Qavg=SCEN.qavg, PF=SCEN.pf, Qpeak=Qavg*PF;
const A_dims=areaFromDims(), V_dims=volFromDims(), Lweir_have=totalWeirFromInputs();
const sor= +$("sorVal").value, t= +$("tVal").value, wlr= +$("wlrVal").value, V= +$("Vtotal").value, Dp= +$("D").value;
const A_need=(isFinite(Qpeak)&&isFinite(sor)&&sor>0)? Qpeak/sor : NaN;
const V_need=(isFinite(Qavg)&&isFinite(t)&&t>0)? (Qavg*t/24) : NaN;
const Lweir_need=(isFinite(Qpeak)&&isFinite(wlr)&&wlr>0)? Qpeak/wlr : NaN;
function mark(id,ok){ const el=$(id); if(el && el.value!=="") el.classList.add(ok?"pass":"fail"); }
["L","B","Di","D","N","weir"].forEach(id=>{
let ok=true;
if(isFinite(A_need)) ok = ok && eqStrict(A_dims, A_need);
if(isFinite(V_need)) ok = ok && eqStrict(V_dims, V_need);
if(isFinite(Lweir_need)) ok = ok && eqStrict(Lweir_have, Lweir_need);
mark(id, ok);
});
if($("sorVal").value!==""){
const A_from_VD = (isFinite(V)&&isFinite(Dp)&&Dp>0)? V/Dp : NaN;
const ok = (isFinite(A_dims) && eqStrict(A_need, A_dims)) || (isFinite(A_from_VD) && eqStrict(A_need, A_from_VD));
mark("sorVal", ok);
}
if($("tVal").value!==""){
const ok = (isFinite(V_dims) && eqStrict(V_need, V_dims)) || (isFinite(V) && eqStrict(V_need, V));
mark("tVal", ok);
}
if($("wlrVal").value!==""){ const ok = isFinite(Lweir_have) && eqStrict(Lweir_need, Lweir_have); mark("wlrVal", ok); }
if($("Vtotal").value!==""){
const ok = (isFinite(V_dims) && eqStrict(V, V_dims)) || (isFinite(V_need) && eqStrict(V, V_need));
mark("Vtotal", ok);
}
}
const CRIT = { depth:[3,4], Lmax:30, Bmax:8, Di:[10,30], lwTarget:4, lwTol:0.2, t:[2,4], SOR:[20,40], WLR:[125,500] };
const inR=(v,[a,b])=>isFinite(v)&&v>=a&&v<=b;
const chip=(el,ok)=>{ el.textContent= ok?"OK":"Out"; el.className = ok?"ok":"bad"; };
let started=false, timerStart=null, timerId=null, solved=false;
function startTimer(){ if(timerStart) return; timerStart=Date.now(); timerId=setInterval(()=>{const s=Math.floor((Date.now()-timerStart)/1000); const m=String(Math.floor(s/60)).padStart(2,"0"); const r=String(s%60).padStart(2,"0"); $("timer").textContent=`⏱ ${m}:${r}`;},250); }
function stopTimer(){ if(timerId){ clearInterval(timerId); timerId=null; } }
function hardResetChips(){
["c_dia","c_lw","c_len","c_brd","c_depth","c_t","c_sor","c_wlr"].forEach(id=>{$(id).textContent="—"; $(id).className="";});
$("done") && ($("done").textContent="Your inputs will appear after your selection.");
document.querySelectorAll("input.checkable").forEach(el=>el.classList.remove("pass","fail"));
}
function mutualExclusion(){
const rectTyped=$("L").value||$("B").value, circTyped=$("Di").value;
$("Di").disabled=!!rectTyped; $("L").disabled=$("B").disabled=!!circTyped;
}
function compute(){
if(!started) return;
mutualExclusion();
const L=+$("L").value, B=+$("B").value, Di=+$("Di").value, Dep=+$("D").value;
const tVal=+$("tVal").value, sor=+$("sorVal").value, wlr=+$("wlrVal").value;
chip($("c_depth"), inR(Dep, CRIT.depth));
chip($("c_t"), inR(tVal, CRIT.t));
chip($("c_sor"), inR(sor, CRIT.SOR));
chip($("c_wlr"), inR(wlr, CRIT.WLR));
const rectMode=!!($("L").value||$("B").value), circMode=!!$("Di").value;
if(rectMode){
chip($("c_lw"), inR(L/B,[CRIT.lwTarget-CRIT.lwTol, CRIT.lwTarget+CRIT.lwTol]));
chip($("c_len"), isFinite(L)&&L<=CRIT.Lmax);
chip($("c_brd"), isFinite(B)&&B<=CRIT.Bmax);
$("c_dia").textContent="—"; $("c_dia").className="";
}else if(circMode){
chip($("c_dia"), inR(Di, CRIT.Di));
["c_lw","c_len","c_brd"].forEach(id=>{$(id).textContent="—"; $(id).className="";});
}else{
["c_dia","c_lw","c_len","c_brd"].forEach(id=>{$(id).textContent="—"; $(id).className="";});
}
const geomOk = rectMode
? (inR(L/B,[CRIT.lwTarget-CRIT.lwTol, CRIT.lwTarget+CRIT.lwTol]) && isFinite(L)&&L<=CRIT.Lmax && isFinite(B)&&B<=CRIT.Bmax)
: (circMode ? inR(Di, CRIT.Di) : false);
const allOk = geomOk && inR(Dep, CRIT.depth) && inR(tVal, CRIT.t) && inR(sor, CRIT.SOR) && inR(wlr, CRIT.WLR);
$("done") && ($("done").textContent = allOk ? " Design meets all criteria." : "Keep adjusting until all criteria turn green.");
if(allOk){ solved=true; stopTimer(); } else { solved=false; }
}
function onFirstEdit(){ if(!started){ started=true; startTimer(); } compute(); }
function baseSetup(){
document.getElementById("gameWrap").style.display="";
started=false; solved=false; timerStart=null; stopTimer(); $("timer").textContent="⏱ 00:00";
["L","B","Di","D","weir","sorVal","tVal","wlrVal","Vtotal"].forEach(id=>$(id).value="");
if(!$("N").value) $("N").value=1;
document.getElementById("calc1Card").classList.add("qs-hide");
document.querySelectorAll('.calc3 .fields .form-ctrl').forEach(el => el.classList.add('qs-hide'));
$('startSelect').value = "";
randomizeScenario(); mutualExclusion(); hardResetChips(); renderExtraTanks();
}
$("startBtn")?.addEventListener("click", ()=>{
hide(document.getElementById("startOverlay"));
show(document.getElementById("gameWrap"));
baseSetup();
});
$("new")?.addEventListener("click", baseSetup);
$("reset")?.addEventListener("click", ()=>{
["L","B","Di","D","weir","sorVal","tVal","wlrVal","Vtotal"].forEach(id=>$(id).value="");
mutualExclusion();
if(!started) hardResetChips(); else compute();
renderExtraTanks();
document.getElementById("calc1Card").classList.add("qs-hide");
document.querySelectorAll('.calc3 .fields .form-ctrl').forEach(el => el.classList.add('qs-hide'));
$('startSelect').value = "";
});
$("N")?.addEventListener("input", ()=>{
const val= +$("N").value||1, ok=(val>=1 && val<=8);
$("N").classList.toggle("fail", !ok);
$("N").classList.toggle("pass", ok);
renderExtraTanks();
});
["L","B","Di","D","N","weir","sorVal","tVal","wlrVal","Vtotal"].forEach(id=>$(id)?.addEventListener("input", onFirstEdit));
$("checkBtn")?.addEventListener("click", ()=>{
runDesignSolverAndRender();
runBackChecks();
});
(function () {
const MAP = { sorVal:'sorVal', tVal:'tVal', wlrVal:'wlrVal', N:'N', weir:'weir', Vtotal:'Vtotal' };
const sel = $('startSelect');
if (sel) {
sel.addEventListener('change', () => {
const id = MAP[sel.value] || sel.value;
const el = $(id);
const wrap = el?.closest('.form-ctrl');
if (wrap) wrap.classList.remove('qs-hide');
el?.focus({ preventScroll:false });
if (sel.value === 'N') document.getElementById("calc1Card").classList.remove("qs-hide");
});
}
const nLabel = document.querySelector('label[for="N"]');
if (nLabel) nLabel.textContent = 'No. of tanks ≤ 8';
})();
})(); // end Final Engine
/* =========================================================
EASY / FINAL NAV
========================================================= */
document.getElementById('ctaEasy')?.addEventListener('click', () => {
document.body.classList.remove('final-mode');
document.body.classList.add('easy-mode');
hide(document.getElementById('gameWrap'));
show(document.getElementById('easyChallenge'));
showEasyStartLayer();
hide(document.getElementById('sorQuiz'));
});
document.getElementById('easyStartBtn')?.addEventListener('click', () => {
hide(document.getElementById('easyStartOverlay'));
show(document.getElementById('easyMain')); // harmless if not present
});
document.getElementById('backToFinal')?.addEventListener('click', () => {
document.body.classList.remove('easy-mode');
document.body.classList.add('final-mode');
hide(document.getElementById('easyChallenge'));
show(document.getElementById('gameWrap'));
showEasyStartLayer();
hide(document.getElementById('sorQuiz'));
});
/* ===== Easy Topic Picker wiring (uses your existing IDs) ===== */
(function(){
const $ = (id) => document.getElementById(id);
function showTopicSelectLayer(){
// Ensure Easy section is visible (your ctaEasy already does this)
const easy = $('easyChallenge');
if (easy){ easy.classList.remove('qs-hide'); easy.style.display = 'block'; }
// Hide the default Easy Start overlay and show our topic chooser
const startOv = $('easyStartOverlay');
if (startOv) startOv.style.display = 'none';
const picker = $('easyTopicOverlay');
if (picker) picker.style.display = 'flex';
}
window.showTopicSelectLayer = showTopicSelectLayer;
// When the user clicks the Final board's "Easy Challenge" button,
// your existing handler runs first; then we show the topic picker.
$('ctaEasy')?.addEventListener('click', () => {
// Let the original listener run (it shows easyChallenge + easyStart)
// then immediately swap to the topic picker.
setTimeout(showTopicSelectLayer, 0);
});
// Back button: return to the Final board (same style you use elsewhere)
$('topicCancelBtn')?.addEventListener('click', () => {
const picker = $('easyTopicOverlay'); if (picker) picker.style.display = 'none';
const easy = $('easyChallenge'); if (easy){ easy.classList.add('qs-hide'); easy.style.display = 'none'; }
const final = $('gameWrap'); if (final){ final.classList.remove('qs-hide'); final.style.display = ''; }
document.body.classList.remove('easy-mode');
document.body.classList.add('final-mode');
});
// Topic: SOR — show your existing SOR quiz panel
$('topicSORBtn')?.addEventListener('click', () => {
const picker = $('easyTopicOverlay'); if (picker) picker.style.display = 'none';
const q1 = $('sorQuiz'); if (q1){ q1.classList.remove('qs-hide'); q1.style.display = 'grid'; }
// If you prefer to keep using your Easy start overlay first, comment the two lines above
// and do: $('easyStartOverlay').style.display = 'flex';
});
})();
/* =========================================================
EASY: SOR QUIZ
========================================================= */
(function(){
const $ = (id)=>document.getElementById(id);
const UI = {
shell: $('sorQuiz'),
flow: $('qFlow'),
area: $('qArea'),
opts: $('sorOptions'),
fb: $('sorFeedback'),
next: $('sorNext'),
score: $('sorScore')
};
const SOR_MIN = 20, SOR_MAX = 45, Q_TOTAL = 5;
let qIndex = 0, score = 0, locked = false, correctSOR = null;
let easyAutoAdvance = null; // guard against double timers
function renderScore(){
if (UI.score) UI.score.textContent = `Score: ${score}`;
}
function randBetween(min,max,step){
const n = Math.floor((max-min)/step);
const k = Math.floor(Math.random()*(n+1));
const dp = (step.toString().split('.')[1]||'').length;
return +(min + k*step).toFixed(dp);
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
function makeQuestion(){
const targetSOR = randBetween(SOR_MIN, SOR_MAX, 0.01);
const area = randBetween(50, 1200, 1);
const flowRounded = Math.round((targetSOR*area)/10)*10;
const sorExact = +(flowRounded/area).toFixed(2);
if (sorExact < SOR_MIN || sorExact > SOR_MAX) return makeQuestion();
return { flow: flowRounded, area, sor: sorExact };
}
function buildOptions(correct){
const set = new Set([correct]);
const bumps = [-0.25,-0.15,-0.1,+0.1,+0.15,+0.25];
for (const b of bumps){
if (set.size >= 3) break;
let v = +(correct * (1+b)).toFixed(2);
v = Math.min(SOR_MAX, Math.max(SOR_MIN, v));
set.add(v);
}
while (set.size < 3) set.add(randBetween(SOR_MIN, SOR_MAX, 0.01));
return shuffle([...set]);
}
function renderQuestion(){
qIndex++; locked = false; correctSOR = null;
if (UI.next) UI.next.disabled = true;
UI.fb.textContent = '';
const q = makeQuestion();
correctSOR = q.sor;
UI.flow.textContent = q.flow.toLocaleString();
UI.area.textContent = q.area.toLocaleString();
UI.opts.innerHTML = '';
buildOptions(q.sor).forEach(v=>{
const btn = document.createElement('button');
btn.className = 'sor-opt';
btn.textContent = `${v} m³/day/m²`;
btn.addEventListener('click', () => onPick(v, btn));
UI.opts.appendChild(btn);
});
if (UI.next) UI.next.textContent = (qIndex === Q_TOTAL) ? 'Finish' : 'Next';
}
function onPick(value, btn){
if (locked) return;
locked = true;
// kill any pending auto-advance (just in case)
if (easyAutoAdvance) { clearTimeout(easyAutoAdvance); easyAutoAdvance = null; }
// disable all options
[...UI.opts.children].forEach(b => b.disabled = true);
if (+value === +correctSOR){
btn.classList.add('correct');
UI.fb.textContent = 'Correct!';
score += 2; // +2 points for correct
} else {
btn.classList.add('wrong');
const good = [...UI.opts.children]
.find(b => +b.textContent.replace(/[^\d.]/g,'') === +correctSOR);
good?.classList.add('correct');
UI.fb.textContent = `Answer: ${correctSOR} m³/day/m²`;
}
renderScore();
// Auto-advance after brief pause (works for both correct & wrong)
easyAutoAdvance = setTimeout(() => {
easyAutoAdvance = null;
nextStep();
}, 900);
}
function nextStep(){
if (qIndex >= Q_TOTAL){
UI.fb.innerHTML = `You scored <strong>${score}</strong> / ${Q_TOTAL*2} points.`;
if (UI.next) UI.next.disabled = true;
// signal Part-2 should start
document.dispatchEvent(new CustomEvent('sorQuizDone'));
return;
}
renderQuestion();
}
function initQuiz(){
qIndex = 0;
score = 0;
locked = false;
// hide & inert the Next button (no HTML/CSS edits needed)
if (UI.next){
UI.next.style.display = 'none';
UI.next.setAttribute('aria-hidden','true');
UI.next.disabled = true; // <-- was 'btn.disabled' (undefined) before
UI.next.onclick = null;
}
renderScore();
renderQuestion();
}
document.getElementById('easyStartBtn')?.addEventListener('click', () => {
show(UI.shell, 'grid'); // uses your existing show()
initQuiz();
});
document.getElementById('ctaEasy')?.addEventListener('click', () => hide(UI.shell));
document.getElementById('backToFinal')?.addEventListener('click', () => hide(UI.shell));
window.startSorEasy = () => {
// same effect as pressing the "Start" button
show(UI.shell, 'grid');
initQuiz();
};
document.addEventListener('click', (e) => {
const btn = e.target.closest('#topicSORBtn');
if (!btn) return;
e.preventDefault();
document.getElementById('easyTopicOverlay')?.style && (document.getElementById('easyTopicOverlay').style.display = 'none');
window.startSorEasy?.();
});
// ====== SCORE TRIGGER BASED ON FEEDBACK (can stay; Next is hidden anyway) ======
let easyScore = 0; // only for Easy Challenge display
const feedbackBox = document.getElementById('sorFeedback');
const scoreBox = document.getElementById('sorScore');
const nextBtn = document.getElementById('sorNext');
if (feedbackBox && scoreBox) {
const observer = new MutationObserver(() => {
const txt = feedbackBox.textContent.trim();
// this line used to enable Next; it's harmless now because the button is hidden
if (txt.length > 0 && nextBtn) nextBtn.disabled = false;
// add points only when correct (your legacy display logic)
if (txt.startsWith('Correct')) {
easyScore += 2;
scoreBox.textContent = `Score: ${easyScore}`;
}
});
observer.observe(feedbackBox, { childList: true, characterData: true, subtree: true });
}
})();
/* ==========================================
EASY: SOR RANGE QUIZ (Part 2, timed mode)
========================================== */
(function(){
const $ = (id) => document.getElementById(id);
// ---------- UI refs ----------
const UI = {
shell: $('sorRangeQuiz'),
flow: $('qFlow2'),
area: $('qArea2'),
opts: $('sorRangeOptions'),
fb: $('sorRangeFeedback'),
score: $('rangeScore'),
timer: $('rangeTimer'),
};
// ---------- State ----------
let bestScore = Number(localStorage.getItem('rangeBest') || 0); // persistent best
let easyScore = 0; // resets every round
let timeLeft = 60;
let timerId = null;
let locked = false;
let correctCat = null;
// ---------- Helpers ----------
function randBetween(min,max,step){
const n = Math.floor((max-min)/step);
const k = Math.floor(Math.random()*(n+1));
const dp = (step.toString().split('.')[1]||'').length;
return +(min + k*step).toFixed(dp);
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
function updateHUD(){
if (UI.score) UI.score.textContent = `Score: ${easyScore.toFixed(2)}`;
if (UI.timer) UI.timer.textContent = `${timeLeft}s`;
// mirror if other parts peek at it
window.easyScore = easyScore;
}
function stopTimer(){ if (timerId){ clearInterval(timerId); timerId=null; } }
function startTimer(){
stopTimer();
updateHUD();
timerId = setInterval(()=>{
timeLeft--;
updateHUD();
if (timeLeft <= 0){
stopTimer();
endRound();
}
}, 1000);
}
// ---------- Question generation ----------
// Build a question; realistic SOR ~10–55, area 50–1500 m² => flow ~ area * sor
function makeQuestion(){
const area = randBetween(50, 1500, 1); // m²
const sorTarget = randBetween(10, 55, 0.01); // m³/m²·d
const flow = Math.round(area * sorTarget); // m³/day
const computedSOR = +(flow/area).toFixed(2);
const category = (computedSOR < 20) ? 'Below Range'
: (computedSOR > 40) ? 'Above Range'
: 'Within Range';
return { flow, area, computedSOR, category };
}
function buildOptions(correctCategory){
const OPTS = [
{key:'Within Range', t:'Within Range', s:'SOR: 20–40 m³/day/m²'},
{key:'Below Range', t:'Below Range', s:'SOR < 20 m³/day/m²'},
{key:'Above Range', t:'Above Range', s:'SOR > 40 m³/day/m²'}
];
return shuffle(OPTS.map(o => ({...o, isCorrect: o.key===correctCategory})));
}
// ---------- Render / Interactions ----------
function renderQuestion(){
if (timeLeft <= 0) return; // do not render post time-up
locked = false; correctCat = null;
UI.fb.textContent = '';
const q = makeQuestion();
correctCat = q.category;
UI.flow.textContent = q.flow.toLocaleString();
UI.area.textContent = q.area.toLocaleString();
UI.opts.innerHTML = '';
buildOptions(correctCat).forEach(opt=>{
const btn = document.createElement('button');
btn.className = 'sor-opt';
btn.innerHTML = `<span class="t">${opt.t}</span><span class="s">${opt.s}</span>`;
btn.addEventListener('click', ()=> onPick(opt, btn));
UI.opts.appendChild(btn);
});
}
function onPick(opt, btn){
if (locked || timeLeft <= 0) return;
locked = true;
[...UI.opts.children].forEach(b=>b.disabled=true);
if (opt.isCorrect){
btn.classList.add('correct');
UI.fb.textContent = 'Correct!';
easyScore += 2; // +2 points
} else {
btn.classList.add('wrong');
const good = [...UI.opts.children]
.find(b => b.querySelector('.t').textContent === correctCat);
good?.classList.add('correct');
UI.fb.textContent = `Answer: ${correctCat}`;
easyScore -= 0.05; // −0.05 points
if (easyScore < 0) easyScore = 0; // clamp at 0
}
updateHUD();
// Auto-advance after a short pause
setTimeout(()=>{ if (timeLeft > 0) renderQuestion(); }, 700);
}
// ---------- Round control ----------
function startFreshRound(){
easyScore = 0;
timeLeft = 60;
locked = false;
UI.fb.textContent = '';
UI.opts.innerHTML = ''; // remove disabled buttons from previous round
updateHUD();
renderQuestion();
startTimer();
}
// expose restart globally so any layer/button can call it
window.startFreshRoundPart2 = startFreshRound;
function initRangeQuiz(){
// reset and start
startFreshRound();
}
// ---------- Results overlay ----------
function endRound(){
// update best score
if (easyScore > bestScore){
bestScore = easyScore;
localStorage.setItem('rangeBest', String(bestScore));
}
// freeze current options
[...UI.opts.children].forEach(b=>b.disabled = true);
// overlay nodes
const ov = $('rangeResultOverlay');
const ttl = $('rangeResultTitle');
const msg = $('rangeResultMsg');
const fsc = $('rangeFinalScore');
const bsc = $('rangeBestScore');
const btnRetry = $('rangeRetryBtn'); // "Re-try"
const btnRestart = $('rangeRestartBtn'); // "Restart"
const btnNext = $('rangeNextBtn'); // "Next"
fsc.textContent = easyScore.toFixed(2);
bsc.textContent = bestScore.toFixed(2);
// Hide all then show what we need
btnRetry.style.display = 'none';
btnRestart.style.display = 'none';
btnNext.style.display = 'none';
if (easyScore === 0){
// 0 points → Restart only
ttl.textContent = "Let's try again";
msg.textContent = "You scored 0 points. Click Restart to try a fresh 60-second round.";
btnRestart.style.display = 'inline-block';
} else if (easyScore >= 10){
// >=10 → Next + Restart
ttl.textContent = "Great job!";
msg.textContent = "You reached the minimum score. You can go to the next level, or restart to improve your best.";
btnNext.style.display = 'inline-block';
btnRestart.style.display = 'inline-block';
} else {
// <10 → Re-try + Next (no Restart to avoid confusion)
ttl.textContent = "Keep going";
msg.textContent = "Minimum score of 10 is needed to go to the next level. You can continue now and make up points later.";
btnRetry.style.display = 'inline-block';
btnNext.style.display = 'inline-block';
}
ov.style.display = 'flex';
}
// ---------- Overlay openers (Part-2 Start) ----------
window.showRangeOverlay = function(){
const ov = $('rangeStartOverlay');
if (ov) ov.style.display = 'flex';
};
window.startSorRangeQuiz = function(){
const ov = $('rangeStartOverlay');
if (ov) ov.style.display = 'none';
const q2 = $('sorRangeQuiz');
if (q2){ q2.classList.remove('qs-hide'); q2.style.display='block'; }
initRangeQuiz();
};
// Start Part-2 when Part-1 signals it's done
document.addEventListener('sorQuizDone', () => {
const q1 = $('sorQuiz');
if (q1){ q1.classList.add('qs-hide'); q1.style.display='none'; }
window.showRangeOverlay(); // the overlay's Start will call startSorRangeQuiz()
});
// Wire the overlay "Start" button (works no matter how you arrived)
$('rangeStartBtn')?.addEventListener('click', () => window.startSorRangeQuiz());
// Test ➡ button → jump to SOR-only Practice
document.getElementById('testPart2')?.addEventListener('click', () => {
// hide Easy challenge parts
document.getElementById('easyChallenge')?.classList.add('qs-hide');
// show SOR-only section
const sec = document.getElementById('sorOnlySection');
const ov = document.getElementById('sorOnlyStartOverlay');
if (sec){
sec.classList.remove('qs-hide');
sec.style.removeProperty('display');
}
if (ov) ov.style.display = 'flex';
// update body mode for styling
document.body.classList.remove('easy-mode','final-mode','intermediate-mode');
document.body.classList.add('soronly-mode');
});
// Results overlay buttons (single, reliable wiring)
document.addEventListener('click', (e) => {
const t = e.target;
if (!t) return;
if (t.id === 'rangeRetryBtn'){ // Re-try => new 60s round
$('rangeResultOverlay').style.display = 'none';
window.startFreshRoundPart2?.();
}
if (t.id === 'rangeRestartBtn'){ // Restart => new 60s round
$('rangeResultOverlay').style.display = 'none';
window.startFreshRoundPart2?.();
}
if (t.id === 'rangeNextBtn'){ // Next => hand off to next level
$('rangeResultOverlay').style.display = 'none';
document.dispatchEvent(new CustomEvent('sorRangeDone', {
detail: { score: easyScore, best: bestScore }
}));
}
});
})();
// Hook Next button in Easy Challenge Part 2 → SOR-only Practice
document.getElementById('rangeNextBtn')?.addEventListener('click', () => {
// hide Easy Part 2 result overlay
document.getElementById('rangeResultOverlay').style.display = 'none';
// hide the Easy Challenge section completely
document.getElementById('easyChallenge')?.classList.add('qs-hide');
document.getElementById('easyChallenge').style.display = 'none';
// show the SOR-only section
const sorSection = document.getElementById('sorOnlySection');
if (sorSection) {
sorSection.classList.remove('qs-hide');
sorSection.style.display = 'block';
}
// optionally auto-show the Start overlay in SOR-only
const sorOverlay = document.getElementById('sorOnlyStartOverlay');
if (sorOverlay) {
sorOverlay.style.display = 'flex'; // flex centers it
}
// mark body mode (helps with global CSS)
document.body.classList.remove('easy-mode');
document.body.classList.add('sor-mode');
});
// ===== Intermediate Start button → hide overlay, show board, start engine =====
document.getElementById('interStartBtn')?.addEventListener('click', () => {
const ov = document.getElementById('interStartOverlay');
const board = document.getElementById('interQuiz');
if (ov) ov.style.display = 'none';
if (board){
board.classList.remove('qs-hide','inter-locked');
board.style.display = 'grid'; // ensure grid shows
}
// Refresh a question set each time (optional but nice)
if (window.practiceGenerators?.generatePracticeSet && window.practice?.setQuestions){
window.practice.setQuestions(window.practiceGenerators.generatePracticeSet(20));
}
if (window.practice?.start) {
window.practice.start();
} else {
console.warn('window.practice.start not found');
}
});
// ================= Intermediate Challenge — Timed Round (per-mode scoring) =================
(function(){
const $ = (id) => document.getElementById(id);
// ---------- UI nodes ----------
const UI = {
overlay: $('interStartOverlay'),
start: $('interStartBtn'),
board: $('interQuiz'),
stem: $('interStem'),
given: $('interGiven'),
opts: $('interOptions'),
fb: $('interFeedback'),
hint: $('interHint'),
next: $('interNext'), // kept as hidden a11y fallback
resOv: $('interResultOverlay'),
resMsg: $('interResultMsg'),
restart: $('interRestartBtn'),
back: $('interBackBtn'),
scoreEl: $('interScore'),
timerEl: $('interTimer'),
};
// ---------- Small CSS injections ----------
// Demo badge style (once)
(function ensureDemoPillCSS(){
if (document.getElementById('interDemoPillCSS')) return;
const s = document.createElement('style');
s.id = 'interDemoPillCSS';
s.textContent = `
.demo-pill{
display:inline-block; margin-right:8px; padding:2px 8px;
border-radius:999px; background:#fde047; color:#111;
font-weight:700; font-size:.85rem; vertical-align:middle;
}
`;
document.head.appendChild(s);
})();
// Design Criteria highlighter (JS-only)
(function injectCriteriaCSS(){
if (document.getElementById('interCriteriaHiCSS')) return;
const style = document.createElement('style');
style.id = 'interCriteriaHiCSS';
style.textContent = `
.crit-hi { background: rgba(255,221,87,.14); outline: 2px solid rgba(255,221,87,.45);
border-radius: 6px; padding: 2px 6px; }
.crit-note { color:#14b8a6; font-size:.95rem; font-weight:700; margin:4px 0 6px; opacity:1; }
`;
document.head.appendChild(style);
})();
function getCriteriaListItems(){
const root = $('interQuiz') || $('intermediateSection');
if (!root) return [];
const hdr = [...root.querySelectorAll('h2,h3')].find(h => /Design\s+Criteria/i.test(h.textContent));
if (!hdr) return [];
let list = hdr.parentElement.querySelector('ul');
if (!list){
let n = hdr.nextElementSibling;
while (n && n.tagName !== 'UL') n = n.nextElementSibling;
list = n;
}
return [...(list?.querySelectorAll('li') || [])];
}
function clearCriteriaHighlight(){ getCriteriaListItems().forEach(li => li.classList.remove('crit-hi')); }
function ensureCriteriaNote(){
const root = $('interQuiz') || $('intermediateSection');
if (!root) return;
const hdr = [...root.querySelectorAll('h2,h3')].find(h => /Design\s+Criteria/i.test(h.textContent));
if (!hdr) return;
const next = hdr.nextElementSibling;
if (next && next.classList && next.classList.contains('crit-note')) return;
const note = document.createElement('div');
note.className = 'crit-note';
note.textContent = 'Instruction: Your answer should match the highlighted criteria.';
hdr.parentElement.insertBefore(note, next || hdr.nextSibling);
}
const CRITERIA_LABELS = {
WLR:'WLR:', SOR:'SOR:', Detention:'Detention:', Depth:'Depth:',
Diameter:'Diameter:', LengthWidth:'Length:Width', MaxLength:'Max Length', MaxWidth:'Max Width'
};
function highlightCriteria(tags){
clearCriteriaHighlight();
ensureCriteriaNote();
if (!Array.isArray(tags)) return;
const lis = getCriteriaListItems();
for (const tag of tags){
const label = CRITERIA_LABELS[tag] || tag;
const li = lis.find(x => x.textContent.trim().toLowerCase().startsWith(label.toLowerCase()));
if (li) li.classList.add('crit-hi');
}
}
function inferCriteriaTags(q){
const s = `${q.stem||''} ${q.given||''}`.toLowerCase();
const tags = [];
if (/\bwlr\b/.test(s)) tags.push('WLR');
if (/\bsor\b/.test(s)) tags.push('SOR');
if (/detention/.test(s)) tags.push('Detention');
if (/depth/.test(s)) tags.push('Depth');
return [...new Set(tags)];
}
function stripCriteriaFromGiven(html, tags){
let t = html;
if (tags?.includes('WLR')) t = t.replace(/;?\s*WLR[^;]*(?=;|$)/i, '');
if (tags?.includes('SOR')) t = t.replace(/;?\s*SOR[^;]*(?=;|$)/i, '');
if (tags?.includes('Detention')) t = t.replace(/;?\s*Detention[^;]*(?=;|$)/i, '');
if (tags?.includes('Depth')) t = t.replace(/;?\s*Depth[^;]*(?=;|$)/i, '');
return t.replace(/\s*;+\s*$/,'').trim();
}
// ---------- Difficulty (adaptive) ----------
// Set once anywhere if you want fixed level: window.interDifficulty = 'easy'|'standard'|'hard'|'auto'
const DIFF = {
easy: { label:'Easy' },
standard: { label:'Standard' },
hard: { label:'Hard' },
};
let interRating = 0; // -∞..∞, mapped to three bands
let interStreak = 0;
function clamp(v, lo, hi){ return Math.min(hi, Math.max(lo, v)); }
function pickMode(){
const pref = String(window.interDifficulty || 'auto').toLowerCase();
if (pref !== 'auto') return pref;
if (interRating >= 1.2) return 'hard';
if (interRating <= -0.6) return 'easy';
return 'standard';
}
function renderDifficultyBadge(mode){
if (!UI.scoreEl) return;
UI.scoreEl.textContent = `Score: ${score.toFixed(1)} • ${DIFF[mode].label}`;
}
// ---------- Round timer & scoring (timed round like SOR-90s) ----------
function fmtMMSS(s){
const m = String(Math.floor(s/60)).padStart(2,'0');
const ss = String(s%60).padStart(2,'0');
return `${m}:${ss}`;
}
const INTER_ROUND_SECS = 900; // 15:00 (set 500 for 10:00)
const POINTS_BY_MODE = { easy: 2, standard: 5, hard: 7 };
// Target plan (5E + 6S + 9H) → 103 pts total
const TARGET_CAP = { easy: 5, standard: 6, hard: 9 };
const TARGET_POINTS =
TARGET_CAP.easy * POINTS_BY_MODE.easy +
TARGET_CAP.standard * POINTS_BY_MODE.standard +
TARGET_CAP.hard * POINTS_BY_MODE.hard; // 103
let roundTimerId = null, roundLeft = INTER_ROUND_SECS;
function startRoundTimer(){
stopRoundTimer();
roundLeft = INTER_ROUND_SECS;
if (UI.timerEl) UI.timerEl.textContent = fmtMMSS(roundLeft);
roundTimerId = setInterval(() => {
roundLeft--;
if (UI.timerEl) UI.timerEl.textContent = fmtMMSS(Math.max(0, roundLeft));
if (roundLeft <= 0){
stopRoundTimer();
endQuiz();
}
}, 1000);
}
function stopRoundTimer(){
if (roundTimerId){ clearInterval(roundTimerId); roundTimerId = null; }
}
const modeStats = {
easy: { asked: 0, correct: 0, points: 0 },
standard: { asked: 0, correct: 0, points: 0 },
hard: { asked: 0, correct: 0, points: 0 },
};
let currentAskedMode = 'standard';
// ---------- Question generators ----------
(function(){
const rnd = (min, max, step=1) => {
const n = Math.floor((max - min) / step);
const k = Math.floor(Math.random() * (n + 1));
const dp = (step.toString().split('.')[1] || '').length;
return +(min + k * step).toFixed(dp);
};
const shuffle = a => { for (let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; };
const fmt = n => Number(n).toLocaleString();
const clampSOR = s => +(Math.round(s*100)/100).toFixed(2);
function qAreaFromSOR(){
const Qavg = rnd(8_000, 40_000, 100);
const PF = rnd(2.0, 3.0, 0.1);
const SOR = rnd(22, 38, 0.5);
const Qp = Qavg * PF;
const A = Qp / SOR;
const opts = shuffle([ A*0.85, A, A*1.15, A*1.30 ]).map(x => `${x.toFixed(0)} m²`);
const correctIdx = opts.findIndex(t => t.startsWith(A.toFixed(0)));
return {
stem: "Which tank is suitable is suitable for Peak flow?",
given: `Average flow = <strong>${fmt(Qavg)}</strong> m³/d; PF = <strong>${PF}</strong>; SOR target = <strong>${SOR}</strong> m³/m²·d`,
options: opts,
correct: correctIdx,
hint: "Use peak flow: A = Qavg × PF",
explanation: `Q<sub>p</sub> = ${fmt(Qavg)} × ${PF} = ${fmt(Qp.toFixed(0))} m³/d; A = Q<sub>p</sub>/SOR = ${fmt(Qp.toFixed(0))}/${SOR} ≈ ${A.toFixed(0)} m².`
};
}
function qPickTankByArea(){
const Qavg = rnd(10_000, 60_000, 100);
const PF = rnd(2.0, 3.0, 0.1);
const SOR = rnd(22, 38, 0.5);
const Qp = Qavg * PF;
const Areq = Qp / SOR;
const raw = [ Areq*0.88, Areq*0.97, Areq*1.04, Areq*1.22 ].map(v => Math.max(1, Math.round(v)));
const seen = new Set(); const candidates = raw.filter(v => (seen.has(v) ? false : (seen.add(v), true)));
while (candidates.length < 4){
const bump = Math.round(Areq * (1 + (Math.random()*0.35 - 0.15)));
if (!seen.has(bump) && bump > 0){ candidates.push(bump); seen.add(bump); }
}
const viable = candidates.filter(v => v >= Areq).sort((a,b)=>a-b);
const correctVal = viable.length ? viable[0] : Math.max(...candidates);
const optsShuffled = shuffle(candidates.slice());
const correct = optsShuffled.indexOf(correctVal);
return {
stem: "Which tank should be selected to meet the peak-flow?",
given: `Average flow = <strong>${fmt(Qavg)}</strong> m³/d; PF = <strong>${PF}</strong>; SOR limit = <strong>${SOR}</strong> m³/m²·d`,
options: optsShuffled.map(a => `Tank (area ${a} m²)`),
correct,
hint: "Use your own judgement",
explanation: `A<sub>req</sub> = ${fmt(Qp.toFixed(0))}/${SOR} ≈ ${Math.round(Areq)} m². Select the smallest candidate ≥ this value (ties: pick the smaller).`
};
}
function qSORComplianceRect(){
const L = rnd(12, 28, 0.5), B = rnd(3, 7.5, 0.1);
const Qavg = rnd(12_000, 45_000, 100);
const PF = rnd(2.0, 3.0, 0.1);
const A = L*B, Qp = Qavg*PF, SOR = Qp/A;
const within = (SOR >= 20 && SOR <= 40);
const ratioOK = (L/B >= 3.8 && L/B <= 4.2);
const widthOK = (B <= 8);
const opts = [ "SOR is OK", "SOR exceeds limit", "Width > 8 m", "L:W ratio invalid" ];
let correct;
if (!within) correct = 1;
else if (!widthOK) correct = 2;
else if (!ratioOK) correct = 3;
else correct = 0;
return {
stem: `Rectangular clarifier (L = ${L} m, B = ${B} m) is managing a flow of <strong>${fmt(Qavg)}</strong>. Which statement is correct?`,
given: `PF = <strong>${PF}</strong>; SOR range = 20–40 m³/m²·d`,
options: opts,
correct,
hint: "SOR is Flow per unit area.",
explanation: `Area = ${A.toFixed(1)} m²; Q<sub>p</sub> = ${fmt(Qp.toFixed(0))}; SOR = ${clampSOR(SOR)} m³/m²·d. L:W = ${(L/B).toFixed(2)} (target 4.0±0.2).`
};
}
function qNumTanksCircular(){
const Qavg = rnd(15_000, 80_000, 100);
const PF = rnd(2.0, 3.0, 0.1);
const SOR = rnd(22, 36, 0.5);
const D = rnd(12, 28, 0.5);
const Qp = Qavg*PF;
const Areq = Qp/SOR;
const A1 = Math.PI * D*D / 4;
const Lw1 = Math.PI * D;
const WLRmin = 125, WLRmax = 500;
let N = 1;
for (; N<=8; N++){
const Aok = (A1*N >= Areq);
const WLR = Qp / (Lw1*N);
const Wok = (WLR >= WLRmin && WLR <= WLRmax);
if (Aok && Wok) break;
}
const opts = [1,2,3,4].map(n => `${n} tank${n>1?'s':''}`);
const correct = Math.min(N, 4) - 1;
return {
stem: `How many circular tanks (D = ${D} m) are needed to satisfy SOR and WLR?`,
given: `Average flow = <strong>${fmt(Qavg)}</strong> m³/d; PF = <strong>${PF}</strong>; SOR target = <strong>${SOR}</strong> m³/m²·d; WLR range = 125–500 m³/m·d`,
options: opts,
correct,
hint: "A<sub>req</sub> = (Qavg×PF)/SOR. A<sub>1</sub> = πD²/4; L<sub>w1</sub> = πD. Check N so A and WLR both meet criteria.",
explanation: `A<sub>req</sub> ≈ ${Areq.toFixed(0)} m²; A<sub>1</sub> = ${A1.toFixed(0)} m²; L<sub>w1</sub> = ${Lw1.toFixed(1)} m. Pick smallest N with A<sub>1</sub>×N ≥ A<sub>req</sub> and WLR = Q<sub>p</sub>/(L<sub>w1</sub>×N) within 125–500.`
};
}
function qDetentionFeasibility(){
const Qavg = rnd(10_000, 50_000, 100);
const PF = rnd(2.0, 3.0, 0.1);
const tTarget = rnd(2.0, 4.0, 0.5);
const D = rnd(3.0, 4.0, 0.1);
const B = rnd(3.0, 7.5, 0.1);
const L = +(B * rnd(3.8, 4.2, 0.1)).toFixed(1);
const A = L*B;
const V = A*D;
const t = 24*V/Qavg;
const opts = [ "Detention meets 2–4 h", "Detention is too low", "Detention is too high", "Depth violates 3–4 m" ];
let correct;
if (D < 3 || D > 4) correct = 3;
else if (t < 2) correct = 1;
else if (t > 4) correct = 2;
else correct = 0;
return {
stem: `For a rectangular tank (L = ${L} m, B = ${B} m, D = ${D} m), check detention feasibility.`,
given: `Average flow = <strong>${fmt(Qavg)}</strong> m³/d; target detention = <strong>${tTarget.toFixed(1)}</strong> h (allowed 2–4 h)`,
options: opts,
correct,
hint: "V = L×B×D; t = 24V/Qavg. Depth must be 3–4 m.",
explanation: `A = ${A.toFixed(1)} m²; V = ${V.toFixed(0)} m³; t ≈ ${t.toFixed(2)} h. Depth ${D} m is ${ (D<3||D>4)?'out of':'within' } 3–4 m.`
};
}
function qWeirConfigRect(){
const Qavg = rnd(12_000, 60_000, 100);
const PF = rnd(2.0, 3.0, 0.1);
const N = rnd(1, 2, 1);
const B = rnd(4.0, 7.0, 0.1);
const L = +(B * rnd(3.8, 4.2, 0.1)).toFixed(1);
const Qp = Qavg * PF;
const WLRmin = 125, WLRmax = 500;
const configs = [
{ label: 'Weir along one long side (per tank)', Lw: L * N },
{ label: 'Weirs along both long sides (per tank)', Lw: (2*L) * N },
{ label: 'Weirs along both short sides (per tank)', Lw: (2*B) * N },
{ label: 'Weir around the full perimeter (per tank)', Lw: (2*(L+B)) * N },
];
const scored = configs.map(c => ({...c, WLR: Qp / c.Lw}));
const viable = scored.filter(c => c.WLR >= WLRmin && c.WLR <= WLRmax)
.sort((a,b) => a.Lw - b.Lw);
const chosen = viable[0] ||
scored.sort((a,b) => Math.abs(a.WLR - WLRmax) - Math.abs(b.WLR - WLRmax))[0];
const options = configs.map(c => c.label);
const correct = options.indexOf(chosen.label);
return {
stem: `Select the **weir arrangement** that meets Weir Loading Rate (WLR) while minimizing total overflow-weir length for a rectangular clarifier.`,
given: `Average flow = <strong>${fmt(Qavg)}</strong> m³/d; PF = <strong>${PF}</strong>; Tanks in service = <strong>${N}</strong>; L = <strong>${L}</strong> m; B = <strong>${B}</strong> m; ` +
`WLR band = <strong>${WLRmin}–${WLRmax}</strong> m³/m·d (WLR = flow per meter of overflow weir).`,
options,
correct,
hint: `Compute Q<sub>p</sub> = Q<sub>avg</sub>×PF. For each arrangement, total L<sub>w</sub> and WLR = Q<sub>p</sub>/L<sub>w</sub>. Pick the smallest L<sub>w</sub> that stays in band.`,
explanation: scored.map(c => `${c.label}: L<sub>w</sub>=${(c.Lw).toFixed(1)} m → WLR≈${(Qp/c.Lw).toFixed(1)}`).join('<br>')
};
}
function qNumRectTanksWLR(){
const Qavg = rnd(15_000, 85_000, 100);
const PF = rnd(2.0, 3.0, 0.1);
const SOR = rnd(22, 36, 0.5);
const B = rnd(4.0, 7.0, 0.1);
const L = +(B * rnd(3.8, 4.2, 0.1)).toFixed(1);
const Qp = Qavg * PF;
const A1 = L * B;
const Lw1 = 2 * L;
const Areq = Qp / SOR;
const WLRmin = 125, WLRmax = 500;
let N=1;
for (; N<=8; N++){
const Aok = (A1*N >= Areq);
const WLR = Qp / (Lw1*N);
const Wok = (WLR >= WLRmin && WLR <= WLRmax);
if (Aok && Wok) break;
}
const opts = [1,2,3,4].map(n => `${n} tank${n>1?'s':''}`);
const correct = Math.min(N,4) - 1;
return {
stem: `How many rectangular tanks (L≈${L} m, B≈${B} m) are needed if the **overflow weir runs along both long sides** of each tank, meeting both SOR and WLR?`,
given: `Average flow = <strong>${fmt(Qavg)}</strong> m³/d; PF = <strong>${PF}</strong>; SOR target = <strong>${SOR}</strong> m³/m²·d; WLR band = <strong>125–500</strong> m³/m·d.`,
options: opts,
correct,
hint: `Meet both: A<sub>1</sub>×N ≥ Q<sub>p</sub>/SOR and Q<sub>p</sub>/(2L×N) in 125–500.`,
explanation: `A<sub>req</sub>≈${Math.round(Areq)} m²; per-tank A=${Math.round(A1)} m² → test N=1..8. WLR(N)=Q<sub>p</sub>/(2L·N).`
};
}
function qDetentionDepthPick(){
let tries=0, Qavg, B, L, tTarget, Dreq;
do {
Qavg = rnd(12_000, 55_000, 100);
B = rnd(4.0, 7.0, 0.1);
L = +(B * rnd(3.8, 4.2, 0.1)).toFixed(1);
tTarget= rnd(2.2, 3.8, 0.1);
const A= L*B;
Dreq = (Qavg * tTarget) / (24 * A);
} while ((Dreq < 2.7 || Dreq > 4.3) && ++tries < 50);
const deltas = [-0.5, -0.2, +0.2, +0.5];
const raw = deltas.map(d => +(Dreq + d).toFixed(1));
const opts = raw.map(v => `${Math.max(2.0, Math.min(5.0, v)).toFixed(1)} m`);
const correctIdx = opts
.map(t => Math.abs(parseFloat(t) - Dreq))
.reduce((bestIdx, diff, idx, arr) => diff < arr[bestIdx] ? idx : bestIdx, 0);
return {
stem: `Choose the **depth** that achieves the target detention time for a rectangular clarifier.`,
given: `Average flow = <strong>${fmt(Qavg)}</strong> m³/d; L = <strong>${L}</strong> m; B = <strong>${B}</strong> m; target detention = <strong>${tTarget.toFixed(1)}</strong> h`,
options: opts,
correct: correctIdx,
hint: "t = 24·(L·B·D)/Q<sub>avg</sub> ⇒ solve for D.",
explanation: `D<sub>req</sub> = (Q<sub>avg</sub>·t)/(24·L·B) ≈ ${Dreq.toFixed(2)} m. Choose the nearest practical depth (~3–4 m).`
};
}
function generatePracticeSet(N=20){
const factories = [
qAreaFromSOR,
qPickTankByArea,
qSORComplianceRect,
qNumTanksCircular,
qDetentionFeasibility,
qWeirConfigRect,
qNumRectTanksWLR,
qDetentionDepthPick
];
const shuffled = factories.slice().sort(() => Math.random() - 0.5);
const out = [];
while (out.length < N){
for (const f of shuffled){
out.push(f());
if (out.length === N) break;
}
}
window.practiceGenerators = { generatePracticeSet }; // expose once
return out;
}
// expose if not already
if (!window.practiceGenerators) window.practiceGenerators = { generatePracticeSet };
})();
// ---------- state ----------
let interQuestions = [];
let order = [];
let i = 0;
let score = 0;
let usedHint = false;
let locked = false;
let interAutoAdvance = null;
let interDemoShown = false;
// ---------- helpers ----------
const shuffle = (a)=>{ for(let k=a.length-1;k>0;k--){ const j=(Math.random()*(k+1))|0; [a[k],a[j]]=[a[j],a[k]]; } return a; };
function renderScore(){ if (UI.scoreEl) UI.scoreEl.textContent = `Score: ${score.toFixed(1)}`; }
// Demo question factory
function makeInterDemo(){
const L = 22, B = 5.5, PF = 2, Qavg = 40_000;
const Qp = Qavg * PF;
const LwPerTank = 2 * L;
let N = 1;
for (; N <= 4; N++){
const WLR = Qp / (LwPerTank * N);
if (WLR >= 125 && WLR <= 500) break;
}
return {
demo: true,
demoPoints: 1,
stem: `How many rectangular tanks (L=${L} m, B=${B} m) are needed if the overflow weir runs along both long sides of each tank, meeting WLR?`,
given: `Average flow = <strong>${Qavg.toLocaleString()}</strong> m³/d; PF = <strong>${PF}</strong>.`,
options: [1,2,3,4].map(n => `${n} tank${n>1?'s':''}`),
correct: Math.min(N, 4) - 1,
hint: 'WLR = Qp / (2L · N). Choose the smallest N with WLR in 125–500.',
explanation: `Qp = ${Qavg.toLocaleString()} × ${PF} = ${(Qp).toLocaleString()} m³/d; per-tank Lw = ${LwPerTank} m.`,
criteria: ['WLR']
};
}
// ---------- rendering ----------
function renderQuestion(){
const q = interQuestions[order[i]];
if (!q){ return endQuiz(); }
if (interAutoAdvance){ clearTimeout(interAutoAdvance); interAutoAdvance = null; }
UI.board?.classList.remove('inter-locked');
UI.opts.innerHTML = '';
UI.fb.textContent = '';
UI.hint.classList.remove('used');
usedHint = false;
locked = false;
if (UI.next) UI.next.disabled = true;
const demoTag = q.demo ? `<span class="demo-pill" aria-label="Demo question">Demo&nbsp;Question</span>` : '';
UI.stem.innerHTML = `${demoTag}<strong>Scenario:</strong> ${q.stem}`;
const tags = Array.isArray(q.criteria) ? q.criteria : inferCriteriaTags(q);
// decide the mode ONCE for this question
const askMode = pickMode();
// cap highlights by difficulty (E=1,S=2,H=3)
const hiMaxByMode = { easy: 1, standard: 2, hard: 3 };
const tagsToShow = tags.slice(0, hiMaxByMode[askMode] ?? tags.length);
const cleanedGiven = stripCriteriaFromGiven(q.given || '', tagsToShow);
UI.given.innerHTML = cleanedGiven ? `<strong>Given:</strong> ${cleanedGiven}` : '';
highlightCriteria(tagsToShow);
q.options.forEach((txt, idx) => {
const b = document.createElement('button');
b.className = 'sor-opt';
b.innerHTML = `<span class="t">${txt}</span>`;
b.addEventListener('click', () => onPick(q, idx, b));
UI.opts.appendChild(b);
});
UI.hint.onclick = () => {
if (locked || UI.hint.classList.contains('used')) return;
UI.hint.classList.add('used');
usedHint = true;
UI.fb.innerHTML = `Hint: ${q.hint}`;
};
if (UI.next) UI.next.onclick = next; // hidden, but a11y
// score + difficulty + record asked
renderScore();
currentAskedMode = askMode;
if (modeStats[askMode]) modeStats[askMode].asked++;
renderDifficultyBadge(askMode);
}
function onPick(q, idx, btn){
if (locked) return;
locked = true;
[...UI.opts.children].forEach(x => x.disabled = true);
// Demo fast-path (no adaptive changes to rating)
if (q.demo){
if (idx === q.correct){
score += (q.demoPoints ?? 1);
UI.fb.textContent = `Correct! (+${q.demoPoints ?? 1})`;
} else {
btn.classList.add('wrong');
const good = [...UI.opts.children][q.correct];
good?.classList.add('correct');
UI.fb.innerHTML = `Answer: ${q.options[q.correct]}<br><span style="opacity:.85">${q.explanation}</span>`;
}
renderScore();
renderDifficultyBadge(pickMode());
if (UI.next) UI.next.disabled = false;
if (interAutoAdvance) clearTimeout(interAutoAdvance);
interAutoAdvance = setTimeout(()=>{ if (UI.resOv?.style.display!=='flex') next(); }, 900);
return;
}
const mode = currentAskedMode;
if (idx === q.correct){
btn.classList.add('correct');
const pts = POINTS_BY_MODE[mode] || 0;
score += pts;
if (modeStats[mode]) { modeStats[mode].correct++; modeStats[mode].points += pts; }
UI.fb.textContent = `Correct! (+${pts})`;
// simple adaptive bump
interStreak++;
interRating = clamp(interRating + (usedHint ? 0.3 : 0.6), -2, 2);
} else {
btn.classList.add('wrong');
const good = [...UI.opts.children][q.correct];
good?.classList.add('correct');
UI.fb.innerHTML = `Answer: ${q.options[q.correct]}<br><span style="opacity:.85">${q.explanation}</span>`;
// simple adaptive drop
interStreak = 0;
interRating = clamp(interRating - 0.7, -2, 2);
}
renderScore();
renderDifficultyBadge(pickMode());
if (UI.next) UI.next.disabled = false;
if (interAutoAdvance) clearTimeout(interAutoAdvance);
interAutoAdvance = setTimeout(() => {
if (UI.resOv && UI.resOv.style.display === 'flex') return;
next();
}, 900);
}
function next(){
if (interAutoAdvance){ clearTimeout(interAutoAdvance); interAutoAdvance = null; }
i++;
if (i >= order.length){
// generate more and keep the round going until timer ends
const more = window.practiceGenerators?.generatePracticeSet
? window.practiceGenerators.generatePracticeSet(20)
: interQuestions.slice(); // fallback: reuse
const filtered = more.filter(q => !q.demo);
interQuestions = filtered.length ? filtered : more;
order = shuffle([...Array(interQuestions.length).keys()]);
i = 0;
}
renderQuestion();
}
function endQuiz(){
if (interAutoAdvance){ clearTimeout(interAutoAdvance); interAutoAdvance = null; }
stopRoundTimer();
const eMax = TARGET_CAP.easy * POINTS_BY_MODE.easy; // 10
const sMax = TARGET_CAP.standard * POINTS_BY_MODE.standard; // 30
const hMax = TARGET_CAP.hard * POINTS_BY_MODE.hard; // 63
const ePct = Math.min(100, Math.round((modeStats.easy.points / eMax) * 100 || 0));
const sPct = Math.min(100, Math.round((modeStats.standard.points / sMax) * 100 || 0));
const hPct = Math.min(100, Math.round((modeStats.hard.points / hMax) * 100 || 0));
const totalPct = Math.min(100, Math.round((score / TARGET_POINTS) * 100 || 0));
UI.resMsg.innerHTML = `
<div style="margin-bottom:8px;"><strong>Round complete!</strong></div>
<div style="margin-bottom:6px;">Total points: <strong>${score}</strong> / ${TARGET_POINTS} (${totalPct}%)</div>
<div style="line-height:1.4">
<div><strong>Easy</strong>: ${modeStats.easy.correct}/${modeStats.easy.asked} correct • ${modeStats.easy.points}/${eMax} pts (${ePct}%)</div>
<div><strong>Standard</strong>: ${modeStats.standard.correct}/${modeStats.standard.asked} correct • ${modeStats.standard.points}/${sMax} pts (${sPct}%)</div>
<div><strong>Hard</strong>: ${modeStats.hard.correct}/${modeStats.hard.asked} correct • ${modeStats.hard.points}/${hMax} pts (${hPct}%)</div>
</div>
`;
UI.resOv.style.display = 'flex';
}
// ---------- Start + ordering ----------
function start(){
if (!UI.board) return;
// ensure a question set exists
if (!interQuestions.length && window.practiceGenerators?.generatePracticeSet){
interQuestions = window.practiceGenerators.generatePracticeSet(20);
}
// prepend demo once
if (!interDemoShown){
interQuestions = [ makeInterDemo(), ...interQuestions ];
interDemoShown = true;
}
// build order with demo first
const n = interQuestions.length;
const idxs = [...Array(n).keys()];
const demoIdx = interQuestions.findIndex(q => q && q.demo === true);
order = (demoIdx >= 0) ? [demoIdx, ...idxs.filter(x => x !== demoIdx).sort(()=>Math.random()-0.5)]
: idxs.sort(()=>Math.random()-0.5);
// resets
i = 0; score = 0; usedHint = false; locked = false;
interRating = 0; interStreak = 0;
modeStats.easy = { asked:0, correct:0, points:0 };
modeStats.standard = { asked:0, correct:0, points:0 };
modeStats.hard = { asked:0, correct:0, points:0 };
// kick off round timer
startRoundTimer();
// show board
if (UI.overlay){ UI.overlay.style.display = 'none'; UI.overlay.setAttribute('aria-hidden','true'); }
if (UI.board){ UI.board.classList.remove('qs-hide','inter-locked'); UI.board.style.display = 'grid'; }
renderQuestion();
}
// Bind Start once (avoid dup handlers)
(function bindInterStartOnce(){
const btn = $('interStartBtn');
if (!btn) return;
const clone = btn.cloneNode(true);
btn.parentNode.replaceChild(clone, btn);
clone.addEventListener('click', start, { once:true });
})();
// ---------- Navigate into Intermediate section ----------
$('ctaInter')?.addEventListener('click', () => {
const final = $('gameWrap');
const easy = $('easyChallenge');
const inter = $('intermediateSection');
const ov = $('interStartOverlay');
const board = $('interQuiz');
if (final){ final.classList.add('qs-hide'); final.style.display = 'none'; }
if (easy){ easy.classList.add('qs-hide'); easy.style.display = 'none'; }
if (inter){ inter.classList.remove('qs-hide'); inter.style.display = 'block'; }
if (board){ board.classList.add('qs-hide'); board.style.display = 'none'; }
if (ov){ ov.classList.remove('qs-hide'); ov.style.display = 'flex'; }
document.body.classList.remove('final-mode','easy-mode');
document.body.classList.add('intermediate-mode');
});
// ---------- Expose for external control ----------
window.practice = {
start,
setQuestions(arr){
if (!Array.isArray(arr) || !arr.length) { console.warn('setQuestions expects a non-empty array'); return; }
interQuestions = arr;
},
get questions(){ return interQuestions; }
};
// ---------- Results overlay buttons ----------
UI.restart?.addEventListener('click', () => {
UI.resOv.style.display = 'none';
start();
});
UI.back?.addEventListener('click', () => {
UI.resOv.style.display = 'none';
const inter = $('intermediateSection');
const final = $('gameWrap');
if (inter){ inter.style.display = 'none'; inter.classList.add('qs-hide'); }
if (final){ final.style.display = ''; final.classList.remove('qs-hide'); }
document.body.classList.remove('intermediate-mode');
document.body.classList.add('final-mode');
});
// ---------- Hide in-quiz Next & add overlay Next-to-Final ----------
(function hideInterNextBtn(){
const btn = $('interNext');
if (!btn) return;
btn.style.display = 'none';
btn.setAttribute('aria-hidden','true');
btn.disabled = true;
btn.onclick = null;
})();
(function ensureInterResultNext(){
const ov = UI.resOv;
if (!ov) return;
if (document.getElementById('interToFinalBtn')) return;
const btn = document.createElement('button');
btn.id = 'interToFinalBtn';
btn.type = 'button';
btn.textContent = 'Next: Final Challenge';
btn.style.marginLeft = '12px';
btn.style.padding = '10px 16px';
btn.style.borderRadius = '10px';
btn.style.fontWeight = '700';
const host = ov.querySelector('.actions') || ov.querySelector('.btn-row') || ov;
host.appendChild(btn);
btn.addEventListener('click', () => {
ov.style.display = 'none';
if (typeof window.gotoFinalStartOverlay === 'function'){
window.gotoFinalStartOverlay();
} else {
// fallback: show final container + try common overlay IDs
const inter = $('intermediateSection');
const final = $('gameWrap');
if (inter){ inter.style.display = 'none'; inter.classList.add('qs-hide'); }
if (final){ final.style.display = ''; final.classList.remove('qs-hide'); }
document.body.classList.remove('intermediate-mode');
document.body.classList.add('final-mode');
const candidates = ['finalStartOverlay','finalStart','finalChallengeStartOverlay','finalStartCard'];
for (const id of candidates){
const el = $(id);
if (el){ el.style.display = 'flex'; el.classList.remove('qs-hide'); break; }
}
}
});
})();
})();
/* ================== SOR-ONLY PRACTICE ENGINE (Q1–Q4) ================== */
(function(){
const $ = (id) => document.getElementById(id);
/* ---------- UI refs ---------- */
const UI = {
section: $('sorOnlySection'),
overlay: $('sorOnlyStartOverlay'),
startBtn: $('sorOnlyStartBtn'),
board: $('sorOnlyQuiz'),
stem: $('sorOnlyStem'),
given: $('sorOnlyGiven'),
opts: $('sorOnlyOptions'),
fb: $('sorOnlyFeedback'),
hint: $('sorOnlyHint'),
next: $('sorOnlyNext'),
scoreEl: $('sorOnlyScore'),
timerEl: $('sorOnlyTimer'),
resOv: $('sorOnlyResultOverlay'),
resTitle: $('sorOnlyResultTitle'),
resMsg: $('sorOnlyResultMsg'),
restart: $('sorOnlyRestartBtn'),
back: $('sorOnlyBackBtn'),
};
// Hide SOR-only Next button + row (auto-advance mode)
(()=>{
const btn = UI.next;
if (btn){
const row = btn.closest('.sor-next-row');
if (row) row.style.display = 'none';
else btn.style.display = 'none';
btn.setAttribute('aria-hidden','true');
}
})();
/* ---------- constants & state ---------- */
const PER_Q_SECS = 90; // 1:30 per question
const POINT_CORRECT = 2.0;
const HINT_PENALTY = 0.5; // deducted if hint used on a correct answer
let timerId = null;
let timeLeft = PER_Q_SECS;
let questions = []; // array of question objects
let order = []; // randomized order of indices
let i = 0; // current index in order
let score = 0;
let usedHint = false;
/* ---------- helpers ---------- */
const rnd = (min, max, step=1) => {
const n = Math.floor((max-min)/step);
const k = Math.floor(Math.random()*(n+1));
const dp = (step.toString().split('.')[1]||'').length;
return +(min + k*step).toFixed(dp);
};
const shuffle = a => { for (let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; };
const fmt = n => Number(n).toLocaleString();
const mmss = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
function stopTimer(){ if (timerId){ clearInterval(timerId); timerId = null; } }
function startTimer(){
stopTimer();
timeLeft = PER_Q_SECS;
if (UI.timerEl) UI.timerEl.textContent = mmss(timeLeft);
timerId = setInterval(()=>{
timeLeft--;
if (UI.timerEl) UI.timerEl.textContent = mmss(Math.max(0,timeLeft));
if (timeLeft <= 0){
stopTimer();
onTimeUp();
}
}, 1000);
}
function renderScore(){ if (UI.scoreEl) UI.scoreEl.textContent = `Score: ${score.toFixed(1)}`; }
/* =========================================================
QUESTION FACTORIES (Q1–Q4) — SOR FOCUS ONLY
========================================================= */
// Q1 — Required Area from SOR (peak flow design)
function qAreaFromSOR_Peak(){
const Qavg = rnd(8_000, 40_000, 100);
const PF = rnd(2.0, 3.0, 0.1);
const SOR = rnd(22, 38, 0.5); // target SOR (m³/m²·d)
const Qp = Qavg * PF;
const A = Qp / SOR; // required m²
const base = Math.round(A);
const raw = [base, Math.round(base*0.88), Math.round(base*1.12), Math.round(base*1.27)];
const opts = shuffle([...new Set(raw)]).slice(0,4);
const correct = opts.indexOf(base);
return {
stem: "What clarifier surface area is required (peak flow design)?",
given: `Q<sub>avg</sub> = <strong>${fmt(Qavg)}</strong> m³/d ; PF = <strong>${PF}</strong> ; SOR target = <strong>${SOR}</strong> m³/m²·d`,
options: opts.map(a => `${a} m²`),
correct,
hint: "Calculate on the basis of peak flow.",
explanation: `Q<sub>p</sub> = ${fmt(Qavg)}×${PF} = ${fmt(Qp.toFixed(0))} m³/d; A = Q<sub>p</sub>/SOR = ${fmt(Qp.toFixed(0))}/${SOR} ≈ ${base} m².`
};
}
// Q2 — Select Area so BOTH avg & peak lie within a dynamic SOR band (PF up to 3)
// We widen the lower bound so overlap exists: PF ≤ SORmax/SORmin
function qSelectAreaDualSORDynamic(){
const PF = rnd(2.0, 3.0, 0.1);
const SORmax = 40;
let SORmin = Math.max(12, Math.floor(SORmax / PF)); // ensure overlap
if (SORmin >= SORmax) SORmin = SORmax - 1;
const Qavg = rnd(10_000, 60_000, 100);
const Qp = PF*Qavg;
// Overlap in A: [ (PF*Qavg)/SORmax , Qavg/SORmin ]
const Amin = Math.ceil((PF*Qavg)/SORmax);
const Amax = Math.floor(Qavg/SORmin);
const A_both = Math.max(1, Math.round((Amin + Amax)/2));
// Construct behaviors
const A_peakOnly = A_both + Math.max(1, Math.round(0.08*A_both)); // avg too low
const A_avgOnly = Math.max(1, A_both - Math.max(1, Math.round(0.08*A_both))); // peak too high
const A_neither = A_both + Math.max(2, Math.round(0.35*A_both)); // both too low
// Deduplicate + ensure 4
const seen = new Set();
const candidates = [A_both, A_peakOnly, A_avgOnly, A_neither].map(v=>Math.max(1,Math.round(v)))
.filter(v => (seen.has(v) ? false : (seen.add(v), true)));
while (candidates.length < 4){
const jit = A_both + Math.round((Math.random()<0.5?-1:1)*A_both*(0.1+Math.random()*0.3));
if (jit>0 && !seen.has(jit)){ candidates.push(jit); seen.add(jit); }
}
const opts = shuffle(candidates.slice());
const correct = opts.indexOf(A_both);
return {
stem: "Select a clarifier area so SOR is within the specified band for BOTH average and peak flows.",
given: `Q<sub>avg</sub> = <strong>${fmt(Qavg)}</strong> m³/d ; PF = <strong>${PF.toFixed(1)}</strong> ; SOR band = <strong>${SORmin}–${SORmax}</strong> m³/m²·d`,
options: opts.map(a => `${a} m²`),
correct,
hint: "Calculate SOR for both Avererage and Peak flows.",
explanation: "One option keeps both avg and peak SOR inside the band; larger depresses avg too low, smaller raises peak too high."
};
}
// Q3 — Pick Rectangular Dimensions (L×B) that meet SOR (peak) AND limits.
// Guarantees: correct option satisfies SOR band 20–40, B≤8, L≤30, L:W≈4±0.2
function qPickRectDimsForSOR(){
// helper from your engine: rnd(min,max,step), shuffle(), fmt()
// Limits and band
const SORmin = 20, SORmax = 40;
// Try a few draws to ensure feasibility without deep recursion
for (let tries = 0; tries < 10; tries++){
const Qavg = rnd(12_000, 50_000, 100);
const PF = rnd(2.0, 3.0, 0.1);
const Qp = Qavg * PF;
// choose ratio close to 4:1
const r = rnd(3.9, 4.1, 0.01);
// geometry capacity: B ≤ 8 AND L=rB ≤ 30 ⇒ B ≤ min(8, 30/r)
const Bcap = Math.min(8, 30 / r);
const Amax = r * Bcap * Bcap; // maximum area allowed by limits
// SOR band → feasible area interval
const AbandMin = Qp / SORmax; // need A ≥ this
const AbandMax = Qp / SORmin; // and A ≤ this
// Check intersection with geometry
if (AbandMin <= Amax){
// Pick an area inside intersection, biased to the upper half
const upper = Math.min(AbandMax, Amax);
const lower = Math.max(AbandMin, 0.8 * upper);
const A_feas = Math.max(1, rnd(lower, upper, 0.1));
// Derive dimensions from area and ratio (keeps ratio ≈4)
let B = Math.sqrt(A_feas / r);
let L = r * B;
// Safety round + clamp tiny FP errors
B = +B.toFixed(1); L = +L.toFixed(1);
const A = +(L * B).toFixed(1);
const Speak = +(Qp / A).toFixed(1);
const ratio = +(L / B).toFixed(2);
const ok = (B <= 8 + 1e-9) && (L <= 30 + 1e-9)
&& (ratio >= 3.8 && ratio <= 4.2)
&& (Speak >= SORmin && Speak <= SORmax);
if (!ok) continue; // try another draw
// ---------- Build distractors ----------
const distractors = [];
// D1: SOR too high (area a bit too small), still within L,B limits
const A_small = +(A * 0.82).toFixed(1);
let B_small = +(Math.sqrt(A_small / r).toFixed(1));
let L_small = +(r * B_small).toFixed(1);
distractors.push({ L: L_small, B: B_small });
// D2: Length violation (L > 30) but width ≤ 8
// choose B that pushes L slightly over 30 while keeping B≤8
let B_long = Math.min(8, (30 / r) * 1.06);
if (B_long < 0.5) B_long = 0.5; // silly guard
B_long = +B_long.toFixed(1);
let L_long = +(r * B_long).toFixed(1);
// ensure violation (if rounding kept it ≤30, nudge)
if (L_long <= 30) { L_long = +(30.4).toFixed(1); B_long = +(L_long / r).toFixed(1); }
distractors.push({ L: L_long, B: B_long });
// D3: Ratio violation (use r_bad = 3.5 or 4.5), keep SOR roughly OK if possible
const r_bad = Math.random() < 0.5 ? 3.5 : 4.5;
const A_target = Math.min(Amax, Math.max(AbandMin, Math.min(AbandMax, A))); // keep near A
let B_bad = Math.sqrt(A_target / r_bad);
// respect geometry for width, but we want ratio violation; if this clips too hard,
// it may also upset SOR—fine, we only need *a* violation.
B_bad = Math.min(8, B_bad);
let L_bad = r_bad * B_bad;
if (L_bad > 30) { L_bad = 30.0; B_bad = L_bad / r_bad; }
B_bad = +B_bad.toFixed(1); L_bad = +L_bad.toFixed(1);
distractors.push({ L: L_bad, B: B_bad });
// Options: 1 correct + 3 distractors
const correct = { L, B };
const opts = [ correct, ...distractors ];
const order = shuffle([0,1,2,3]);
const options = order.map(k => `L = ${opts[k].L} m, B = ${opts[k].B} m`);
const correctIdx = order.indexOf(0);
return {
stem: "Choose the rectangular dimensions that satisfy SOR (peak) and dimensional limits.",
given: `Q<sub>avg</sub> = <strong>${fmt(Qavg)}</strong> m³/d • PF = <strong>${PF.toFixed(1)}</strong> • SOR band = 20–40 m³/m²·d • Limits: B ≤ 8 m, L ≤ 30 m, L:W ≈ 4:1 (±0.2)`,
options,
correct: correctIdx,
hint: "Area = L×B; SOR(peak) = (Qavg×PF)/Area. Check L:W≈4:1, B≤8 m, L≤30 m.",
explanation: `Feasible: L=${L} m, B=${B} m → A=${A} m², SOR(peak)=${Speak} m³/m²·d; ratio=${ratio}.`
};
}
// if not feasible with this draw, loop to try new Qavg/PF/r
}
// If all tries failed (very unlikely), fall back to a deterministic easy case
const Qavg = 20000, PF = 2.2, Qp = Qavg*PF, r = 4.0;
const Bcap = Math.min(8, 30/r); // = 7.5
const Amax = r*Bcap*Bcap; // 225 m²
const AbandMin = Qp/40, AbandMax = Qp/20; // 1100, 2200 — bigger than Amax, so clamp
const A = Math.min(Amax, (AbandMin+AbandMax)*0.25); // 225 m²
const B = +(Math.sqrt(A/r).toFixed(1)); // 7.5
const L = +(r*B).toFixed(1); // 30.0
const options = shuffle([
`L = ${L} m, B = ${B} m`, // correct (just at the edge)
`L = ${+(L*1.06).toFixed(1)} m, B = ${B} m`, // length violation
`L = ${L} m, B = ${+(B*0.82).toFixed(1)} m`, // SOR too high (smaller area)
`L = ${+(L*0.9).toFixed(1)} m, B = ${+(B*0.9).toFixed(1)} m` // ratio/area off
]);
return {
stem: "Choose the rectangular dimensions that satisfy SOR (peak) and dimensional limits.",
given: `Q<sub>avg</sub> = <strong>${fmt(Qavg)}</strong> m³/d • PF = <strong>${PF.toFixed(1)}</strong> • SOR band = 20–40 m³/m²·d • Limits: B ≤ 8 m, L ≤ 30 m, L:W ≈ 4:1 (±0.2)`,
options,
correct: options.indexOf(`L = ${L} m, B = ${B} m`),
hint: "Area = L×B; SOR(peak) = (Qavg×PF)/Area. Check L:W≈4:1, B≤8 m, L≤30 m.",
explanation: `Feasible: L=${L} m, B=${B} m (edge case).`
};
}
// Q4 — Number of Circular Tanks (by SOR only)
function qNumCircularTanksBySOR(){
const Qavg = rnd(15_000, 80_000, 100);
const PF = rnd(2.0, 3.0, 0.1);
const SOR = rnd(22, 36, 0.5);
const D = rnd(12, 28, 0.5);
const Qp = Qavg*PF;
const Areq = Qp / SOR;
const A1 = Math.PI*D*D/4;
let N = Math.ceil(Areq / A1);
if (N < 1) N = 1;
const candidateNs = [1,2,3,4];
const opts = shuffle(candidateNs);
const correctVal = Math.min(N, 4); // cap at 4 for layout
const correct = opts.indexOf(correctVal);
return {
stem: "How many circular tanks (same diameter) are required to satisfy SOR at peak?",
given: `Q<sub>avg</sub> = <strong>${fmt(Qavg)}</strong> m³/d ; PF = <strong>${PF}</strong> ; SOR target = <strong>${SOR}</strong> m³/m²·d ; Tank diameter D = <strong>${D}</strong> m`,
options: opts.map(n => `${n} tank${n>1?'s':''}`),
correct,
hint: "Compare your calculated value with the value caculated by following the design criteria",
explanation: `A<sub>req</sub> ≈ ${Math.round(Areq)} m²; A<sub>1</sub> = ${Math.round(A1)} m²; so N ≈ ${Math.ceil(Areq/A1)}.`
};
}
// Build a 20-question set, cycling Q1..Q4
function buildSet(N=20){
const factories = [qAreaFromSOR_Peak, qSelectAreaDualSORDynamic, qPickRectDimsForSOR, qNumCircularTanksBySOR];
const out = [];
for (let k=0;k<N;k++){
const f = factories[k % factories.length];
out.push(f());
}
return out;
}
/* =========================================================
RENDER / INTERACTION
========================================================= */
function renderQuestion(){
const q = questions[order[i]];
if (!q) { return endQuiz(); }
// reset UI
UI.board?.classList.remove('sor-locked');
UI.fb.textContent = '';
UI.hint.classList.remove('used');
UI.next.disabled = true;
usedHint = false;
// text
UI.stem.innerHTML = q.stem;
UI.given.innerHTML = q.given;
// options
UI.opts.innerHTML = '';
q.options.forEach((t, idx) => {
const btn = document.createElement('button');
btn.className = 'sor-opt';
btn.innerHTML = t;
btn.addEventListener('click', () => onPick(q, idx, btn));
UI.opts.appendChild(btn);
});
// hint
UI.hint.onclick = () => {
if (UI.hint.classList.contains('used')) return;
usedHint = true;
UI.hint.classList.add('used');
UI.fb.innerHTML = q.hint || 'Think about SOR at peak vs average.';
};
renderScore();
startTimer();
}
function onPick(q, idx, btn){
stopTimer();
// disable all
const kids = [...UI.opts.children];
kids.forEach(b=>b.disabled=true);
if (idx === q.correct){
btn.classList.add('correct');
score += usedHint ? 1.5 : 2;
// motivational message instead of explanation
const totalPossible = questions.length * 2;
const needed = Math.max(0, 0.9*totalPossible - score); // 90% target
if (needed > 0){
UI.fb.innerHTML = ` Correct! Keep going — earn <strong>${needed.toFixed(1)}</strong> more points to unlock the next level.`;
} else {
UI.fb.innerHTML = ` Correct! You’ve reached the score needed to unlock the next level!`;
}
} else {
btn.classList.add('wrong');
const kids = [...UI.opts.children];
kids[q.correct].classList.add('correct');
UI.fb.innerHTML = ` Wrong. Correct answer: <strong>${q.options[q.correct]}</strong>`;
}
renderScore();
// auto-advance after brief pause
setTimeout(next, 900);
// Auto-advance after feedback (no extra click)
if (window.sorAutoAdvance) {
clearTimeout(window.sorAutoAdvance);
window.sorAutoAdvance = null;
}
window.sorAutoAdvance = setTimeout(() => {
// don’t jump if a result overlay is up
const ov = document.getElementById('sorOnlyResultOverlay');
if (ov && ov.style.display === 'flex') return;
// reuse your existing flow
if (UI.next && typeof UI.next.click === 'function') {
UI.next.click();
} else if (typeof next === 'function') {
next();
}
}, 900); // adjust delay if you like
}
function onTimeUp(){
if (window.sorAutoAdvance) {
clearTimeout(window.sorAutoAdvance);
window.sorAutoAdvance = null;
}
UI.board?.classList.add('sor-locked');
const kids = [...UI.opts.children];
kids.forEach(b=>b.disabled=true);
const q = questions[order[i]];
if (q && kids[q.correct]) kids[q.correct].classList.add('correct');
UI.fb.innerHTML = `Time’s up!<br><span style="opacity:.85">Answer: ${q?.options?.[q.correct] || ''}</span>`;
setTimeout(next, 900);
}
function next(){
stopTimer();
i++;
if (i >= order.length) return endQuiz();
renderQuestion();
}
function endQuiz(){
stopTimer();
const maxPts = order.length * POINT_CORRECT;
const passMark = 0.9 * maxPts; // 90% to pass
const passed = score >= passMark;
UI.resTitle.textContent = passed ? "Well done — Passed!" : "Session Complete";
UI.resMsg.innerHTML =
`Final Score: <strong>${score.toFixed(1)}</strong> / ${maxPts.toFixed(1)}<br>` +
`Required to pass: <strong>${passMark.toFixed(1)}</strong> (90%)`;
UI.resOv.style.display = 'flex';
}
function start(){
stopTimer();
questions = buildSet(20); // 20 questions
order = shuffle([...Array(questions.length).keys()]);
i = 0; score = 0; usedHint = false;
renderQuestion();
}
// Expose an API (handy for linking/tests)
window.sorOnly = {
start,
setQuestions: (arr)=>{ questions = arr.slice(); order = shuffle([...Array(questions.length).keys()]); i=0; score=0; usedHint=false; renderQuestion(); }
};
/* ---------- wiring ---------- */
UI.startBtn?.addEventListener('click', () => {
UI.overlay.style.display = 'none';
UI.board.classList.remove('qs-hide','sor-locked');
UI.board.style.removeProperty('display'); // use CSS grid
start();
});
UI.next?.addEventListener('click', next);
UI.restart?.addEventListener('click', () => {
UI.resOv.style.display = 'none';
start();
});
UI.back?.addEventListener('click', () => {
UI.resOv.style.display = 'none';
UI.board.classList.add('qs-hide');
UI.board.style.display = 'none';
UI.section.classList.add('qs-hide');
UI.section.style.display = 'none';
// optional: return to Easy or Final; you can customize later
});
// Optional console helper: window.openSorOnly()
window.openSorOnly = () => {
UI.section.classList.remove('qs-hide'); UI.section.style.removeProperty('display');
UI.overlay.style.display = 'flex';
};
})();
//show SorOnly Result Overlay
function showSorOnlyResultOverlay(finalScore) {
// Track personal best
const key = 'sorOnlyBest';
let best = Number(localStorage.getItem(key) || 0);
if (finalScore > best) {
best = finalScore;
localStorage.setItem(key, String(best));
}
// Title + message (simple feedback tiers; tweak as you like)
const ttl = document.getElementById('sorOnlyResultTitle');
const msg = document.getElementById('sorOnlyResultMsg');
if (finalScore >= 18) {
ttl.textContent = "Great job!";
msg.textContent = "You’re ready to push into the Intermediate level.";
} else if (finalScore >= 10) {
ttl.textContent = "Nice progress";
msg.textContent = "Keep practicing to boost consistency, or proceed to Intermediate.";
} else {
ttl.textContent = "Keep going";
msg.textContent = "Aim for 10+ to get comfortable before moving on.";
}
// Fill scores
document.getElementById('sorOnlyFinalScore').textContent = finalScore.toFixed(2);
document.getElementById('sorOnlyBestScore').textContent = best.toFixed(2);
// Show overlay
const ov = document.getElementById('sorOnlyResultOverlay');
if (ov) ov.style.display = 'flex';
}
// Restart SOR-only
document.getElementById('sorOnlyRestartBtn')?.addEventListener('click', () => {
document.getElementById('sorOnlyResultOverlay').style.display = 'none';
// Reset & start the SOR-only practice again (call your existing start function)
// Example:
// startSorOnlyPractice(); // <- replace with your function name
const quiz = document.getElementById('sorOnlyQuiz');
if (quiz) { quiz.classList.remove('qs-hide'); quiz.style.display = 'block'; }
// and re-init timer/question here as you already do
});
// Go to Intermediate section
document.getElementById('sorOnlyNextBtn')?.addEventListener('click', () => {
// Hide SOR-only overlay & section
document.getElementById('sorOnlyResultOverlay').style.display = 'none';
const s = document.getElementById('sorOnlySection');
if (s){ s.classList.add('qs-hide'); s.style.display = 'none'; }
// Show Intermediate section (with its start overlay)
const inter = document.getElementById('intermediateSection');
const ov = document.getElementById('interStartOverlay');
if (inter){ inter.classList.remove('qs-hide'); inter.style.display = 'block'; }
if (ov){ ov.style.display = 'flex'; }
// Body class toggle (optional, if you use wallpaper modes)
document.body.classList.remove('easy-mode','final-mode');
document.body.classList.add('intermediate-mode');
});
// Back (decide where you want to go — to Easy, or Final menu)
document.getElementById('sorOnlyBackBtn')?.addEventListener('click', () => {
document.getElementById('sorOnlyResultOverlay').style.display = 'none';
// Example: go back to Easy Challenge landing
const easy = document.getElementById('easyChallenge');
if (easy){ easy.classList.remove('qs-hide'); easy.style.display = 'block'; }
const sor = document.getElementById('sorOnlySection');
if (sor){ sor.classList.add('qs-hide'); sor.style.display = 'none'; }
document.body.classList.remove('intermediate-mode');
document.body.classList.add('easy-mode');
});
/* =========================================================
WEIR — Easy (Part 1) -> gate -> 60s (Part 2)
========================================================= */
(function(){
const $ = (id) => document.getElementById(id);
const show = (el, disp='block') => { if (!el) return; el.classList.remove('qs-hide'); el.style.display = disp; };
const hide = (el) => { if (!el) return; el.style.display = 'none'; el.classList.add('qs-hide'); };
/* --------------------------
PART 1: Easy (3 options)
-------------------------- */
// Fixed Example values (left column)
const EX = { L: 50, WLR: 200 }; // m ; m³/day·m
EX.Q = EX.L * EX.WLR; // m³/day
const P1 = {
hostId: 'weirQuiz',
openBtnSel: '#topicWLRBtn',
scoreGoal: 10, // gate threshold
pts: 2, // +2 per correct
};
function randBetween(min,max,step){
const n = Math.floor((max-min)/step);
const k = Math.floor(Math.random()*(n+1));
const dp = (step.toString().split('.')[1]||'').length;
return +(min + k*step).toFixed(dp);
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
const fmt = (n) => Number(n).toLocaleString();
// Re-query UI each time so elements are never "stale"
function P1UI(){
return {
host: $('weirQuiz'),
exQ: $('weirExQ'),
exL: $('weirExL'),
exWL: $('weirExWL'),
givenQ: $('weirGivenQ'),
givenL: $('weirGivenL'),
opts: $('weirOptions'),
fb: $('weirFeedback'),
scoreEl: $('weirScore') // <div id="weirScore">Score: 0</div> (we overwrite text)
};
}
let p1Score = 0;
let p1Running = false;
function openWeirEasy(){
// Close picker; hide other cards
const picker = $('easyTopicOverlay'); if (picker) picker.style.display = 'none';
['sorQuiz','detQuiz','weir60'].forEach(id => hide($(id)));
const ui = P1UI();
if (!ui.host) return console.warn('Missing #weirQuiz');
show(ui.host, 'grid');
startWeirEasy(true);
}
window.openWeirEasy = openWeirEasy;
// Button: open Weir Easy from topic chooser (capture to beat other listeners)
document.addEventListener('click', (ev) => {
const btn = ev.target.closest(P1.openBtnSel);
if (!btn) return;
ev.preventDefault();
ev.stopPropagation();
ev.stopImmediatePropagation();
openWeirEasy();
}, true);
function startWeirEasy(reset=true){
const ui = P1UI();
if (reset){
p1Score = 0;
if (ui.scoreEl) ui.scoreEl.textContent = 'Score: 0';
if (ui.fb) ui.fb.textContent = '';
// Fixed example (left) — set once per run
if (ui.exQ) ui.exQ.textContent = fmt(EX.Q);
if (ui.exL) ui.exL.textContent = EX.L;
if (ui.exWL) ui.exWL.textContent = EX.WLR;
}
p1Running = true;
renderP1();
}
window.startWeirEasy = startWeirEasy;
function makeP1(){
// Build a tidy question: pick L & WLR, derive Q (WLR = Q / L)
const L = randBetween(40,160,2); // m
const WLR = randBetween(150,450,10); // m³/day·m
const Q = WLR * L; // m³/day
// options (3) around correct
const seeds = new Set([WLR]);
for (const f of [0.85, 1.15, 0.9, 1.1, 0.75, 1.25]){
if (seeds.size >= 3) break;
let v = Math.round(WLR * f);
v = Math.max(100, Math.min(600, v));
seeds.add(v);
}
while (seeds.size < 3) seeds.add(randBetween(125,500,5));
const all = [...seeds];
const distractors = all.filter(v => v !== WLR);
shuffle(distractors);
const options = shuffle([WLR, ...distractors.slice(0, 2)]);
const correctIdx = options.indexOf(WLR);
return { L, Q, options, correctIdx };
}
function renderP1(){
if (!p1Running) return;
const ui = P1UI();
// write givens
const q = makeP1();
if (ui.givenQ) ui.givenQ.textContent = `= ${fmt(q.Q)} m³/day`;
if (ui.givenL) ui.givenL.textContent = `= ${q.L} m`;
// build options
ui.fb && (ui.fb.textContent = '');
if (ui.opts) ui.opts.innerHTML = '';
q.options.forEach((val, idx) => {
const b = document.createElement('button');
b.type = 'button';
// include all common classes so your CSS catches it no matter what
b.className = 'weir-opt option sor-opt';
b.dataset.idx = idx;
b.innerHTML = `${val} m³/day·m`;
ui.opts.appendChild(b);
});
const onPick = (ev) => {
const btn = ev.target.closest('button');
if (!btn) return;
ui.opts.removeEventListener('click', onPick);
[...ui.opts.querySelectorAll('button')].forEach(b => b.disabled = true);
const i = +btn.dataset.idx;
if (i === q.correctIdx){
btn.classList.add('correct');
ui.fb && (ui.fb.textContent = 'Correct');
p1Score += P1.pts;
ui.scoreEl && (ui.scoreEl.textContent = `Score: ${p1Score}`);
if (p1Score >= P1.scoreGoal){
// unlock 60s
window.__weir60Eligible = true;
p1Running = false;
// hide P1 card
hide(ui.host);
// open 60s start overlay
openWeir60(); // will show overlay if present
return;
}
} else {
btn.classList.add('wrong');
const good = ui.opts.children[q.correctIdx];
good && good.classList.add('correct');
ui.fb && (ui.fb.textContent = 'Try the next one');
}
setTimeout(renderP1, 700);
};
ui.opts.addEventListener('click', onPick);
}
})();
/* ================================================
WOR 60s — timed quiz (direct WLR = Q / L)
Router-free; mirrors SOR Part-2 structure
================================================ */
(function(){
const $ = (id) => document.getElementById(id);
// ---------- UI refs ----------
const UI = {
shell: $('weir60'), // main 60s card/section
flow: $('weir60Q'), // Average Flow (m³/day)
wlen: $('weir60L'), // Weir Length (m)
opts: $('weir60Options'), // options container
fb: $('weir60Feedback'), // feedback text
score: $('weir60Score'), // HUD score
timer: $('weir60Timer'), // HUD timer
// overlays
startOv: $('weir60StartOverlay'),
resOv: $('weir60ResultOverlay'),
};
// ---------- State ----------
let bestScore = Number(localStorage.getItem('weir60Best') || 0); // persistent best
let easyScore = 0; // resets every round
let timeLeft = 60;
let timerId = null;
let locked = false;
let correctWLR = null;
// ---------- Helpers ----------
function randBetween(min,max,step){
const n = Math.floor((max-min)/step);
const k = Math.floor(Math.random()*(n+1));
const dp = (step.toString().split('.')[1]||'').length;
return +(min + k*step).toFixed(dp);
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
function updateHUD(){
if (UI.score) UI.score.textContent = `Score: ${easyScore.toFixed(2)}`;
if (UI.timer) UI.timer.textContent = `${timeLeft}s`;
window.easyScore = easyScore; // if anything else peeks at it
}
function stopTimer(){ if (timerId){ clearInterval(timerId); timerId=null; } }
function startTimer(){
stopTimer();
updateHUD();
timerId = setInterval(()=>{
timeLeft--;
updateHUD();
if (timeLeft <= 0){
stopTimer();
endRound();
}
}, 1000);
}
// ---------- Question generation (direct WOR numeric) ----------
// WLR (a.k.a. WOR) = Q / L
function makeQuestion(){
const L = randBetween(25, 160, 1); // m
const WLRt = randBetween(150, 450, 0.01); // target WOR m³/day·m
const Q = Math.round((WLRt * L) / 10) * 10; // flow rounded to nearest 10
const wlr = +(Q / L).toFixed(2); // exact answer shown in options
return { Q, L, wlr };
}
function buildOptions(correct){
const set = new Set([correct]);
const bumps = [-0.15,-0.10,-0.05,+0.05,+0.10,+0.15];
for (const b of bumps){
if (set.size >= 3) break;
let v = +(correct * (1+b)).toFixed(2);
v = Math.max(80, Math.min(600, v));
set.add(v);
}
while (set.size < 3) set.add(randBetween(120, 520, 0.01));
return shuffle([...set]);
}
// ---------- Render / Interactions ----------
function renderQuestion(){
if (timeLeft <= 0) return;
locked = false; correctWLR = null;
UI.fb.textContent = '';
const q = makeQuestion();
correctWLR = q.wlr;
UI.flow.textContent = q.Q.toLocaleString();
UI.wlen.textContent = q.L.toLocaleString();
UI.opts.innerHTML = '';
buildOptions(q.wlr).forEach(v=>{
const btn = document.createElement('button');
btn.className = 'sor-opt';
btn.textContent = `${v} m³/day·m`;
btn.addEventListener('click', () => onPick(v, btn));
UI.opts.appendChild(btn);
});
}
function onPick(value, btn){
if (locked || timeLeft <= 0) return;
locked = true;
[...UI.opts.children].forEach(b=>b.disabled=true);
if (+value === +correctWLR){
btn.classList.add('correct');
UI.fb.textContent = 'Correct!';
easyScore += 2; // +2 points
} else {
btn.classList.add('wrong');
const good = [...UI.opts.children]
.find(b => +b.textContent.replace(/[^\d.]/g,'') === +correctWLR);
good?.classList.add('correct');
UI.fb.textContent = `Answer: ${correctWLR} m³/day·m`;
easyScore -= 0.05; // small penalty to keep rhythm
if (easyScore < 0) easyScore = 0;
}
updateHUD();
// Auto-advance after a short pause
setTimeout(()=>{ if (timeLeft > 0) renderQuestion(); }, 700);
}
// ---------- Round control ----------
function startFreshRound(){
easyScore = 0;
timeLeft = 60;
locked = false;
UI.fb.textContent = '';
UI.opts.innerHTML = '';
updateHUD();
renderQuestion();
startTimer();
}
window.startWeir60Fresh = startFreshRound; // optional global
function initWeir60(){ startFreshRound(); }
// ---------- Results overlay (Final/Best + SOR-style tiers) ----------
function endRound(){
if (easyScore > bestScore){
bestScore = easyScore;
localStorage.setItem('weir60Best', String(bestScore));
}
[...UI.opts.children].forEach(b=>b.disabled = true);
const ov = $('weir60ResultOverlay');
const ttl = $('weir60ResultTitle');
const msg = $('weir60ResultMsg');
const fsc = $('weir60FinalScore');
const bsc = $('weir60BestScore');
const btnRetry = $('weir60RetryBtn');
const btnRestart = $('weir60RestartBtn');
const btnNext = $('weir60NextBtn');
fsc && (fsc.textContent = easyScore.toFixed(2));
bsc && (bsc.textContent = bestScore.toFixed(2));
if (btnRetry) btnRetry.style.display = 'none';
if (btnRestart) btnRestart.style.display = 'none';
if (btnNext) btnNext.style.display = 'none';
if (easyScore === 0){
ttl && (ttl.textContent = "Let's try again");
msg && (msg.textContent = "You scored 0 points. Click Restart to try a fresh 60-second round.");
btnRestart && (btnRestart.style.display = 'inline-block');
} else if (easyScore >= 10){
ttl && (ttl.textContent = "Great job!");
msg && (msg.textContent = "You reached the minimum score. You can go to the next level, or restart to improve your best.");
btnNext && (btnNext.style.display = 'inline-block');
btnRestart && (btnRestart.style.display = 'inline-block');
} else {
ttl && (ttl.textContent = "Keep going");
msg && (msg.textContent = "Minimum score of 10 is needed to go to the next level. You can continue now and make up points later.");
btnRetry && (btnRetry.style.display = 'inline-block');
btnNext && (btnNext.style.display = 'inline-block');
}
if (ov) ov.style.display = 'flex';
}
// ---------- Overlay openers (Start) ----------
window.showWeir60Overlay = function(){
if (UI.startOv) UI.startOv.style.display = 'flex';
};
window.startWeir60Quiz = function(){
if (UI.startOv) UI.startOv.style.display = 'none';
if (UI.shell){ UI.shell.classList.remove('qs-hide'); UI.shell.style.display='block'; }
initWeir60();
};
// Start overlay buttons
$('weir60StartBtn')?.addEventListener('click', () => window.startWeir60Quiz());
$('weir60BackBtn')?.addEventListener('click', () => {
if (UI.startOv) UI.startOv.style.display = 'none';
const picker = $('easyTopicOverlay'); if (picker) picker.style.display = 'flex';
});
// After WOR Easy Part-1 completes, show the Start overlay
// (From Part-1: document.dispatchEvent(new CustomEvent('weirQuizDone')))
document.addEventListener('weirQuizDone', () => {
const q1 = $('weirQuiz');
if (q1){ q1.classList.add('qs-hide'); q1.style.display='none'; }
window.showWeir60Overlay();
});
// Results overlay buttons (same pattern as SOR)
document.addEventListener('click', (e) => {
const t = e.target; if (!t) return;
if (t.id === 'weir60RetryBtn'){ // Re-try => new 60s round
UI.resOv?.style && (UI.resOv.style.display = 'none');
startFreshRound();
}
if (t.id === 'weir60RestartBtn'){ // Restart => new 60s round
UI.resOv?.style && (UI.resOv.style.display = 'none');
startFreshRound();
}
if (t.id === 'weir60NextBtn'){ // Next => go to Weir-90 (no router; call directly)
UI.resOv?.style && (UI.resOv.style.display = 'none');
if (typeof window.openWeir90 === 'function') {
window.openWeir90(); // show 90s start overlay
} else {
console.warn('openWeir90() not defined yet.');
}
}
});
// Optional global opener if you need to trigger WOR-60 from elsewhere
window.openWeir60 = function({ skipOverlay = false } = {}){
const picker = $('easyTopicOverlay'); if (picker) picker.style.display = 'none';
if (skipOverlay) window.startWeir60Quiz();
else window.showWeir60Overlay();
};
})();
/* ================== WEIR PRACTICE ENGINE (90 sec/question) ================== */
(function(){
const $ = (id) => document.getElementById(id);
/* ---------- UI refs ---------- */
const UI = {
section: $('weir90Section'),
overlay: $('weir90StartOverlay'),
startBtn: $('weir90StartBtn'),
board: $('weir90Quiz'),
stem: $('weir90Stem'),
given: $('weir90Given'),
opts: $('weir90Options'),
fb: $('weir90Feedback'),
hint: $('weir90Hint'),
next: $('weir90Next'),
scoreEl: $('weir90Score'),
timerEl: $('weir90Timer'),
resOv: $('weir90ResultOverlay'),
resTitle: $('weir90ResultTitle'),
resMsg: $('weir90ResultMsg'),
resFinal: $('weir90FinalScore'),
resBest: $('weir90BestScore'),
restart: $('weir90RestartBtn'),
toNext: $('weir90NextBtn'),
back2: $('weir90BackBtn2'),
};
// Hide explicit Next (auto-advance like SOR)
(()=>{
const btn = UI.next;
if (btn){
const row = btn.closest('.sor-next-row');
if (row) row.style.display = 'none';
else btn.style.display = 'none';
btn.setAttribute('aria-hidden','true');
btn.disabled = true;
}
})();
/* ---------- constants & state ---------- */
const PER_Q_SECS = 90;
const POINT_CORRECT = 2.0;
const HINT_PENALTY = 0.5; // deducted if hint used on a correct answer
const PASS_SCORE = 20; // show "Next" when final ≥ 20
const NUM_QUESTIONS = 20;
let timerId = null, timeLeft = PER_Q_SECS;
let questions = [], order = [], i = 0;
let score = 0, usedHint = false;
// persistent best
let bestKey = 'weir90Best';
let best = Number(localStorage.getItem(bestKey) || 0);
/* ---------- helpers ---------- */
const rnd = (min, max, step=1) => {
const n = Math.floor((max-min)/step);
const k = Math.floor(Math.random()*(n+1));
const dp = (step.toString().split('.')[1]||'').length;
return +(min + k*step).toFixed(dp);
};
const shuffle = a => { for (let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; };
const fmt = n => Number(n).toLocaleString();
const mmss = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
function stopTimer(){ if (timerId){ clearInterval(timerId); timerId = null; } }
function startTimer(){
stopTimer();
timeLeft = PER_Q_SECS;
UI.timerEl.textContent = mmss(timeLeft);
timerId = setInterval(()=>{
timeLeft--;
UI.timerEl.textContent = mmss(Math.max(0,timeLeft));
if (timeLeft <= 0){ stopTimer(); onTimeUp(); }
}, 1000);
}
function renderScore(){ UI.scoreEl.textContent = `Score: ${score.toFixed(1)}`; }
/* =========================================================
QUESTION FACTORIES — WOR (numeric answers, auto-advance)
========================================================= */
// Q1 — Minimum number of tanks (integer)
// Given Q (m³/d), allowable WOR W* (m³/d·m), weir length per tank L (m)
// N ≥ Q/(W*·L)
function qNfromQL(){
const Q = rnd(8_000, 60_000, 100);
const Wst = rnd(180, 450, 1); // allowable WOR
const Lt = rnd(20, 80, 0.5); // m per tank
const Nmin = Math.ceil(Q / (Wst * Lt));
const ans = Math.max(1, Nmin);
// build 4 unique integer options around ans
const pool = new Set([ans]);
while (pool.size < 4){
const delta = (Math.random()<0.5 ? -1 : 1) * rnd(1,3,1);
pool.add(Math.max(1, ans + delta));
}
const options = shuffle([...pool]).map(n => `${n}`);
return {
stem: 'How many tanks are needed to satisfy the allowable WOR?',
given: `Q = <strong>${fmt(Q)}</strong> m³/d • Allowable WOR = <strong>${Wst.toFixed(0)}</strong> m³/d·m • Weir length/tank = <strong>${Lt.toFixed(1)}</strong> m`,
options,
correct: options.indexOf(String(ans)),
hint: 'Use WOR = Q / (N·L). Choose the smallest integer N such that WOR ≤ allowable.',
};
}
// Q2 — Required weir length per tank (two decimals)
// L ≥ (Q / W*) / N
function qLfromQN(){
const Q = rnd(12_000, 80_000, 100);
const Wst = rnd(200, 420, 1);
const N = rnd(2, 6, 1);
const L = Q / (Wst * N);
const ans = +(L.toFixed(2));
const decoys = [ +(ans*0.85).toFixed(2), +(ans*1.10).toFixed(2), +(ans*0.95).toFixed(2) ];
const options = shuffle([ans, ...decoys]).map(v => v.toFixed(2));
return {
stem: 'Required weir length per tank to meet allowable WOR?',
given: `Q = <strong>${fmt(Q)}</strong> m³/d • Allowable WOR = <strong>${Wst.toFixed(0)}</strong> m³/d·m • Number of tanks = <strong>${N}</strong>`,
options,
correct: options.indexOf(ans.toFixed(2)),
hint: 'Rearrange WOR ≤ W*: L_total ≥ Q/W*. With N tanks: L ≥ (Q/W*)/N.',
};
}
// Q3 — Compute WOR for current setup (numeric)
// WOR = Q / (N·L)
function qWORfromSetup(){
const Q = rnd(10_000, 90_000, 100);
const N = rnd(2, 8, 1);
const Lt = rnd(18, 85, 0.1);
const WOR = +(Q / (N * Lt)).toFixed(2);
const ans = WOR;
const decoys = [ +(ans*0.9).toFixed(2), +(ans*1.1).toFixed(2), +(ans*1.25).toFixed(2) ];
const options = shuffle([ans, ...decoys]).map(v => `${(+v).toFixed(2)}`);
return {
stem: 'What is the current WOR for the setup?',
given: `Q = <strong>${fmt(Q)}</strong> m³/d • N = <strong>${N}</strong> • L/tank = <strong>${Lt.toFixed(1)}</strong> m`,
options,
correct: options.indexOf(ans.toFixed(2)),
hint: 'Compute WOR = Q / (N·L).',
};
}
// Q4 — Maximum allowable flow for given W* and geometry (rounded to nearest 10)
// Qmax = W* · N · L
function qMaxFlowWithinAllowable(){
const Wst = rnd(180, 420, 1);
const N = rnd(2, 6, 1);
const Lt = rnd(20, 75, 0.5);
const raw = Wst * N * Lt;
const ans = Math.round(raw / 10) * 10; // round to nearest 10
const decoys = [
Math.round(ans*0.85/10)*10,
Math.round(ans*1.10/10)*10,
Math.round(ans*0.95/10)*10
];
const options = shuffle([ans, ...decoys]).map(v => fmt(v));
return {
stem: 'What is the maximum allowable FLOW (Q) for the given W*, N, and L?',
given: `Allowable WOR = <strong>${Wst.toFixed(0)}</strong> m³/d·m • N = <strong>${N}</strong> • L/tank = <strong>${Lt.toFixed(1)}</strong> m`,
options: options.map(s => `${s} m³/d`),
correct: options.indexOf(fmt(ans)),
hint: 'Use Qmax = W* × N × L (round reasonably).',
};
}
// Build a 20-question set, cycling the four types
function buildSet(N=NUM_QUESTIONS){
const factories = [qNfromQL, qLfromQN, qWORfromSetup, qMaxFlowWithinAllowable];
const out = [];
for (let k=0; k<N; k++) out.push(factories[k % factories.length]());
return out;
}
/* ---------- RENDER / INTERACTION ---------- */
function renderQuestion(){
const q = questions[order[i]];
if (!q) return endQuiz();
UI.board?.classList.remove('sor-locked');
UI.fb.textContent = '';
UI.hint.classList.remove('used');
UI.next && (UI.next.disabled = true);
usedHint = false;
UI.stem.innerHTML = q.stem;
UI.given.innerHTML = q.given;
UI.opts.innerHTML = '';
q.options.forEach((t, idx) => {
const btn = document.createElement('button');
btn.className = 'sor-opt';
btn.innerHTML = t;
btn.addEventListener('click', () => onPick(q, idx, btn));
UI.opts.appendChild(btn);
});
// Hint
UI.hint.onclick = () => {
if (UI.hint.classList.contains('used')) return;
usedHint = true;
UI.hint.classList.add('used');
UI.fb.innerHTML = q.hint || 'Use WOR = Q / (N·L). Compare with allowable if needed.';
};
renderScore();
startTimer();
}
function onPick(q, idx, btn){
stopTimer();
const kids = [...UI.opts.children];
kids.forEach(b=>b.disabled=true);
if (idx === q.correct){
btn.classList.add('correct');
score += usedHint ? (POINT_CORRECT - HINT_PENALTY) : POINT_CORRECT;
if (score < 0) score = 0;
UI.fb.innerHTML = ` Correct!`;
} else {
btn.classList.add('wrong');
kids[q.correct]?.classList.add('correct');
UI.fb.innerHTML = ` Wrong. Correct answer: <strong>${q.options[q.correct]}</strong>`;
}
renderScore();
// Auto-advance after brief pause
setTimeout(next, 900);
}
function onTimeUp(){
UI.board?.classList.add('sor-locked');
const kids = [...UI.opts.children];
kids.forEach(b=>b.disabled=true);
const q = questions[order[i]];
if (q && kids[q.correct]) kids[q.correct].classList.add('correct');
UI.fb.innerHTML = `Time’s up!`;
setTimeout(next, 900);
}
function next(){
stopTimer();
i++;
if (i >= order.length) return endQuiz();
renderQuestion();
}
function endQuiz(){
stopTimer();
const finalScore = score;
// Title/Msg tiers (gate at 20 for Next)
if (finalScore >= PASS_SCORE){
UI.resTitle.textContent = "Great job!";
UI.resMsg.textContent = "You reached the minimum score. You can proceed to Intermediate, or restart to improve your best.";
} else {
UI.resTitle.textContent = "Session complete";
UI.resMsg.textContent = `Aim for ${PASS_SCORE}+ to unlock Next confidently.`;
}
// Personal best
if (finalScore > best){ best = finalScore; localStorage.setItem(bestKey, String(best)); }
UI.resFinal.textContent = finalScore.toFixed(2);
UI.resBest.textContent = best.toFixed(2);
// Show overlay + control Next visibility
UI.resOv.style.display = 'flex';
const nextBtn = UI.toNext;
if (nextBtn) nextBtn.style.display = (finalScore >= PASS_SCORE) ? 'inline-block' : 'none';
}
function start(){
stopTimer();
questions = buildSet(NUM_QUESTIONS);
order = shuffle([...Array(questions.length).keys()]);
i = 0; score = 0; usedHint = false;
UI.board?.classList.remove('qs-hide'); UI.board.style.removeProperty('display');
renderQuestion();
}
/* ---------- wiring ---------- */
UI.startBtn?.addEventListener('click', () => {
UI.overlay.style.display = 'none';
UI.board.classList.remove('qs-hide','sor-locked');
UI.board.style.removeProperty('display');
start();
});
UI.next?.addEventListener('click', next); // (hidden, for parity)
UI.restart?.addEventListener('click', () => {
UI.resOv.style.display = 'none';
start();
});
UI.toNext?.addEventListener('click', () => {
// Hide overlay + section, then open Intermediate (like SOR)
UI.resOv.style.display = 'none';
UI.section.classList.add('qs-hide'); UI.section.style.display = 'none';
const inter = $('intermediateSection');
const ov = $('interStartOverlay');
if (inter){ inter.classList.remove('qs-hide'); inter.style.display = 'block'; }
if (ov){ ov.style.display = 'flex'; }
});
UI.back2?.addEventListener('click', () => {
UI.resOv.style.display = 'none';
UI.section.classList.add('qs-hide'); UI.section.style.display = 'none';
const topic = $('easyTopicOverlay'); if (topic) topic.style.display = 'flex';
});
// Opener (called from 60s "Next" or elsewhere)
window.openWeir90 = () => {
const sec = $('weir90Section'); const ov = $('weir90StartOverlay');
if (sec){ sec.classList.remove('qs-hide'); sec.style.removeProperty('display'); }
if (ov){ ov.style.display = 'flex'; }
};
})();
/* =========================================================
EASY: DETENTION TIME QUIZ (clone of SOR Easy Part 1)
========================================================= */
(function(){
const $ = (id)=>document.getElementById(id);
const UI = {
shell: $('detQuiz'),
flow: $('detGivenQ'), // Q (m³/day)
area: $('detGivenV'), // V (m³) — we reuse "area" slot name from SOR
opts: $('detOptions'),
fb: $('detFeedback'),
next: $('detNext'),
score: $('detScore')
};
const Q_TOTAL = 5;
let qIndex = 0, score = 0, locked = false, correctT = null;
let easyAutoAdvance = null;
function renderScore(){
if (UI.score) UI.score.textContent = `Score: ${score}`;
}
function randBetween(min,max,step){
const n = Math.floor((max-min)/step);
const k = Math.floor(Math.random()*(n+1));
const dp = (step.toString().split('.')[1]||'').length;
return +(min + k*step).toFixed(dp);
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } return a; }
// Build a tidy question (like SOR’s makeQuestion)
// t = 24*V/Q ; we choose a neat target t and V, then derive Q and recompute exact t from shown V,Q
function makeQuestion(){
const tTarget = randBetween(1.0, 8.0, 0.5); // hours
const V = randBetween(500, 6000, 50); // m³
const Qday = Math.max(50, Math.round((24*V/tTarget)/10)*10); // rounded m³/day
const tExact = +((24*V)/Qday).toFixed(2); // what user must pick
// keep within sensible bounds; if not, draw again
if (tExact < 0.25 || tExact > 12) return makeQuestion();
return { flow: Qday, vol: V, t: tExact };
}
function buildOptions(correct){
const set = new Set([correct]);
const bumps = [-0.25,-0.15,-0.1,+0.10,+0.15,+0.25];
for (const b of bumps){
if (set.size >= 3) break;
let v = +(correct * (1+b)).toFixed(2);
v = Math.min(12, Math.max(0.25, v));
set.add(v);
}
while (set.size < 3) set.add(randBetween(0.5, 8.0, 0.01));
return shuffle([...set]);
}
function renderQuestion(){
qIndex++; locked = false; correctT = null;
if (UI.next) UI.next.disabled = true;
if (UI.fb) UI.fb.textContent = '';
const q = makeQuestion();
correctT = q.t;
if (UI.flow) UI.flow.textContent = q.flow.toLocaleString();
if (UI.area) UI.area.textContent = q.vol.toLocaleString();
UI.opts.innerHTML = '';
buildOptions(q.t).forEach(v=>{
const btn = document.createElement('button');
btn.className = 'sor-opt';
btn.textContent = `${v} h`;
btn.addEventListener('click', () => onPick(v, btn));
UI.opts.appendChild(btn);
});
if (UI.next) UI.next.textContent = (qIndex === Q_TOTAL) ? 'Finish' : 'Next';
}
function onPick(value, btn){
if (locked) return;
locked = true;
if (easyAutoAdvance){ clearTimeout(easyAutoAdvance); easyAutoAdvance = null; }
// disable all options
[...UI.opts.children].forEach(b => b.disabled = true);
if (+value === +correctT){
btn.classList.add('correct');
if (UI.fb) UI.fb.textContent = 'Correct!';
score += 2;
} else {
btn.classList.add('wrong');
const good = [...UI.opts.children]
.find(b => +b.textContent.replace(/[^\d.]/g,'') === +correctT);
good?.classList.add('correct');
if (UI.fb) UI.fb.textContent = `Answer: ${correctT} h`;
}
renderScore();
// Auto-advance after brief pause
easyAutoAdvance = setTimeout(() => {
easyAutoAdvance = null;
nextStep();
}, 900);
}
function nextStep(){
if (qIndex >= Q_TOTAL){
if (UI.fb) UI.fb.innerHTML = `You scored <strong>${score}</strong> / ${Q_TOTAL*2} points.`;
if (UI.next) UI.next.disabled = true;
// hand off to Detention 60-sec start overlay (same idea as sorQuizDone)
// Optionally set a gate flag if your 60s script checks it
window.__det60Eligible = (score >= 10);
document.dispatchEvent(new CustomEvent('detEasyDone'));
return;
}
renderQuestion();
}
function initQuiz(){
qIndex = 0; score = 0; locked = false;
// hide & inert the Next button (no HTML/CSS edits needed)
if (UI.next){
UI.next.style.display = 'none';
UI.next.setAttribute('aria-hidden','true');
UI.next.disabled = true;
UI.next.onclick = null;
}
renderScore();
renderQuestion();
}
// Start when user picks Detention in the topic overlay
document.addEventListener('click', (e) => {
const btn = e.target.closest('#topicDetBtn');
if (!btn) return;
e.preventDefault();
const overlay = document.getElementById('easyTopicOverlay');
if (overlay) overlay.style.display = 'none';
typeof show === 'function' ? show(UI.shell, 'grid') : (UI.shell.style.display='grid');
initQuiz();
});
// Optional public starter (like startSorEasy)
window.startDetEasy = () => {
typeof show === 'function' ? show(UI.shell, 'grid') : (UI.shell.style.display='grid');
initQuiz();
};
})();
/* ==========================================
DETENTION TIME — 60s CHALLENGE (Part 2)
Clone of SOR 60s engine; t = 24*V/Q
IDs expected:
Start overlay: #det60StartOverlay, #det60StartBtn
Quiz board: #det60Quiz
HUD: #det60Score, #det60Timer
givens: #det60Q (m³/day), #det60V (m³)
options: #det60Options
feedback: #det60Feedback
Results overlay: #det60ResultOverlay
fields: #det60ResultTitle, #det60ResultMsg,
#det60FinalScore, #det60BestScore
buttons: #det60RetryBtn, #det60RestartBtn, #det60NextBtn
========================================== */
(function(){
const $ = (id) => document.getElementById(id);
// ---------- UI refs ----------
const UI = {
shell: $('det60Quiz'),
q: $('det60Q'),
v: $('det60V'),
opts: $('det60Options'),
fb: $('det60Feedback'),
scoreEl: $('det60Score'),
timerEl: $('det60Timer'),
};
// ---------- State ----------
let bestScore = Number(localStorage.getItem('det60Best') || 0);
let roundScore = 0;
let timeLeft = 60;
let timerId = null;
let locked = false;
let correctCat = null;
// Recommended detention band for the challenge (adjust if you like)
const DET_MIN = 2.0; // hours
const DET_MAX = 4.0; // hours
// ---------- Helpers ----------
function randBetween(min,max,step){
const n = Math.floor((max-min)/step);
const k = Math.floor(Math.random()*(n+1));
const dp = (step.toString().split('.')[1]||'').length;
return +(min + k*step).toFixed(dp);
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [a[i],a[j]]=[a[j],a[i]]; } return a; }
function updateHUD(){
if (UI.scoreEl) UI.scoreEl.textContent = `Score: ${roundScore.toFixed(2)}`;
if (UI.timerEl) UI.timerEl.textContent = `${Math.max(0,timeLeft)}s`;
// mirror if other parts peek at it
window.det60Score = roundScore;
}
function stopTimer(){ if (timerId){ clearInterval(timerId); timerId = null; } }
function startTimer(){
stopTimer();
updateHUD();
timerId = setInterval(()=>{
timeLeft--;
updateHUD();
if (timeLeft <= 0){
stopTimer();
endRound();
}
}, 1000);
}
// ---------- Question generation ----------
// Build a question using tidy numbers:
// choose target t (0.8–6.5 h), volume V (m³), derive Q (m³/d), then recompute t = 24V/Q
function makeQuestion(){
const V = randBetween(400, 6000, 10); // m³
const tTarget = randBetween(0.8, 6.5, 0.1); // hours
const Q = Math.max(50, Math.round((24*V/tTarget)/10)*10); // m³/day
const t = +((24*V)/Q).toFixed(2); // exact from displayed V,Q
const category = (t < DET_MIN) ? 'Below Range'
: (t > DET_MAX) ? 'Above Range'
: 'Within Range';
return { Q, V, t, category };
}
function buildOptions(correctCategory){
const OPTS = [
{ key:'Within Range', t:'Within Range', s:`t: ${DET_MIN}–${DET_MAX} h` },
{ key:'Below Range', t:'Below Range', s:`t < ${DET_MIN} h` },
{ key:'Above Range', t:'Above Range', s:`t > ${DET_MAX} h` },
];
// mark which is correct, then shuffle for display
return shuffle(OPTS.map(o => ({...o, isCorrect: o.key === correctCategory})));
}
// ---------- Render / Interactions ----------
function renderQuestion(){
if (timeLeft <= 0) return;
locked = false; correctCat = null;
if (UI.fb) UI.fb.textContent = '';
const q = makeQuestion();
correctCat = q.category;
if (UI.q) UI.q.textContent = q.Q.toLocaleString();
if (UI.v) UI.v.textContent = q.V.toLocaleString();
UI.opts.innerHTML = '';
buildOptions(correctCat).forEach(opt=>{
const btn = document.createElement('button');
btn.className = 'sor-opt';
btn.innerHTML = `<span class="t">${opt.t}</span><span class="s">${opt.s}</span>`;
btn.addEventListener('click', ()=> onPick(opt, btn));
UI.opts.appendChild(btn);
});
}
function onPick(opt, btn){
if (locked || timeLeft <= 0) return;
locked = true;
[...UI.opts.children].forEach(b=>b.disabled=true);
if (opt.isCorrect){
btn.classList.add('correct');
if (UI.fb) UI.fb.textContent = 'Correct!';
roundScore += 2; // +2 points
} else {
btn.classList.add('wrong');
const good = [...UI.opts.children]
.find(b => b.querySelector('.t').textContent === correctCat);
good?.classList.add('correct');
if (UI.fb) UI.fb.textContent = `Answer: ${correctCat}`;
roundScore -= 0.05; // small penalty, like SOR
if (roundScore < 0) roundScore = 0;
}
updateHUD();
// Auto-advance after a short pause
setTimeout(()=>{ if (timeLeft > 0) renderQuestion(); }, 700);
}
// ---------- Round control ----------
function startFreshRound(){
roundScore = 0;
timeLeft = 60;
locked = false;
if (UI.fb) UI.fb.textContent = '';
UI.opts.innerHTML = '';
updateHUD();
renderQuestion();
startTimer();
}
// expose restart globally
window.startFreshRoundDet60 = startFreshRound;
function initDet60(){
startFreshRound();
}
// ---------- Results overlay ----------
function endRound(){
// update personal best
if (roundScore > bestScore){
bestScore = roundScore;
localStorage.setItem('det60Best', String(bestScore));
}
// freeze any visible options
[...UI.opts.children].forEach(b=>b.disabled = true);
const ov = $('det60ResultOverlay');
const ttl = $('det60ResultTitle');
const msg = $('det60ResultMsg');
const fsc = $('det60FinalScore');
const bsc = $('det60BestScore');
const btnRetry = $('det60RetryBtn');
const btnRestart = $('det60RestartBtn');
const btnNext = $('det60NextBtn');
if (fsc) fsc.textContent = roundScore.toFixed(2);
if (bsc) bsc.textContent = bestScore.toFixed(2);
if (btnRetry) btnRetry.style.display = 'none';
if (btnRestart) btnRestart.style.display = 'none';
if (btnNext) btnNext.style.display = 'none';
if (roundScore === 0){
if (ttl) ttl.textContent = "Let's try again";
if (msg) msg.textContent = "You scored 0 points. Click Restart to try a fresh 60-second round.";
if (btnRestart) btnRestart.style.display = 'inline-block';
} else if (roundScore >= 10){
if (ttl) ttl.textContent = "Great job!";
if (msg) msg.textContent = "You reached the minimum score. You can go to the next level, or restart to improve your best.";
if (btnNext) btnNext.style.display = 'inline-block';
if (btnRestart) btnRestart.style.display = 'inline-block';
} else {
if (ttl) ttl.textContent = "Keep going";
if (msg) msg.textContent = "Minimum score of 10 is needed to go to the next level. You can continue now and make up points later.";
if (btnRetry) btnRetry.style.display = 'inline-block';
if (btnNext) btnNext.style.display = 'inline-block';
}
if (ov) ov.style.display = 'flex';
}
// ---------- Overlay openers (Start) ----------
window.showDet60Overlay = function(){
const ov = $('det60StartOverlay');
if (ov) ov.style.display = 'flex';
};
window.startDet60Quiz = function(){
const ov = $('det60StartOverlay');
if (ov) ov.style.display = 'none';
const card = $('det60Quiz');
if (card){ card.classList.remove('qs-hide'); card.style.display = 'block'; }
initDet60();
};
// Start Part-2 when Easy signals it’s done (same as SOR)
document.addEventListener('detEasyDone', () => {
const q1 = $('detQuiz');
if (q1){ q1.classList.add('qs-hide'); q1.style.display='none'; }
// Only show if you gate with a flag; remove if not using a gate
if (window.__det60Eligible === undefined || window.__det60Eligible) {
window.showDet60Overlay();
}
});
// Wire overlay "Start" button
$('det60StartBtn')?.addEventListener('click', () => window.startDet60Quiz());
// Results overlay buttons (single, reliable wiring)
document.addEventListener('click', (e) => {
const t = e.target; if (!t) return;
if (t.id === 'det60RetryBtn'){ // Re-try => new 60s round
$('det60ResultOverlay').style.display = 'none';
window.startFreshRoundDet60?.();
}
if (t.id === 'det60RestartBtn'){ // Restart => new 60s round
$('det60ResultOverlay').style.display = 'none';
window.startFreshRoundDet60?.();
}
if (t.id === 'det60NextBtn'){ // Next => hand off to next level/section
$('det60ResultOverlay').style.display = 'none';
document.dispatchEvent(new CustomEvent('det60Done', {
detail: { score: roundScore, best: bestScore }
}));
}
});
//========= Optional global opener for testing====OPTIONAL======
window.openDet60 = function({ skipOverlay = false } = {}){
// close other overlays you might have (optional)
// document.getElementById('easyTopicOverlay')?.style && (document.getElementById('easyTopicOverlay').style.display = 'none');
if (skipOverlay) window.startDet60Quiz();
else window.showDet60Overlay();
};
})();
/* ================== DETENTION TIME — 90s PER QUESTION (replica of SOR 90s) ================== */
(function(){
const $ = (id) => document.getElementById(id);
// ---------- UI ----------
const UI = {
section: $('det90Section'),
overlay: $('det90StartOverlay'),
startBtn: $('det90StartBtn'),
board: $('det90Quiz'),
stem: $('det90Stem'),
given: $('det90Given'),
opts: $('det90Options'),
fb: $('det90Feedback'),
hint: $('det90Hint'),
next: $('det90Next'),
timerEl: $('det90Timer'),
scoreEl: $('det90Score'),
// results overlay
resOv: $('det90ResultOverlay'),
resTitle: $('det90ResultTitle'),
resMsg: $('det90ResultMsg'),
resFinal: $('det90FinalScore'),
resBest: $('det90BestScore'),
restart: $('det90RestartBtn'),
toNext: $('det90NextBtn'),
back2: $('det90BackBtn'),
};
// ---------- Config ----------
const PER_Q_SECS = 90;
const POINT_CORRECT = 2.0;
const HINT_PENALTY = 0.5;
const NUM_QUESTIONS = 20;
// ---------- State ----------
let questions = [], order = [], i = 0;
let score = 0, usedHint = false;
let tick = null, left = PER_Q_SECS;
// ---------- Helpers ----------
const fmt = (n, dp=0) => Number(n).toLocaleString(undefined, { maximumFractionDigits: dp });
const round1 = (x) => Math.round(x*10)/10;
const round2 = (x) => Math.round(x*100)/100;
const mmss = s => `${String(Math.floor(s/60)).padStart(2,'0')}:${String(s%60).padStart(2,'0')}`;
const shuffle = a => { for (let k=a.length-1;k>0;k--){ const j=(Math.random()*(k+1))|0; [a[k],a[j]]=[a[j],a[k]]; } return a; };
const pick = (arr) => arr[(Math.random()*arr.length)|0];
function stopTimer(){ clearInterval(tick); tick = null; }
function startTimer(){
stopTimer();
left = PER_Q_SECS;
UI.timerEl.textContent = mmss(left);
tick = setInterval(()=>{
left -= 1;
UI.timerEl.textContent = mmss(Math.max(0,left));
if (left <= 0) onTimeUp();
}, 1000);
}
function renderScore(){ UI.scoreEl.textContent = `Score: ${score.toFixed(1)}`; }
/* =========================================================
QUESTION FACTORIES (Q1, Q2, Q6, Q7, Q8)
========================================================= */
// Q1 — t = 24·H / SOR (Q cancels). Use tidy combos.
function q1_detFromSORDepth(){
const combos = [
{Q:14400, SOR:24, H:3.0},
{Q:18000, SOR:30, H:3.0},
{Q:12000, SOR:20, H:2.5},
{Q:15000, SOR:25, H:3.0},
];
const c = pick(combos);
const t = round1(24*c.H/c.SOR);
const opts = shuffle([t, round1(t*0.8), round1(t*1.2), round1(t+0.5)]);
return {
stem: "A primary clarifier treats Q at design SOR with depth H. What is the detention time?",
given: `Q = <strong>${fmt(c.Q)}</strong> m³/d; SOR = <strong>${c.SOR}</strong> m³/m²·d; H = <strong>${c.H.toFixed(1)}</strong> m.`,
options: opts.map(x => `${x.toFixed(1)} h`),
correct: opts.indexOf(t),
hint: "t = 24·V/Q = 24·(A·H)/Q; with SOR = Q/A ⇒ t = 24·H/SOR."
};
}
// Q2 — three circular tanks; one OOS (two online)
function q2_threeCircular_twoOnline(){
const D = pick([22,24,26]);
const H = 3.0;
const Q = pick([24000,27000,30000]);
const N = 2;
const A = Math.PI * D*D / 4;
const V = A * H;
const Qt = Q / N;
const t = round2(24*V/Qt);
const opts = shuffle([t, round2(t*0.85), round2(t*1.15), round2(t+0.3)]);
return {
stem: "Three identical circular primaries (one out of service). Per-tank detention time?",
given: `D = <strong>${D}</strong> m; H = <strong>${H.toFixed(1)}</strong> m; Q = <strong>${fmt(Q)}</strong> m³/d; Online tanks = <strong>2</strong>.`,
options: opts.map(x => `${x.toFixed(2)} h`),
correct: opts.indexOf(t),
hint: "Per tank Q = Q_total/N; V = (πD²/4)·H; t = 24·V / (Q/N)."
};
}
// Q6 — min N so t ≥ 2 h (V per tank, Qpeak)
function q6_minTanks_for_t2(){
const V = pick([1000,1200,1500]);
const Qp = pick([28800,32400,36000]);
const tReq = 2.0;
const Ncalc = (Qp * tReq) / (24 * V);
const N = Math.max(1, Math.ceil(Ncalc));
const opts = shuffle([N, Math.max(1,N-1), N+1, Math.max(1,N+2)]).slice(0,4);
return {
stem: "Each primary tank has volume V. At peak Q, how many tanks are needed so t ≥ 2 h?",
given: `V = <strong>${fmt(V)}</strong> m³/tank; Q<sub>peak</sub> = <strong>${fmt(Qp)}</strong> m³/d.`,
options: opts.map(n => `${n} tank${n>1?'s':''}`),
correct: opts.indexOf(N),
hint: "t = 24·(N·V)/Q ⇒ N ≥ (Q·t)/(24·V)."
};
}
// Q7 — design comparison (per-tank detention time)
function q7_designCompare(){
const Q = 12000;
const A1 = 600, H1 = 2.5, N1 = 1;
const A2 = 350, H2 = 2.0, N2 = 2;
const tA = 24*(A1*H1) / (Q/N1);
const tB = 24*(A2*H2) / (Q/N2);
const key = (Math.abs(tA - tB) < 1e-6) ? 'Same' : (tA > tB ? 'A' : 'B');
const options = ['A','B','Same','Need WOR data'];
return {
stem: "Two SOR-compliant designs. Which has higher per-tank detention time?",
given: `Q = <strong>${fmt(Q)}</strong> m³/d.<br>
A: 1 clarifier, A<sub>s</sub> = <strong>${A1}</strong> m², H = <strong>${H1}</strong> m.<br>
B: 2 clarifiers, each A<sub>s</sub> = <strong>${A2}</strong> m², H = <strong>${H2}</strong> m.`,
options,
correct: options.indexOf(key),
hint: "t = 24·(A·H)/(Q/N). Compare A vs B."
};
}
// Q8 — min D with t ≥ 2.5 h AND WOR ≤ 160
function q8_minDiameter_dualCriteria(){
const H = 3.0, Q = 12000, tMin = 2.5, WORmax = 160;
const Ds = [22,23,24,25];
function ok(D){
const A = Math.PI*D*D/4, V = A*H, L = Math.PI*D;
const t = 24*V/Q, WOR = Q/L;
return t >= tMin - 1e-9 && WOR <= WORmax + 1e-9;
}
let ans = Ds.find(ok) ?? Ds[Ds.length-1];
return {
stem: "Circular clarifier must satisfy t ≥ 2.5 h and WOR ≤ 160 m³/(m·d). Minimum diameter?",
given: `H = <strong>${H.toFixed(1)}</strong> m; Q = <strong>${fmt(Q)}</strong> m³/d.`,
options: Ds.map(d => `${d} m`),
correct: Ds.indexOf(ans),
hint: "Check both t and WOR for each D; choose the smallest that passes both."
};
}
function buildSet(N = NUM_QUESTIONS){
const factories = [q1_detFromSORDepth, q2_threeCircular_twoOnline, q6_minTanks_for_t2, q7_designCompare, q8_minDiameter_dualCriteria];
const out = [];
for (let k=0;k<N;k++) out.push(factories[k % factories.length]());
return shuffle(out);
}
// ---------- Render / flow ----------
function renderQuestion(){
const q = questions[order[i]];
if (!q) return endQuiz();
UI.board?.classList.remove('sor-locked');
UI.fb.textContent = '';
UI.hint.classList.remove('used');
UI.next.disabled = true;
usedHint = false;
UI.stem.innerHTML = q.stem;
UI.given.innerHTML = q.given;
UI.opts.innerHTML = '';
q.options.forEach((t, idx) => {
const btn = document.createElement('button');
btn.className = 'sor-opt';
btn.innerHTML = t;
btn.addEventListener('click', () => onPick(q, idx, btn));
UI.opts.appendChild(btn);
});
UI.hint.onclick = () => {
if (UI.hint.classList.contains('used')) return;
usedHint = true;
UI.hint.classList.add('used');
UI.fb.innerHTML = q.hint || 'Use t = 24·V/Q and per-tank flow when multiple tanks are online.';
};
renderScore();
startTimer();
}
function onPick(q, idx, btn){
stopTimer();
const kids = [...UI.opts.children];
kids.forEach(b=>b.disabled=true);
if (idx === q.correct){
btn.classList.add('correct');
score += usedHint ? (POINT_CORRECT - HINT_PENALTY) : POINT_CORRECT;
if (score < 0) score = 0;
UI.fb.innerHTML = `Correct!`;
} else {
btn.classList.add('wrong');
kids[q.correct]?.classList.add('correct');
UI.fb.innerHTML = `Wrong.`;
}
renderScore();
setTimeout(next, 900);
}
function onTimeUp(){
stopTimer();
UI.board?.classList.add('sor-locked');
const kids = [...UI.opts.children];
kids.forEach(b=>b.disabled=true);
const q = questions[order[i]];
if (q && kids[q.correct]) kids[q.correct].classList.add('correct');
UI.fb.innerHTML = `Time’s up!`;
setTimeout(next, 900);
}
function next(){
i++;
if (i >= order.length) return endQuiz();
renderQuestion();
}
function endQuiz(){
stopTimer();
const maxPts = order.length * POINT_CORRECT;
const passMark = 0.9 * maxPts;
const passed = score >= passMark;
UI.resTitle.textContent = passed ? "Well done — Passed!" : "Session Complete";
UI.resMsg.innerHTML =
`Final Score: <strong>${score.toFixed(1)}</strong> / ${maxPts.toFixed(1)}<br>` +
`Required to pass: <strong>${passMark.toFixed(1)}</strong> (90%)`;
// personal best
const key = 'det90Best';
let best = Number(localStorage.getItem(key) || 0);
if (score > best){ best = score; localStorage.setItem(key, String(best)); }
UI.resFinal.textContent = score.toFixed(1);
UI.resBest.textContent = best.toFixed(1);
UI.resOv.style.display = 'flex';
}
function start(){
stopTimer();
questions = buildSet(NUM_QUESTIONS);
order = shuffle([...Array(questions.length).keys()]);
i = 0; score = 0; usedHint = false;
UI.board?.classList.remove('qs-hide'); UI.board.style.removeProperty('display');
renderQuestion();
}
// ---------- wiring ----------
UI.startBtn?.addEventListener('click', () => {
UI.overlay.style.display = 'none';
start();
});
UI.next?.addEventListener('click', next);
UI.restart?.addEventListener('click', () => { UI.resOv.style.display = 'none'; start(); });
UI.toNext?.addEventListener('click', () => {
UI.resOv.style.display = 'none';
const inter = $('intermediateSection');
const ov = $('interStartOverlay');
if (inter){ inter.classList.remove('qs-hide'); inter.style.display = 'block'; }
if (ov){ ov.style.display = 'flex'; }
UI.section.classList.add('qs-hide'); UI.section.style.display = 'none';
document.dispatchEvent(new CustomEvent('det90Done', { detail: { score } }));
});
UI.back2?.addEventListener('click', () => {
UI.resOv.style.display = 'none';
UI.section.classList.add('qs-hide'); UI.section.style.display = 'none';
const topic = $('easyTopicOverlay'); if (topic) topic.style.display = 'flex';
});
// Wire Det-60 → Det-90 (overlay Next)
document.getElementById('det60NextBtn')?.addEventListener('click', () => {
document.getElementById('det60ResultOverlay')?.style && (document.getElementById('det60ResultOverlay').style.display = 'none');
window.showDet90Overlay();
});
})();
// ---------- ONE-TIME UTILITIES ----------
function hideById(id){
const el = document.getElementById(id);
if (!el) return;
el.classList.add('qs-hide');
el.style.display = 'none';
}
function hideOverlays(){
document.querySelectorAll(
'#rangeStartOverlay,#rangeResultOverlay,' +
'#det60StartOverlay,#det60ResultOverlay,' +
'#det90StartOverlay,#det90ResultOverlay,' +
'#weir60StartOverlay,#weir60ResultOverlay,' +
'#weir90StartOverlay,#weir90ResultOverlay,' +
'#sorOnlyStartOverlay,#sorOnlyResultOverlay'
).forEach(el => el.style.display = 'none');
}
function hideAllPlayAreas(){
[
'sorQuiz','sorRangeQuiz',
'weirQuiz','weir60','weir90Quiz',
'detQuiz','det60Quiz','det90Quiz',
'easyChallenge'
].forEach(hideById);
hideOverlays();
}
// ---------- MAKE DET-90 OPEN CLEANLY ----------
window.showDet90Overlay = function(){
hideAllPlayAreas(); // ← ensure nothing else is visible
const sec = document.getElementById('det90Section');
const ov = document.getElementById('det90StartOverlay');
if (sec){ sec.classList.remove('qs-hide'); sec.style.removeProperty('display'); }
if (ov) ov.style.display = 'flex';
};
// Det-90 Start: hide everything, then show the 90s board
document.getElementById('det90StartBtn')?.addEventListener('click', () => {
hideAllPlayAreas(); // <- important
const ov = document.getElementById('det90StartOverlay');
const quiz = document.getElementById('det90Quiz');
if (ov) ov.style.display = 'none';
if (quiz){ quiz.classList.remove('qs-hide'); quiz.style.removeProperty('display'); }
// start your 90s logic here if needed (e.g., window.det90?.start?.());
});
// Det-60 result → Det-90 start overlay (clean)
document.getElementById('det60NextBtn')?.addEventListener('click', () => {
hideAllPlayAreas(); // <- ensure 60s board is gone
window.showDet90Overlay(); // shows the 90s start overlay
});
// Detention 90 → Intermediate (Result overlay "Next")
(function () {
const $ = (id) => document.getElementById(id);
function goIntermediate(){
// If you use a router, prefer it
if (window.AppRouter?.go) { AppRouter.go('intermediate'); return; }
// Hide Det-90 overlay + section
const ov = $('det90ResultOverlay');
if (ov) ov.style.display = 'none';
const detSec = $('det90Section');
if (detSec){ detSec.classList.add('qs-hide'); detSec.style.display = 'none'; }
// Show Intermediate section + its start overlay
const inter = $('intermediateSection');
const interOv = $('interStartOverlay');
if (inter){ inter.classList.remove('qs-hide'); inter.style.display = 'block'; }
if (interOv){ interOv.style.display = 'flex'; }
// Optional body mode + signal
document.body.classList.remove('easy-mode','soronly-mode','final-mode');
document.body.classList.add('intermediate-mode');
document.dispatchEvent(new CustomEvent('det90:next', { detail:{ from:'det90' } }));
}
$('det90NextBtn')?.addEventListener('click', goIntermediate);
// accessibility: Enter key while overlay focused
$('det90ResultOverlay')?.addEventListener('keydown', (e)=>{ if (e.key === 'Enter') goIntermediate(); });
})();
// ---------- MAKE WEIR-90 OPEN CLEANLY ----------
window.showWeir90Overlay = function () {
// ensure nothing else is visible (hides 60s etc.)
hideAllPlayAreas();
const sec = document.getElementById('weir90Section');
const ov = document.getElementById('weir90StartOverlay');
if (sec){ sec.classList.remove('qs-hide'); sec.style.removeProperty('display'); }
if (ov) ov.style.display = 'flex';
};
// Weir-90 Start: hide everything, then show the 90s board
document.getElementById('weir90StartBtn')?.addEventListener('click', () => {
hideAllPlayAreas();
const ov = document.getElementById('weir90StartOverlay');
const quiz = document.getElementById('weir90Quiz');
if (ov) ov.style.display = 'none';
if (quiz){ quiz.classList.remove('qs-hide'); quiz.style.removeProperty('display'); }
// window.weir90?.start?.(); // (only if you have a start function)
});
// Weir-60 result → Weir-90 start overlay (clean handoff)
document.getElementById('weir60NextBtn')?.addEventListener('click', () => {
hideAllPlayAreas();
window.showWeir90Overlay();
});
// (optional console helper)
window.openWeir90 = () => window.showWeir90Overlay();
/* ---------- FINAL welcome + preview (Step 4) ---------- */
(function(){
const $ = (id) => document.getElementById(id);
// --- Welcome (unchanged) ---
function showWelcome(){
const w = $('finalWelcomeOverlay');
if (w) w.style.display = 'flex';
sessionStorage.setItem('finalWelcomeShown','1');
}
function hideWelcome(){
const w = $('finalWelcomeOverlay');
if (w) w.style.display = 'none';
}
// --- Overall progress (non-invasive) ---
function computeOverall(){
let sum = 0, count = 0;
for (let i = 0; i < localStorage.length; i++){
const k = localStorage.key(i);
if (/Best$/.test(k)){
const v = parseFloat(localStorage.getItem(k));
if (!isNaN(v)) { sum += v; count++; }
}
}
const percent = count ? Math.round(sum / count) : 0;
return { points: Math.round(sum), percent };
}
// --- Helpers to (un)lock Final tiles during preview ---
function allFinalCTAs(){
const finalRoot = document.getElementById('final') || document;
return Array.from(finalRoot.querySelectorAll('[id^="cta"]'));
}
function lockOtherFinalCTAs(keepId){
allFinalCTAs().forEach(el => {
if (keepId && el.id === keepId) return;
el.classList.add('locked');
el.setAttribute('aria-disabled','true');
el.setAttribute('tabindex','-1');
if (!el.getAttribute('title')){
el.setAttribute('title','Locked in preview. Reach 95% overall to unlock full access.');
}
});
}
function clearFinalLocks(){
allFinalCTAs().forEach(el => {
el.classList.remove('locked');
el.removeAttribute('aria-disabled');
if (el.getAttribute('tabindex') === '-1') el.removeAttribute('tabindex');
});
sessionStorage.removeItem('__finalPreviewChosen');
}
// --- Preview overlay (now cleans locks when shown) ---
function showFinalPreview(opts = {}){
const {points, percent} = computeOverall();
const withTry = opts.withTry ?? (sessionStorage.getItem('__finalPreviewUsed') !== '1');
// Whenever we re-show overlay, clear any leftover locks
clearFinalLocks();
const ov = $('finalPreviewOverlay');
if (ov){
$('finalPreviewPoints').textContent = points;
$('finalPreviewPercent').textContent = percent + '%';
const tryBtn = $('finalPreviewTry');
if (tryBtn) tryBtn.style.display = withTry ? 'inline-block' : 'none';
ov.style.display = 'flex';
}
}
function hideFinalPreview(){
const ov = $('finalPreviewOverlay');
if (ov) ov.style.display = 'none';
}
// --- One-activity guard in limited preview (counts first pane action, not global Submit) ---
function consumeLimitedPreview(){
if (window.__finalPreviewConsumed) return;
window.__finalPreviewConsumed = true;
document.removeEventListener('click', previewClickHandler, true);
document.removeEventListener('keydown', previewKeyHandler, true);
if (window.__finalPreviewObserver){
window.__finalPreviewObserver.disconnect();
window.__finalPreviewObserver = null;
}
sessionStorage.setItem('__finalPreviewUsed','1');
setTimeout(() => { showFinalPreview({ withTry:false }); }, 800);
}
function isGlobalSubmitOrToolbar(el){
if (!el) return false;
// Exclude global toolbar region (adjust selectors if your toolbar id differs)
const toolbar = el.closest('#finalToolbar, #toolbar');
if (toolbar) return true;
// direct id/data-action checks for global buttons
const id = (el.id || '').toLowerCase();
const act = (el.getAttribute && (el.getAttribute('data-action')||'').toLowerCase()) || '';
if (/(^|#)btnsubmit|btn-new|btnreset|submitcheck|submit&_?check/.test('#'+id)) return true;
if (/^(submit|final|overall)$/.test(act)) return true;
// label heuristics
const label = (el.innerText || el.value || '').toLowerCase();
if (/submit\s*&?\s*check|final\s*submit|overall\s*check/.test(label)) return true;
return false;
}
function previewClickHandler(e){
if (location.hash !== '#final' || !document.body.classList.contains('final-limited')) return;
// Only count actions inside the Final work area
const wrap = document.getElementById('gameWrap');
if (!wrap || !wrap.contains(e.target)) return;
// Ignore clicks on starting-point tiles
if (e.target.closest('[id^="cta"]')) return;
// Treat typical action controls inside a pane as "one activity"
const ctrl = e.target.closest(
'button,[role="button"],input[type="button"],input[type="submit"],' +
'.btn,.button,[class*="btn"],[class*="Button"],[class*="apply"],[class*="calc"],[class*="check"],[class*="validate"],' +
'[id*="apply"],[id*="calc"],[id*="check"],[id*="validate"]'
);
if (!ctrl) return;
// Do not count the global toolbar/submit
if (isGlobalSubmitOrToolbar(ctrl)) return;
// First activity inside the pane → consume preview
consumeLimitedPreview();
}
function previewKeyHandler(e){
if (location.hash !== '#final' || !document.body.classList.contains('final-limited')) return;
// Enter often triggers a local action; ignore if it's the global submit/toolbar
if (e.key === 'Enter'){
const btn = e.target?.closest('button,[role="button"],input[type="submit"],input[type="button"]');
if (isGlobalSubmitOrToolbar(btn)) return;
consumeLimitedPreview();
}
}
function armLimitedPreviewOnce(){
if (window.__finalPreviewArmed) return;
window.__finalPreviewArmed = true;
window.__finalPreviewConsumed = false;
// Catch first pane activity
document.addEventListener('click', previewClickHandler, true);
document.addEventListener('keydown', previewKeyHandler, true);
// Safety net: watch for feedback text changes after an action
const wrap = document.getElementById('gameWrap');
if (wrap && !window.__finalPreviewObserver){
window.__finalPreviewObserver = new MutationObserver((muts) => {
if (!document.body.classList.contains('final-limited') || window.__finalPreviewConsumed) return;
for (const m of muts){
const text = (m.target.textContent || '').toLowerCase();
if (/criteria|meets|does not meet|ok|update|applied|calculated|units|range|invalid|error|warning|note|feedback/.test(text)){
consumeLimitedPreview();
break;
}
}
});
window.__finalPreviewObserver.observe(wrap, { childList:true, subtree:true, characterData:true });
}
}
// --- "Choose exactly one starting point" during preview ---
function armFinalChoiceOnce(){
if (window.__finalChoiceArmed) return;
window.__finalChoiceArmed = true;
document.addEventListener('click', finalChoiceHandler, true);
}
function finalChoiceHandler(e){
if (location.hash !== '#final' || !document.body.classList.contains('final-limited')) return;
// Only care about Final CTAs (ids like ctaEasy, ctaXYZ, etc.)
const cta = e.target.closest('[id^="cta"]');
if (!cta) return;
// If already chosen, ignore
if (sessionStorage.getItem('__finalPreviewChosen')) return;
// Record chosen CTA and lock all others
sessionStorage.setItem('__finalPreviewChosen', cta.id);
lockOtherFinalCTAs(cta.id);
// After we decided the first starting point, no need to keep this listener
document.removeEventListener('click', finalChoiceHandler, true);
window.__finalChoiceArmed = false;
}
// --- Unified entry for Final ---
window.openFinal = function({ mode = 'full' } = {}){
const startOv = $('startOverlay');
if (mode === 'preview'){
if (location.hash !== '#final') location.hash = '#final';
$('finalWelcomeOverlay') && ( $('finalWelcomeOverlay').style.display = 'none' );
startOv && ( startOv.style.display = 'none' );
document.body.classList.add('final-limited');
showFinalPreview({ withTry: sessionStorage.getItem('__finalPreviewUsed') !== '1' });
return;
}
if (!sessionStorage.getItem('finalWelcomeShown')){
startOv && ( startOv.style.display = 'none' );
showWelcome();
} else {
startOv && ( startOv.style.display = 'flex' );
}
};
// --- Boot & deep-link handling ---
document.addEventListener('DOMContentLoaded', () => {
if (location.hash === '#final' || $('startOverlay')){
const mode = sessionStorage.getItem('__openFinalMode') || 'full';
sessionStorage.removeItem('__openFinalMode');
window.openFinal({ mode });
}
});
window.addEventListener('hashchange', () => {
if (location.hash === '#final' && sessionStorage.getItem('__openFinalMode')){
const mode = sessionStorage.getItem('__openFinalMode');
sessionStorage.removeItem('__openFinalMode');
window.openFinal({ mode });
}
});
// --- Welcome buttons ---
$('finalProBtn')?.addEventListener('click', () => {
hideWelcome();
$('startOverlay')?.style && ( $('startOverlay').style.display = 'flex' );
});
$('finalBeginBtn')?.addEventListener('click', () => {
hideWelcome();
document.getElementById('ctaEasy')?.click();
if (typeof window.showTopicSelectLayer === 'function'){
setTimeout(window.showTopicSelectLayer, 0);
}
});
// --- Skip button (bottom-right) ---
const __skipBtn = $('skipToFinalBtn');
if (__skipBtn){
__skipBtn.addEventListener('click', () => {
// remember where we came from so "Resume" can return
sessionStorage.setItem('__resumeHash', location.hash || '');
if (location.hash === '#final'){
// already on Final → open preview directly
window.openFinal({ mode: 'preview' });
} else {
// route to Final and hint preview mode
sessionStorage.setItem('__openFinalMode', 'preview');
location.hash = '#final';
setTimeout(() => {
if (location.hash === '#final') window.openFinal({ mode: 'preview' });
}, 60);
}
});
}
// --- Preview overlay buttons ---
$('finalPreviewTry')?.addEventListener('click', () => {
// close overlay + hide the Optional button during preview
hideFinalPreview();
hideSkipToFinal();
// switch to Final mode & reveal board (your pattern)
document.body.classList.remove('easy-mode','intermediate-mode');
document.body.classList.add('final-mode');
hide(document.getElementById('easyChallenge')); // your global hide()
show(document.getElementById('gameWrap')); // your global show()
// make sure the old Final Start overlay isn't on top
const startOv = document.getElementById('startOverlay');
if (startOv) startOv.style.display = 'none';
// reset Final to clean/default state (no parameter panes visible)
if (typeof window.hideOverlays === 'function') window.hideOverlays();
if (typeof window.hideAllPlayAreas === 'function') window.hideAllPlayAreas();
// also hide all form controls explicitly (matches your engine)
document.querySelectorAll('.calc3 .fields .form-ctrl')
.forEach(el => el.classList.add('qs-hide'));
// clear the “Start Here” dropdown
const sel = document.getElementById('startSelect');
if (sel) sel.value = "";
// limited-preview rules: one starting choice + one pane activity
document.body.classList.add('final-limited');
clearFinalLocks();
armFinalChoiceOnce();
armLimitedPreviewOnce();
});
$('finalPreviewResume')?.addEventListener('click', () => {
hideFinalPreview();
document.body.classList.remove('final-limited');
clearFinalLocks();
const back = sessionStorage.getItem('__resumeHash');
if (back) location.hash = back;
});
$('finalPreviewExit')?.addEventListener('click', () => {
hideFinalPreview();
document.body.classList.remove('final-limited');
clearFinalLocks();
location.hash = '#home'; // adjust if your home anchor differs
});
// --- Console helpers for testing ---
window.showFinalWelcome = showWelcome;
window.hideFinalWelcome = hideWelcome;
window.showSkipToFinal = () => { const b = $('skipToFinalBtn'); if (b) b.style.display = 'inline-block'; };
window.hideSkipToFinal = () => { const b = $('skipToFinalBtn'); if (b) b.style.display = 'none'; };
window.finalPreviewForceReturn = () => { sessionStorage.setItem('__finalPreviewUsed','1'); showFinalPreview({ withTry:false }); };
})();
// --- Triggers for "Optional: Skip to Final (limited)" on 90s quizzes (Hint OR 2 wrongs) ---
(function(){
// Adjust selectors only if your IDs differ. These cover common 90s quiz roots.
const NINETY_CONTAINERS = ['#sorOnlyQuiz','#sorOnlySection','#sor90Quiz','#weir90Quiz','#det90Quiz','#sor90','#weir90','#det90'];
const $ = (sel, root=document) => root.querySelector(sel);
const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
const has = (root) => !!root && root.isConnected;
function in90sContainer(node){
return NINETY_CONTAINERS.some(sel => {
const root = $(sel);
return root && (node === root || root.contains(node));
});
}
function showSkip(){
if (typeof window.showSkipToFinal === 'function') window.showSkipToFinal();
}
// 1) HINT trigger — any "Hint" button clicked inside a 90s quiz shows the Optional button
document.addEventListener('click', function(e){
const btn = e.target.closest('button,[role="button"],.btn');
if (!btn) return;
if (!in90sContainer(btn)) return;
const id = (btn.id || '').toLowerCase();
const data = (btn.getAttribute('data-action') || '').toLowerCase();
const text = (btn.innerText || btn.value || '').trim().toLowerCase();
if (id.includes('hint') || data === 'hint' || text === 'hint'){
showSkip();
}
}, true);
// 2) Two-wrongs trigger — after two wrong answers in a 90s quiz, show the Optional button
const wrongCounters = new Map(); // rootEl -> wrongCount
function attachObserver(root){
if (!root || root.__skipObs) return;
wrongCounters.set(root, 0);
const obs = new MutationObserver((muts) => {
if (!has(root)) return;
for (const m of muts){
// Check newly added/changed nodes for "wrong" signals
const nodes = [...(m.addedNodes || [])];
nodes.push(m.target); // also inspect the changed target
for (const node of nodes){
if (!(node instanceof HTMLElement)) continue;
// Heuristics for a wrong answer visual/feedback
let isWrong = false;
// Common class markers
const cls = (node.className || '').toString().toLowerCase();
if (cls.includes('wrong') || cls.includes('incorrect') || cls.includes('is-wrong')) isWrong = true;
// Attributes frequently used by MCQ options
if (!isWrong && node.matches && node.matches('[data-correct="0"]')) isWrong = true;
if (!isWrong && node.querySelector && node.querySelector('[data-correct="0"], .wrong, .incorrect, .is-wrong')) isWrong = true;
// Text feedback patterns (kept conservative)
const txt = (node.innerText || '').toLowerCase();
if (!isWrong && /\b(wrong|incorrect|try again|not correct)\b/.test(txt)) isWrong = true;
if (isWrong){
const n = (wrongCounters.get(root) || 0) + 1;
wrongCounters.set(root, n);
if (n >= 2){
showSkip();
// We can stop watching this quiz instance after triggering once
try { obs.disconnect(); } catch(e){}
root.__skipObs = null;
return;
}
}
}
}
});
obs.observe(root, { subtree:true, childList:true, characterData:true });
root.__skipObs = obs;
}
function scanAndAttach(){
NINETY_CONTAINERS.forEach(sel => {
const root = $(sel);
if (root) attachObserver(root);
});
}
// Attach now, when hash changes (navigation), and after a small delay (lazy renders)
document.addEventListener('DOMContentLoaded', scanAndAttach);
window.addEventListener('hashchange', scanAndAttach);
setTimeout(scanAndAttach, 800);
// Console helpers for testing
window._skip_testShow = showSkip; // force show
window._skip_resetWrongs = () => { wrongCounters.forEach((_,k)=>wrongCounters.set(k,0)); };
})();
// Tag WOR & Det 90s answer options as .opt90 so the CSS above applies only to them
(function colorWorDet90Options(){
const ROOTS = ['#weir90Quiz','#det90Quiz'];
function mark(root){
// Any element that represents an answer option already carries data-correct
root.querySelectorAll('[data-correct]').forEach(el=>{
const btn = el.closest('button,[role="button"],.btn') || el;
btn.classList.add('opt90');
});
}
function attach(selector){
const root = document.querySelector(selector);
if (!root) return;
mark(root);
if (root.__opt90Obs) return;
const obs = new MutationObserver(()=>mark(root));
obs.observe(root, {subtree:true, childList:true});
root.__opt90Obs = obs;
}
function run(){ ROOTS.forEach(attach); }
document.addEventListener('DOMContentLoaded', run);
window.addEventListener('hashchange', run);
setTimeout(run, 500); // catch late renders
})();
// --- Final Result overlay (shown after "Submit & Check") ---
(function(){
const $ = (id) => document.getElementById(id);
function showFinalResult({ passed, fails }){
if ($('finalResultOverlay').style.display !== 'flex'){
$('finalResultOverlay').style.display = 'flex';
}
$('finalResultTitle').textContent = passed ? 'All criteria satisfied' : 'Some criteria need attention';
$('finalResultMsg').textContent = passed
? 'Great job—your design meets the stated criteria.'
: 'These items still need work. Adjust inputs until all turn green:';
// build a short list of failing criteria (if any)
const ul = $('finalResultList');
ul.innerHTML = '';
if (!passed && fails && fails.length){
fails.slice(0,5).forEach(name => {
const li = document.createElement('li');
li.textContent = name;
ul.appendChild(li);
});
}
else {
// keep spacing consistent when there is no list
ul.innerHTML = '';
}
}
function hideFinalResult(){
$('finalResultOverlay').style.display = 'none';
}
// buttons
$('finalResultEditBtn')?.addEventListener('click', hideFinalResult);
$('finalResultReplayBtn')?.addEventListener('click', () => {
hideFinalResult();
// click your existing "New / Replay" (first button on the Final toolbar)
const replay = document.querySelector('#gameWrap button, #btnNew, [data-action="new"]');
replay?.click();
});
// derive pass/fail from the UI (no solver refactor)
function readFinalStatus(){
const $$ = (sel) => Array.from(document.querySelectorAll(sel));
// nodes that explicitly show evaluation state
const badNodes = $$('#gameWrap [data-status="bad"], #gameWrap .bad, #gameWrap .chip--bad');
const hasBad = badNodes.length > 0;
const anyStatus = $$('#gameWrap [data-status], #gameWrap .chip--ok, #gameWrap .chip--bad, #gameWrap .good, #gameWrap .bad').length > 0;
if (!anyStatus){
return { state: 'unready', fails: [] };
}
if (hasBad){
const fails = badNodes
.map(n => (n.getAttribute('data-crit') || n.textContent || '').trim())
.filter(Boolean);
return { state: 'fail', fails };
}
return { state: 'pass', fails: [] };
}
// hook into the Submit & Check button (no refactor; runs after the solver)
const submitBtn = Array.from(document.querySelectorAll('button,[role="button"],input[type="submit"]'))
.find(el => /submit\s*&?\s*check/i.test((el.innerText||el.value||'').trim()));
if (submitBtn){
submitBtn.addEventListener('click', () => {
// don't interfere with the limited-preview flow
if (document.body.classList.contains('final-limited')) return;
// let your existing solver/back-checks run first, then read the DOM result
setTimeout(() => {
const res = readFinalStatus();
// reset the list area
const ul = document.getElementById('finalResultList'); if (ul) ul.innerHTML = '';
if (res.state === 'unready'){
// No greens/reds yet → nothing has been evaluated
document.getElementById('finalResultTitle').textContent = 'Nothing to check yet';
document.getElementById('finalResultMsg').textContent = 'Pick a starting point and enter values, then press “Submit & Check”.';
document.getElementById('finalResultOverlay').style.display = 'flex';
return;
}
if (res.state === 'fail'){
// Show the fail overlay with short list
document.getElementById('finalResultTitle').textContent = 'Some criteria need attention';
document.getElementById('finalResultMsg').textContent = 'These items still need work. Adjust inputs until all turn green:';
res.fails.slice(0,5).forEach(name => {
const li = document.createElement('li'); li.textContent = name; ul.appendChild(li);
});
document.getElementById('finalResultOverlay').style.display = 'flex';
return;
}
// Otherwise: pass
document.getElementById('finalResultTitle').textContent = 'All criteria satisfied';
document.getElementById('finalResultMsg').textContent = 'Great job—your design meets the stated criteria.';
document.getElementById('finalResultOverlay').style.display = 'flex';
}, 0);
});
}
// expose helpers for console testing
window.showFinalResultOverlay = () => { const s = readFinalStatus(); showFinalResult(s); };
window.hideFinalResultOverlay = hideFinalResult;
})();
// Instant tooltip for "Submit & Check"
(function fastSubmitTip(){
const TIP = "Click this only after you’ve entered all values and you’re satisfied with your design.";
function apply(root=document){
const btn = Array.from(root.querySelectorAll('button,[role="button"],input[type="submit"]'))
.find(el => /submit\s*&?\s*check/i.test((el.innerText||el.value||'').trim()));
if (!btn) return;
btn.classList.add('tip-host');
btn.setAttribute('data-tip', TIP); // instant tooltip
btn.setAttribute('aria-label', "Submit & Check — " + TIP); // a11y
btn.removeAttribute('title'); // remove slow native tooltip
}
document.addEventListener('DOMContentLoaded', () => apply());
window.addEventListener('hashchange', () => apply());
setTimeout(() => apply(), 300);
const wrap = document.getElementById('gameWrap');
if (wrap && !wrap.__submitTipObs){
const obs = new MutationObserver(() => apply(wrap));
obs.observe(wrap, { subtree:true, childList:true });
wrap.__submitTipObs = obs;
}
})();

// ---------- Intermediate: "Explore remaining topics" button ----------
(function(){
  const $ = (id) => document.getElementById(id);
  const TOPICS = ['sor','wor','det'];

  function normTopic(str){
    str = (str || '').toLowerCase();
    if (/sor/.test(str)) return 'sor';
    if (/wor|weir/.test(str)) return 'wor';
    if (/det/.test(str)) return 'det';
    return null;
  }

  // 1) Remember what the user picked in "Pick a topic"
  document.addEventListener('click', function(e){
    const pickLayer = $('topicSelectOverlay') || $('topicPicker') || $('pickTopicOverlay') || $('pickTopic');
    if (!pickLayer || pickLayer.offsetParent === null) return; // picker not visible

    const el = e.target.closest('[data-topic], [id^="topic"], button, a');
    if (!el) return;

    let key = el.getAttribute('data-topic') || el.id || el.textContent;
    const chosen = normTopic(key);
    if (!chosen) return;

    sessionStorage.setItem('recentTopic', chosen);
    sessionStorage.setItem('remainingTopics', JSON.stringify(TOPICS.filter(t => t !== chosen)));
  }, true);

  // 2) Label text showing the other two topics
  function labelForRemaining(){
    try {
      const rem = JSON.parse(sessionStorage.getItem('remainingTopics') || '[]');
      if (!rem.length) return 'Explore remaining topics';
      const names = rem.map(t => t === 'sor' ? 'SOR' : (t === 'wor' ? 'WOR' : 'Detention time'));
      return 'Explore remaining topics (' + names.join(', ') + ')';
    } catch(e){
      return 'Explore remaining topics';
    }
  }

  // 3) Inject the button into Intermediate Start overlay when it appears
  function injectBtn(){
    const ov = $('interStartOverlay');
    if (!ov || ov.offsetParent === null) return;

    if (ov.__remBtn){
      ov.__remBtn.textContent = labelForRemaining();
      return;
    }

    let row = ov.querySelector('.overlay-actions, .actions, .btn-row, footer');
    if (!row){
      row = document.createElement('div');
      row.className = 'overlay-actions';
      row.style.cssText = 'display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-top:12px;';
      ov.appendChild(row);
    }

    const btn = document.createElement('button');
    btn.className = 'secondary';       // uses your existing secondary button style
    btn.id = 'interViewRemainingBtn';
    btn.textContent = labelForRemaining();
    btn.addEventListener('click', () => {
      // close Intermediate Start overlay
      ov.style.display = 'none';

      // open Easy area cleanly
      if (typeof hideAllPlayAreas === 'function') hideAllPlayAreas();
      document.body.classList.remove('final-mode','intermediate-mode','soronly-mode');
      document.body.classList.add('easy-mode');

      const easy = $('easyChallenge');
      if (easy){ easy.classList.remove('qs-hide'); easy.style.removeProperty('display'); }

      // open Topic Picker overlay
      const pick = $('topicSelectOverlay') || $('topicPicker') || $('pickTopicOverlay') || $('pickTopic');
      if (pick){ pick.style.display = 'flex'; }
      else if (typeof window.showTopicSelectLayer === 'function'){ window.showTopicSelectLayer(); }
    });

    row.appendChild(btn);
    ov.__remBtn = btn;
  }

  // Watch Intermediate Start overlay for visibility changes
  const interOv = $('interStartOverlay');
  if (interOv && !interOv.__remWatch){
    const mo = new MutationObserver(() => {
      if (interOv.offsetParent !== null) injectBtn();
    });
    mo.observe(interOv, { attributes:true, attributeFilter:['style','class','open','aria-hidden'] });
    interOv.__remWatch = mo;
    // first run (in case it's already visible)
    setTimeout(injectBtn, 150);
  }

  // optional: console helper to simulate a chosen topic
  window._setRecentTopic = (t) => {
    const n = normTopic(t);
    if (!n) return;
    sessionStorage.setItem('recentTopic', n);
    sessionStorage.setItem('remainingTopics', JSON.stringify(TOPICS.filter(x => x !== n)));
  };
})();

/*-------Reference dock + panel (global)-------*/

(function(){
  const dock  = document.getElementById('refDock');
  const panel = document.getElementById('refPanel');
  const close = panel.querySelector('.ref-close');

  function openRefs(){
    dock.classList.remove('open');           // stop using the “slide to center” mode
  dock.classList.add('is-hidden');         // hide the tab while open
  panel.hidden = false;
  panel.classList.add('show');
  dock.setAttribute('aria-expanded','true');
}
  function closeRefs(){
  panel.classList.remove('show');
  dock.setAttribute('aria-expanded','false');
  setTimeout(() => {
    panel.hidden = true;
    dock.classList.remove('is-hidden');    // reveal tab back at the right edge
  }, 200);
}

  // Show/hide the reference UI when overlays are present
  function isVisible(el){
    if (!el) return false;
    const st = getComputedStyle(el);
    if (st.display === 'none' || st.visibility === 'hidden' || +st.opacity === 0) return false;
    // treat off-screen backdrops as visible too
    return true;
  }
  // REPLACE your overlaysOpen + refreshRefVisibility with these:

function overlaysOpen(){
  // treat app overlays as "open", but ignore our own reference panel
  const sels = [
    '#topicOverlay', '#pickTopicOverlay',
    '[role="dialog"]', '.modal', '.modal-dialog', '.modal-content',
    '.overlay', '.dialog', '.sheet', '.drawer',
    '.modal-backdrop', '.overlay-bg', '.scrim'
  ];
  const refPanel = document.getElementById('refPanel');
  return sels.some(sel =>
    Array.from(document.querySelectorAll(sel)).some(el => {
      // ignore our own references dialog
      if (refPanel && (el === refPanel || refPanel.contains(el))) return false;
      const st = getComputedStyle(el);
      return st.display !== 'none' && st.visibility !== 'hidden' && st.opacity !== '0';
    })
  );
}

function refreshRefVisibility(){
  const panel = document.getElementById('refPanel');
  const dock  = document.getElementById('refDock');

  // if our own panel is open, never hide the dock (it slides to center)
  const selfOpen = panel.classList.contains('show');   // card itself indicates “open”


  const hide = overlaysOpen();
  dock.style.display = (hide && !selfOpen) ? 'none' : 'block';

  // only auto-close references if some OTHER overlay opened
  if (hide && !selfOpen && panel.classList.contains('show')) {
    // call your existing closeRefs() here
    if (typeof closeRefs === 'function') closeRefs();
  }
}


  // wire interactions
  // click the blue tab → open (no toggle)
dock.addEventListener('click', openRefs);
close.addEventListener('click', closeRefs);
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && panel.classList.contains('show')) closeRefs(); });

  // watch DOM for overlay changes
  const mo = new MutationObserver(refreshRefVisibility);
  mo.observe(document.documentElement, {subtree:true, attributes:true, attributeFilter:['class','style'], childList:true});
  window.addEventListener('resize', refreshRefVisibility);
  // initial pass
  refreshRefVisibility();
})();


/*-- Score dock + panel --*/

(function(){
  const QUALIFY_PCT = 95;
  const EASY_IDS = ['easy1','easy60','easy90'];
  const INT_ID   = 'intermediate';

  const statusEl = document.getElementById('skipStatus');
  const goBtn    = document.getElementById('skipFinalGo') || document.getElementById('skipFinalBtn');


  function loadScores(){
    try { return JSON.parse(localStorage.getItem('quiz.scores.v1')) || {}; }
    catch { return {}; }
  }
  function sum(ids, s){
    return ids.reduce((a,id)=>{
      const r = s[id] || {earned:0,total:0};
      a.earned += +r.earned||0;
      a.total  += +r.total||0;
      return a;
    }, {earned:0,total:0});
  }
  const pct = ({earned,total}) => total ? Math.round((earned/total)*100) : NaN;
  const needFor = ({earned,total}, p) => !total ? null : Math.max(0, Math.ceil((p/100)*total - earned));

  function refreshSkipOverlay(){
    const s = loadScores();

    const easySum = sum(EASY_IDS, s);
    const intSum  = sum([INT_ID], s);

    const easyPct = pct(easySum);
    const intPct  = pct(intSum);

    const qualified = (!Number.isNaN(intPct) && intPct >= QUALIFY_PCT) ||
                      (!Number.isNaN(easyPct) && easyPct >= QUALIFY_PCT && !Number.isNaN(intPct) && intPct >= QUALIFY_PCT);

    // enable/disable the button
    if (goBtn) goBtn.disabled = !qualified;

    // status line
    const easyTxt = Number.isNaN(easyPct) ? '—' : `${easyPct}% (${easySum.earned}/${easySum.total})`;
    const intTxt  = Number.isNaN(intPct)  ? '—' : `${intPct}% (${intSum.earned}/${intSum.total})`;

    let msg = `Easy overall: <strong>${easyTxt}</strong> &nbsp;|&nbsp; Intermediate: <strong>${intTxt}</strong><br/>`;
    if (qualified){
      msg += `<span style="color:#10b981">Qualified for Final Challenge.</span>`;
    } else {
      // primary path: Intermediate alone
      const needI = needFor(intSum, QUALIFY_PCT);
      if (needI != null && needI > 0){
        msg += `<span style="color:#f59e0b">Need ${needI} more point${needI===1?'':'s'} in Intermediate to reach ${QUALIFY_PCT}% (instant qualify).</span>`;
      } else {
        // fallback guidance if Intermediate has no attempts yet
        msg += `<span style="color:#f59e0b">Score ≥ ${QUALIFY_PCT}% in Intermediate to qualify, or ≥ ${QUALIFY_PCT}% in both Easy and Intermediate.</span>`;
      }
    }
    if (statusEl) statusEl.innerHTML = msg;
  }

  // Update when scores change (our score board dispatches this)
  document.addEventListener('finalQualificationChanged', refreshSkipOverlay);
  // Also react to cross-tab/localStorage updates just in case
  window.addEventListener('storage', (e)=>{ if (e.key === 'quiz.scores.v1') refreshSkipOverlay(); });

  // Call this when you open the Skip overlay:
  window.openSkipOverlay = function(){
    if (window.scoreDock?.enable) scoreDock.enable(); // you wanted Score button visible on overlays
    refreshSkipOverlay();
    // ...show your overlay here...
  };

  // Run once in case the overlay loads after scores already exist
  refreshSkipOverlay();
})();

/* =========================================================
   SCORE GLUE + SPLIT RULE (50 + 45) — Add-on (no replacements)
   - Mirrors scores into quiz.scores.v1 (idempotent)
   - Harvests Intermediate breakdown from result overlay
   - Computes Final eligibility by split rule:
       Easy bucket (50/50)   = Easy1 + 60s + 90s + Inter-Easy  → need full 50
       Med+Hard bucket (50)  = Inter-Medium + Inter-Hard       → need ≥45
   - Writes localStorage.finalQualified = '1' or '0'
   - Emits 'split95Changed' event with details
   - (Optional) can disable a known Skip button if you turn TAKE_OVER_SKIP_BUTTON = true
   ========================================================= */
(function(){
  // ---------- Config ----------
  const KEY = 'quiz.scores.v1';
  const EASY_IDS = ['easy1','easy60','easy90'];
  const TAKE_OVER_SKIP_BUTTON = false;        // set true if you want this to disable #skipFinalGo directly
  const SKIP_GO_IDS = ['skipFinalGo','skipFinalBtn']; // try these IDs if TAKE_OVER_SKIP_BUTTON is true

  // ---------- Safe storage helpers ----------
  const readScores = () => { try { return JSON.parse(localStorage.getItem(KEY)) || {}; } catch { return {}; } };
  const writeScores = (obj) => { try { localStorage.setItem(KEY, JSON.stringify(obj)); } catch {} };

  // ---------- Mirror/wrap existing updateSectionScore (idempotent) ----------
  const prevUpdate = window.updateSectionScore;
  window.updateSectionScore = function(sectionId, earned, total){
    // Call any existing implementation first
    if (typeof prevUpdate === 'function') try { prevUpdate.apply(this, arguments); } catch {}
    // Mirror into our store (last write wins; harmless if same values)
    const s = readScores();
    s[sectionId] = { earned:+earned||0, total:+total||0, ts: Date.now() };
    writeScores(s);
    // Kick recompute
    recomputeSplitRule();
  };

(function(){
  const KEY = 'quiz.scores.v1';

  // --- helpers ---
  const read = () => { try { return JSON.parse(localStorage.getItem(KEY))||{}; } catch { return {}; } };
  const write = (obj) => { try { localStorage.setItem(KEY, JSON.stringify(obj)); } catch {} };
  const i = (sel) => document.querySelector(sel);
  const geti = (sel) => {
  const el = i(sel); if (!el) return 0;  const m = String(el.textContent).replace(/,/g,'').match(/-?\d+(?:\.\d+)?/);
  return m ? Math.round(parseFloat(m[0])) : 0;   // 2.00 → 2, 1.5 → 2
};
  const fire = (name, detail) => document.dispatchEvent(new CustomEvent(name, {detail}));

  function recompute60Aggregate(){
    const s = read();
    const sor = +s.sor60?.earned || 0;
    const wlr = +s.weir60?.earned || 0;     // from #weir60FinalScore
    const det = +s.det60?.earned || 0;      // from #det60FinalScore
    s.easy60 = { earned: sor + wlr + det, total: +(s.easy60?.total||0), ts: Date.now() };
    write(s);
    // nudge any UIs that subscribe
    fire('finalQualificationChanged'); 
    fire('scoresChanged', {section:'easy60', earned:s.easy60.earned, total:s.easy60.total});
    // if your Score board exposes a render, refresh it live
    if (window.scoreDock && typeof scoreDock.refresh==='function') scoreDock.refresh();
  }

  function setBest(key, val){
    const s = read();
    const prev = +s[key]?.earned || 0;
    if (val > prev){
      s[key] = { earned: val, total: +(s[key]?.total||0), ts: Date.now() };
      write(s);
      recompute60Aggregate();
    }
  }

  function observeOverlay(overlaySel, scoreSel, key){
    const ov = i(overlaySel);
    if (!ov) return;
    const pump = () => {
      // when the overlay shows or the score text changes, capture
      const v = geti(scoreSel);
      if (v>=0) setBest(key, v);
    };
    // watch visibility (style/class changes)
    new MutationObserver(pump).observe(ov, {attributes:true, attributeFilter:['style','class']});
    // watch score text itself
    const scoreEl = i(scoreSel);
    if (scoreEl){
      new MutationObserver(pump).observe(scoreEl, {childList:true, subtree:true, characterData:true});
    }
  }

  // --- hook all three 60s modes by their real IDs in your file ---
  // SOR 60s (range)
  observeOverlay('#rangeResultOverlay',   '#rangeFinalScore',   'sor60');     // (present in your SOR Part-2)
  // WEIR 60s
  observeOverlay('#weir60ResultOverlay',  '#weir60FinalScore',  'weir60');    // “Final:” value is in #weir60FinalScore :contentReference[oaicite:4]{index=4}
  // DETENTION 60s
  observeOverlay('#det60ResultOverlay',   '#det60FinalScore',   'det60');     // “Final:” value is in #det60FinalScore :contentReference[oaicite:5]{index=5}

  // run once on load (in case something was already shown)
  recompute60Aggregate();
})();


  // Also listen to your existing generic event, if used anywhere
  document.addEventListener('quizScore', (e)=>{
    const d = e.detail || {};
    if (!d.section) return;
    const s = readScores();
    s[d.section] = { earned:+d.earned||0, total:+d.total||0, ts: Date.now() };
    // (optional breakdown if provided)
    if (d.section === 'intermediate' && d.byMode){
      const by = d.byMode || {};
      s.intermediateBreakdown = {
        easy:   {earned:+by.easy||0,     total: +(+s.intermediateBreakdown?.easy?.total || 0)}, // totals may be unknown here
        medium: {earned:+by.standard||0, total: +(+s.intermediateBreakdown?.medium?.total || 0)},
        hard:   {earned:+by.hard||0,     total: +(+s.intermediateBreakdown?.hard?.total || 0)}
      };
      s.__interBreakdown = {easy:+by.easy||0, standard:+by.standard||0, hard:+by.hard||0}; // legacy flat
    }
    writeScores(s);
    recomputeSplitRule();
  });

  // ---------- Harvest Intermediate breakdown from your Result overlay UI ----------
  // Your file has #interResultOverlay and #interResultMsg; we read the lines like “Easy … x/y pts” etc.  :contentReference[oaicite:1]{index=1}
  function grab(labelRe, text){
    const rx = new RegExp(String(labelRe) + '[^\\n]*?(\\d+)\\s*/\\s*(\\d+)\\s*pts', 'i');
    const m = text.match(rx);
    return m ? { earned:+m[1], total:+m[2] } : null;
  }
  function harvestIntermediateBreakdown(){
    const msg = document.getElementById('interResultMsg');
    if (!msg) return;
    const t = (msg.textContent || '').replace(/\u00a0/g,' ');
    const E = grab('Easy', t) || {earned:0,total:0};
    const M = grab('Standard|Medium', t) || {earned:0,total:0};
    const H = grab('Hard', t) || {earned:0,total:0};
    const s = readScores();
    s.intermediateBreakdown = { easy:E, medium:M, hard:H, ts: Date.now() };
    s.__interBreakdown = { easy:E.earned, standard:M.earned, hard:H.earned }; // flat
    writeScores(s);
    recomputeSplitRule();
  }
  (function watchInterOverlay(){
    const ov  = document.getElementById('interResultOverlay'); // :contentReference[oaicite:2]{index=2}
    const msg = document.getElementById('interResultMsg');     // :contentReference[oaicite:3]{index=3}
    if (!ov || !msg) return;
    // When overlay shows
    new MutationObserver(() => {
      const vis = ov.style.display && ov.style.display !== 'none';
      if (vis) harvestIntermediateBreakdown();
    }).observe(ov, {attributes:true, attributeFilter:['style','class']});
    // When message updates
    new MutationObserver(harvestIntermediateBreakdown)
      .observe(msg, {childList:true, subtree:true, characterData:true});
  })();

  // ---------- Split rule (50 + 45) ----------
  function sumSections(ids, s){
    return ids.reduce((a,id)=>{
      const r = s[id] || {earned:0,total:0};
      a.earned += (+r.earned||0); a.total += (+r.total||0); return a;
    }, {earned:0,total:0});
  }
  function outOf50(earned, total){
    if (!total) return 0;
    const v = 50 * (earned/total);
    return Math.max(0, Math.min(50, v));
  }
  function needMore(targetOutOf50, earned, total){
    if (!total) return null;           // not computable yet
    const targetPct = targetOutOf50/50;
    return Math.max(0, Math.ceil(targetPct*total - earned));
  }

  function recomputeSplitRule(){
    const s = readScores();
    // Bucket A (Easy) = Easy1 + 60s + 90s + Inter-Easy
    const easySecs = sumSections(EASY_IDS, s);
    const ib = s.intermediateBreakdown || {easy:{earned:0,total:0}, medium:{earned:0,total:0}, hard:{earned:0,total:0}};
    const easyBucket = {
      earned: (easySecs.earned||0) + (+ib.easy?.earned||0),
      total:  (easySecs.total ||0) + (+ib.easy?.total ||0)
    };
    const easyOutOf50 = outOf50(easyBucket.earned, easyBucket.total);   // need full 50

    // Bucket B (Med+Hard) = Inter-Medium + Inter-Hard
    const mh = {
      earned: (+ib.medium?.earned||0) + (+ib.hard?.earned||0),
      total:  (+ib.medium?.total ||0) + (+ib.hard?.total ||0)
    };
    const mhOutOf50 = outOf50(mh.earned, mh.total);                      // need ≥45

    const qualified = (easyOutOf50 >= 50) && (mhOutOf50 >= 45);

    // Persist for any existing code that reads this flag
    localStorage.setItem('finalQualified', qualified ? '1' : '0');

    // (Optional) take over a known Skip button
    if (TAKE_OVER_SKIP_BUTTON){
      for (const id of SKIP_GO_IDS){
        const btn = document.getElementById(id);
        if (btn){ btn.disabled = !qualified; break; }
      }
    }

    // Broadcast a rich status so your Score board/Skip overlay can show guidance if desired
    const needA = needMore(50, easyBucket.earned, easyBucket.total);
    const needB = needMore(45, mh.earned, mh.total);
    document.dispatchEvent(new CustomEvent('split95Changed', {
      detail:{
        qualified,
        easyBucket: { earned:easyBucket.earned, total:easyBucket.total, outOf50:Math.round(easyOutOf50) },
        medHard:    { earned:mh.earned,        total:mh.total,        outOf50:Math.round(mhOutOf50) },
        need: { easyBucket: needA, medHard: needB }
      }
    }));
  }

  // Recompute whenever scores/localStorage change
  window.addEventListener('storage', (e)=>{ if (e.key === KEY) recomputeSplitRule(); });
  // First pass
  recomputeSplitRule();
})();

/*------Score dock rescue wiring------*/
(function(){
  const dock  = document.getElementById('scoreDock');
  const panel = document.getElementById('scorePanel');
  const close = panel?.querySelector('.score-close');
  if (!dock || !panel) return;

  if (!dock.__wired){
    dock.__wired = true;

    // hide on Welcome by default
    dock.style.display = 'none';

    function openBoard(){
      dock.classList.add('is-hidden');
      panel.hidden = false;
      panel.classList.add('show');
      dock.setAttribute('aria-expanded','true');
    }
    function closeBoard(){
      panel.classList.remove('show');
      dock.setAttribute('aria-expanded','false');
      setTimeout(()=>{ panel.hidden = true; dock.classList.remove('is-hidden'); }, 200);
    }

    dock.addEventListener('click', openBoard);
    close?.addEventListener('click', closeBoard);
    document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && panel.classList.contains('show')) closeBoard(); });

    // public API so the rest of your site can show/hide it
    window.scoreDock = {
      enable(){ dock.style.display = 'flex'; },
      disable(){ dock.style.display = 'none'; }
    };
  }
})();

/*---Score button visibility-----*/

(function(){
  const dock  = document.getElementById('scoreDock');
  const panel = document.getElementById('scorePanel');
  if (!dock || !panel) { console.warn('Score: #scoreDock or #scorePanel not found.'); return; }

  // make sure CSS can't keep it hidden
  dock.style.display = 'flex';
  dock.style.zIndex  = '2147483600';

  if (dock.__wired) return;
  dock.__wired = true;

  const close = panel.querySelector('.score-close');

  function openBoard(){
    dock.classList.add('is-hidden');
    panel.hidden = false;
    panel.classList.add('show');
    dock.setAttribute('aria-expanded','true');
  }
  function closeBoard(){
    panel.classList.remove('show');
    dock.setAttribute('aria-expanded','false');
    setTimeout(()=>{ panel.hidden = true; dock.classList.remove('is-hidden'); }, 200);
  }

  // click wiring
  dock.addEventListener('click', openBoard);
  close && close.addEventListener('click', closeBoard);
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && panel.classList.contains('show')) closeBoard(); });

  // public API other code can call
  window.scoreDock = {
    enable(){ dock.style.display = 'flex'; },
    disable(){ dock.style.display = 'none'; }
  };

  // show it now so you can confirm it's working
  window.scoreDock.enable();
})();

/*----Score numbers----*/
(function(){
  const KEY = 'quiz.scores.v1';

  // --- dom helpers: make containers if missing ---
  function ensureContainers(){
    const panel = document.getElementById('scorePanel');
    if (!panel) return {};
    let table  = document.getElementById('scoreTable');
    let footer = document.getElementById('scoreFooter');

    // find a sensible place to insert (prefer a body/content node if present)
    const host =
      panel.querySelector('.score-body, .score-content, .col-body') || panel;

    if (!table){
      table = document.createElement('div');
      table.id = 'scoreTable';
      table.style.padding = '12px 16px';
      host.appendChild(table);
    }
    if (!footer){
      footer = document.createElement('div');
      footer.id = 'scoreFooter';
      footer.style.padding = '12px 16px';
      footer.style.borderTop = '1px solid rgba(255,255,255,.08)';
      host.appendChild(footer);
    }
    return {table, footer};
  }

  // --- storage + math ---
  function loadScores(){ try { return JSON.parse(localStorage.getItem(KEY)) || {}; } catch { return {}; } }
  function sum(ids, s){
    return ids.reduce((a,id)=>{
      const r = s[id] || {earned:0,total:0};
      a.earned += +r.earned||0; a.total += +r.total||0; return a;
    }, {earned:0,total:0});
  }
  // for the split rule footer
  function outOf50(earned, total){ return !total ? 0 : Math.max(0, Math.min(50, 50*(earned/total))); }
  function needMore(targetOutOf50, earned, total){
    if (!total) return null;
    const targetPct = targetOutOf50/50;
    return Math.max(0, Math.ceil(targetPct*total - earned));
  }

  // --- renderer (points-only view + split-rule “need” line) ---
  function renderBoard(){
    const {table, footer} = ensureContainers();
    if (!table || !footer) return;

    const s = loadScores();

    // section totals (points only)
    const easy1 = +((s.easy1   && s.easy1.earned)   || 0);
    const easy60= +((s.easy60  && s.easy60.earned)  || 0);
    const easy90= +((s.easy90  && s.easy90.earned)  || 0);
    const inter = +((s.intermediate && s.intermediate.earned) || 0);

    table.innerHTML = `
      <div class="score-row"><div class="name">Easy (Part-1)</div><div class="value">${easy1}</div></div>
      <div class="score-row"><div class="name">60 sec</div><div class="value">${easy60}</div></div>
      <div class="score-row"><div class="name">90 sec</div><div class="value">${easy90}</div></div>
      <div class="score-row"><div class="name">Intermediate (total)</div><div class="value">${inter}</div></div>
    `;

    // split-95 footer hint (uses breakdown if present)
    const ib = s.intermediateBreakdown || {easy:{earned:0,total:0}, medium:{earned:0,total:0}, hard:{earned:0,total:0}};
    const easyBucketEarn = easy1 + easy60 + easy90 + (+ib.easy.earned||0);
    const easyBucketTot  = (+s.easy1?.total||0)+(+s.easy60?.total||0)+(+s.easy90?.total||0)+(+ib.easy.total||0);
    const mhEarn = (+ib.medium.earned||0) + (+ib.hard.earned||0);
    const mhTot  = (+ib.medium.total ||0) + (+ib.hard.total ||0);

    const easyOut = outOf50(easyBucketEarn, easyBucketTot);
    const mhOut   = outOf50(mhEarn, mhTot);
    const needA   = needMore(50, easyBucketEarn, easyBucketTot);
    const needB   = needMore(45, mhEarn, mhTot);

    footer.innerHTML =
      (easyOut >= 50 && mhOut >= 45)
        ? `<span class="ok">Qualified for Final Challenge.</span>`
        : `<span class="need">${
            needA == null ? 'Play some rounds to build Easy bucket' :
            (needA > 0 ? `Need <strong>${needA}</strong> more point${needA===1?'':'s'} in Easy bucket` : 'Easy bucket is complete')
          }${
            (needB == null ? '' : (needA!=null ? ' · ' : '')) +
            (needB == null ? '' :
              (needB > 0 ? `Need <strong>${needB}</strong> more point${needB===1?'':'s'} in Medium+Hard` :
                           'Medium+Hard bucket is ready')
            )
          }.</span>`;
  }

  // expose so other scripts can call if needed
  window.renderScoreBoard = renderBoard;

  // render whenever the panel opens
  (function wireOpen(){
    const dock  = document.getElementById('scoreDock');
    const panel = document.getElementById('scorePanel');
    if (!dock || !panel) return;
    dock.addEventListener('click', renderBoard, {once:false});
  })();

  // refresh on data changes too
  document.addEventListener('split95Changed', renderBoard);
  window.addEventListener('storage', (e)=>{ if (e.key === KEY) renderBoard(); });
})();


/* ===================== LIVE SCORE MIRROR (no quiz edits) =====================
   - Watches visible quiz panels for "Score: N" changes and mirrors N
     into localStorage('quiz.scores.v1') under the right section key.
   - Uses result overlays to capture accurate TOTALS; live updates only
     change EARNED so your footer math remains correct.
   - Treats SOR Easy Part-1 and WLR Easy Part-1 as the same bucket: 'easy1'.
   ========================================================================== */
(function(){
  const KEY = 'quiz.scores.v1';

  // ---- storage helpers ----
  const load = () => { try { return JSON.parse(localStorage.getItem(KEY)) || {}; } catch { return {}; } };
  const save = (s)  => { try { localStorage.setItem(KEY, JSON.stringify(s)); } catch {} };
  function pushEarned(section, earned){
    const s = load();
    const prev = s[section] || {earned:0,total:0};
    if (+prev.earned === +earned) return;        // no spam
    s[section] = { earned:+earned||0, total:+prev.total||0, ts: Date.now() };
    save(s);
    document.dispatchEvent(new CustomEvent('quizScore',{detail:{section, earned:+earned||0, total:+prev.total||0, progress:true}}));
    try { window.renderScoreBoard?.(); } catch {}
  }
  function pushFinal(section, earned, total){
    const s = load();
    s[section] = { earned:+earned||0, total:+total||0, ts: Date.now() };
    save(s);
    document.dispatchEvent(new CustomEvent('quizScore',{detail:{section, earned:+earned||0, total:+total||0}}));
    try { window.renderScoreBoard?.(); } catch {}
  }

  // ---- 1) LIVE watchers: look for "Score: N" inside visible panels ----
  // Map visible panel → scoreboard section key
  const PANEL_MAP = [
    { section:'easy1', sel:'#sorQuiz'   },  // SOR Easy Part-1
    { section:'easy1', sel:'#weirQuiz'  },  // WLR Easy Part-1 (same bucket)
    { section:'easy60',sel:'#det60Panel,#sec60Panel,#quiz60' },
    { section:'easy90',sel:'#det90Panel,#sec90Panel,#quiz90' },
    { section:'intermediate', sel:'#interPanel,#intermediatePanel' }
  ];

  // For each panel, which nodes likely carry "Score: N"
  const SCORE_NODE_SEL = [
    '[id$="Score"]', '.weir-score', '.sor-score', '.det-score', '.score', '.q-score'
  ].join(',');

  function visible(el){ return !!el && el.offsetParent !== null; }
  function parseScoreText(txt){
    const m = String(txt||'').match(/Score\s*:\s*(\d+)/i);
    return m ? +m[1] : null;
  }

  function scanAndMirror(){
    PANEL_MAP.forEach(m=>{
      const panel = document.querySelector(m.sel);
      if (!panel || !visible(panel)) return;
      const node  = panel.querySelector(SCORE_NODE_SEL);
      if (!node) return;
      const val = parseScoreText(node.textContent);
      if (val != null) pushEarned(m.section, val);
    });
  }

  // Observe DOM changes and rescan (throttled)
  let t = null;
  const rescan = ()=>{ if (t) return; t = requestAnimationFrame(()=>{ t=null; scanAndMirror(); }); };
  new MutationObserver(rescan).observe(document.documentElement, {subtree:true, childList:true, characterData:true, attributes:true});
  document.addEventListener('click', rescan, true);       // user interactions often change the score
  document.addEventListener('keyup', rescan, true);

  // ---- 2) RESULT OVERLAY scrapers to capture FINAL earned/total ----
  // 60s
  watchOverlay('easy60',
    '#det60ResultOverlay, #sec60ResultOverlay, #result60Overlay',
    '#det60ResultMsg,    #sec60ResultMsg,    #result60Msg'
  );
  // 90s
  watchOverlay('easy90',
    '#det90ResultOverlay, #sec90ResultOverlay, #result90Overlay',
    '#det90ResultMsg,    #sec90ResultMsg,    #result90Msg'
  );
  // Intermediate (total)
  watchOverlay('intermediate',
    '#interResultOverlay',
    '#interResultMsg'
  );

  function watchOverlay(section, overlaySel, msgSel){
    const ov  = document.querySelector(overlaySel);
    const msg = document.querySelector(msgSel);
    if (!ov || !msg) return;
    const extract = txt => {
      const m = String(txt||'').replace(/\u00a0/g,' ').match(/(\d+)\s*\/\s*(\d+)\s*(?:pts?)?/i);
      return m ? { earned:+m[1], total:+m[2] } : null;
    };
    const harvest = ()=>{
      const r = extract(msg.textContent);
      if (r && r.total > 0) pushFinal(section, r.earned, r.total);
    };
    new MutationObserver(()=>{ const vis = ov.style.display && ov.style.display!=='none'; if (vis) harvest(); })
      .observe(ov, {attributes:true, attributeFilter:['style','class']});
    new MutationObserver(harvest).observe(msg, {childList:true, subtree:true, characterData:true});
  }

  // ---- 3) Intermediate difficulty breakdown (optional but helps split rule) ----
  // Scrape Easy/Medium(Standard)/Hard lines from Intermediate result message
  (function harvestInterBreakdown(){
    const ov  = document.getElementById('interResultOverlay');
    const msg = document.getElementById('interResultMsg');
    if (!ov || !msg) return;
    function grab(labelRe, text){
      const rx = new RegExp(String(labelRe)+'[^\\n]*?(\\d+)\\s*/\\s*(\\d+)\\s*pts','i');
      const m  = text.match(rx); return m ? {earned:+m[1], total:+m[2]} : null;
    }
    const saveBreakdown = ()=>{
      const t = (msg.textContent||'').replace(/\u00a0/g,' ');
      const E = grab('Easy', t) || {earned:0,total:0};
      const M = grab('Standard|Medium', t) || {earned:0,total:0};
      const H = grab('Hard', t) || {earned:0,total:0};
      const s = load();
      s.intermediateBreakdown = { easy:E, medium:M, hard:H, ts:Date.now() };
      s.__interBreakdown      = { easy:E.earned, standard:M.earned, hard:H.earned }; // legacy flat
      save(s);
      document.dispatchEvent(new CustomEvent('quizScore',{detail:{section:'intermediate', earned:s.intermediate?.earned||0, total:s.intermediate?.total||0}}));
      try { window.renderScoreBoard?.(); } catch {}
    };
    new MutationObserver(()=>{ const vis = ov.style.display && ov.style.display!=='none'; if (vis) saveBreakdown(); })
      .observe(ov, {attributes:true, attributeFilter:['style','class']});
    new MutationObserver(saveBreakdown).observe(msg, {childList:true, subtree:true, characterData:true});
  })();

  // First pass (in case a panel is already visible)
  scanAndMirror();
})();


/* === Scoreboard glue for 90-sec results (SOR-only, Weir-90, Det-90) ===
   - Reads the final score from the result overlays:
       #sorOnlyResultOverlay  -> #sorOnlyFinalScore
       #weir90ResultOverlay   -> #weir90FinalScore
       #det90ResultOverlay    -> #det90FinalScore
   - Stores them under quiz.scores.v1 keys:
       easy90_sor, easy90_weir, easy90_det
   - Aggregates those into a single easy90 entry so your board shows the sum.
*/
(function(){
  const KEY = 'quiz.scores.v1';

  const read = () => { try { return JSON.parse(localStorage.getItem(KEY)) || {}; } catch { return {}; } };
  const write = (obj) => { try { localStorage.setItem(KEY, JSON.stringify(obj)); } catch {} };

  function setScore(id, earned){
    const s = read();
    s[id] = { earned: +earned || 0, total: +earned || 0, ts: Date.now() };
    write(s);
    aggregate90();         // keep the visible “90 sec” number in sync
    // let anything listening refresh itself
    document.dispatchEvent(new Event('finalQualificationChanged'));
    document.dispatchEvent(new Event('scoreChanged'));
  }

  function aggregate90(){
    const s = read();
    const sum = ['easy90_sor','easy90_weir','easy90_det']
      .reduce((a,k)=> a + (+s[k]?.earned||0), 0);
    s.easy90 = { earned: sum, total: sum, ts: Date.now() };
    write(s);
  }

  function bindWatcher(overlayId, scoreId, storeKey){
    const ov   = document.getElementById(overlayId);
    const span = document.getElementById(scoreId);
    if (!ov || !span) return;

    // when overlay is shown, read current score
    const onShow = () => {
      const shown = (ov.style.display && ov.style.display !== 'none') || ov.classList.contains('show');
      if (!shown) return;
      const val = parseFloat(String(span.textContent).replace(/[^0-9.+-]/g,'')) || 0;
      setScore(storeKey, val);
    };

    // watch overlay visibility
    new MutationObserver(onShow).observe(ov, { attributes:true, attributeFilter:['style','class'] });
    // watch score text change (some flows update text before showing)
    new MutationObserver(onShow).observe(span, { childList:true, characterData:true, subtree:true });
    // one pass in case it is already visible
    onShow();
  }

  // Hook up the three 90-sec result cards
  bindWatcher('sorOnlyResultOverlay', 'sorOnlyFinalScore', 'easy90_sor');   // SOR-only 90s
  bindWatcher('weir90ResultOverlay',   'weir90FinalScore',   'easy90_weir'); // Weir 90s
  bindWatcher('det90ResultOverlay',    'det90FinalScore',    'easy90_det');  // Detention 90s
})();

/* ===== Intermediate scoreboard glue (uses your #interResultOverlay / #interResultMsg) ===== */
(function(){
  const KEY = 'quiz.scores.v1';

  const read  = () => { try { return JSON.parse(localStorage.getItem(KEY)) || {}; } catch { return {}; } };
  const write = (obj) => { try { localStorage.setItem(KEY, JSON.stringify(obj)); } catch {} };

  // grab "Label ... 12 / 20 pts"
  function grab(labelRe, text){
    const rx = new RegExp(String(labelRe) + '[^\\n]*?(\\d+)\\s*/\\s*(\\d+)\\s*pts?', 'i');
    const m  = text.match(rx);
    return m ? { earned:+m[1], total:+m[2] } : { earned:0, total:0 };
  }

  function harvestAndStore(){
    const msg = document.getElementById('interResultMsg');
    if (!msg) return;
    const t = (msg.textContent || '').replace(/\u00a0/g,' ');

    const E = grab('Easy', t);
    const M = grab('Standard|Medium', t);
    const H = grab('Hard', t);

    const totalEarn = E.earned + M.earned + H.earned;
    const totalMax  = E.total  + M.total  + H.total;

    const s = read();
    s.intermediate = { earned: totalEarn, total: totalMax, ts: Date.now() };
    s.intermediateBreakdown = { easy:E, medium:M, hard:H, ts: Date.now() };
    // legacy flat (if anything else reads it)
    s.__interBreakdown = { easy:E.earned, standard:M.earned, hard:H.earned };

    write(s);

    // notify UIs
    document.dispatchEvent(new Event('finalQualificationChanged'));
    document.dispatchEvent(new CustomEvent('scoresChanged', {detail:{section:'intermediate', earned:totalEarn, total:totalMax}}));
    if (typeof window.renderScoreBoard === 'function') window.renderScoreBoard();
  }

  // watch the overlay to know when to harvest
  (function watch(){
    const ov  = document.getElementById('interResultOverlay');
    const msg = document.getElementById('interResultMsg');
    if (!ov || !msg) return;

    const onShow = () => {
      const shown = (ov.style.display && ov.style.display !== 'none') || ov.classList.contains('show');
      if (shown) harvestAndStore();
    };

    // overlay visibility changes
    new MutationObserver(onShow)
      .observe(ov, {attributes:true, attributeFilter:['style','class']});

    // message text updates
    new MutationObserver(harvestAndStore)
      .observe(msg, {childList:true, subtree:true, characterData:true});

    // just in case it's already visible
    onShow();
  })();
})();

/*=====script to hide Score on Welcome / Start and only show it in practice paths====*/
document.addEventListener('DOMContentLoaded', function(){
  const scoreDock = document.getElementById('scoreDock');

  // Helpers
  function hideScore(){ if(scoreDock){ scoreDock.style.display = 'none'; } }
  function showScore(){ if(scoreDock){ scoreDock.style.display = 'flex'; } }

  // 1) On first load (Welcome / Start overlays), keep Score hidden
  hideScore();

  // 2) Show Score only on practice paths (Easy / Intermediate)
  const btnEasy  = document.getElementById('ctaEasy');
  const btnInter = document.getElementById('ctaInter');
  if (btnEasy)  btnEasy.addEventListener('click', showScore);
  if (btnInter) btnInter.addEventListener('click', showScore);

  // 3) Make sure Score stays hidden on Final-related flows
  const finalButtons = [
    document.getElementById('startBtn'),         // goes from Start overlay → welcome flow
    document.getElementById('finalProBtn'),
    document.getElementById('finalBeginBtn'),
    document.getElementById('finalPreviewTry'),
    document.getElementById('finalPreviewResume'),
    document.getElementById('finalPreviewExit')
  ];
  finalButtons.forEach(btn => {
    if (btn) btn.addEventListener('click', hideScore);
  });

  // 4) Defensive: if some other code toggles Final later, react to body class changes
  const observer = new MutationObserver(() => {
    if (document.body.classList.contains('final-mode')) {
      hideScore();
    }
  });
  observer.observe(document.body, { attributes: true, attributeFilter: ['class'] });
});

</script>
</body>
</html>
